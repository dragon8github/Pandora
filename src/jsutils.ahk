!u::

    Menu, utilsworker, Add, 项目名：功能说明, utilsHandler


    Menu, utilsTime, Add, toLocaleString：获取中文后缀的时间（1月/一月）, utilsHandler
	Menu, utilsTime, Add, 获取半小时前, utilsHandler
    Menu, utilsTime, Add, 获取当前时间的秒数, utilsHandler
    Menu, utilsTime, Add, 获取12345的时间选择器, utilsHandler
    Menu, utilsTime, Add, 获取指定时间戳, utilsHandler
    Menu, utilsTime, Add, 格式化当前时间, utilsHandler
    Menu, utilsTime, Add, 返回指定时间戳之间的时间间隔, utilsHandler
    Menu, utilsTime, Add, 按类型格式化日期, utilsHandler
    Menu, utilsTime, Add, 验证一个日期是不是今天, utilsHandler
    Menu, utilsTime, Add, 本月最后一天, utilsHandler
    Menu, utilsTime, Add, 今日最晚时间 23:59:59 的时间戳, utilsHandler
    Menu, utilsTime, Add, 获取当前时间的前一天/后一天的时间戳, utilsHandler
    Menu, utilsTime, Add, 验证日期大小, utilsHandler
    Menu, utilsTime, Add, 设置几天后的日期, utilsHandler
    Menu, utilsTime, Add, 获取前6个月/前15天数据, utilsHandler


    Menu, utilsIs, Add, is, utilsHandler
    Menu, utilsIs, Add, isRegExp 是否为正则表达式, utilsHandler
    Menu, utilsIs, Add, isString, utilsHandler
    Menu, utilsIs, Add, isURL, utilsHandler
    Menu, utilsIs, Add, isNumber, utilsHandler
    Menu, utilsIs, Add, isBoolean, utilsHandler
    Menu, utilsIs, Add, isArray, utilsHandler
    Menu, utilsIs, Add, isObject, utilsHandler
    Menu, utilsIs, Add, isPlainObject, utilsHandler
    Menu, utilsIs, Add, isPureObject, utilsHandler
    Menu, utilsIs, Add, isFunction, utilsHandler
    Menu, utilsIs, Add, isDate, utilsHandler
    Menu, utilsIs, Add, isPromise, utilsHandler
    Menu, utilsIs, Add, isNaN, utilsHandler
    Menu, utilsIs, Add, isNodeList, utilsHandler
    Menu, utilsIs, Add, isHtml：div instanceof HTMLElement, utilsHandler
    Menu, utilsIs, Add, 判断是否为数字：!isNaN(+params.id), utilsHandler

    Menu, utilsIs, Add, , utilsHandler
    Menu, utilsIs, Add, , utilsHandler

    Menu, utilsIs, Add, isZH-Cn, utilsHandler
    Menu, utilsIs, Add, isIp, utilsHandler
    Menu, utilsIs, Add, isPhone, utilsHandler
    Menu, utilsIs, Add, isPwd, utilsHandler
    Menu, utilsIs, Add, isUser, utilsHandler
    Menu, utilsIs, Add, isId, utilsHandler
    Menu, utilsIs, Add, isEmail, utilsHandler
    Menu, utilsIs, Add, is-wx, utilsHandler
    Menu, utilsIs, Add, is-ie, utilsHandler
    Menu, utilsIs, Add, is-mobile:判断是否为移动端, utilsHandler
    Menu, utilsIs, Add, isBottom 是否滚动到底部, utilsHandler
    
    
    Menu, utilsDOM, Add, 超灵活的insert：insertAdjacentElement/insertAdjacentHTML, utilsHandler
    Menu, utilsDOM, Add, dom.js, utilsHandler
    Menu, utilsDOM, Add, document.createComment 往DOM插入一个注释, utilsHandler
    Menu, utilsDOM, Add, 虚拟节点 document.createDocumentFragment, utilsHandler

    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add


    Menu, utilsDOM, Add, parents, utilsHandler
    Menu, utilsDOM, Add, addClass, utilsHandler
    Menu, utilsDOM, Add, toggleClass, utilsHandler
    Menu, utilsDOM, Add, hasClass, utilsHandler
    Menu, utilsDOM, Add, removeclass , utilsHandler
    Menu, utilsDOM, Add, getclassname, utilsHandler
    Menu, utilsDOM, Add, getstyle, utilsHandler
    Menu, utilsDOM, Add, setStyle, utilsHandler
    Menu, utilsDOM, Add, setattr, utilsHandler
    Menu, utilsDOM, Add, removeattr, utilsHandler
    Menu, utilsDOM, Add, getComputedStyle(el)['height'], utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, create 创建元素, utilsHandler
    Menu, utilsDOM, Add, create 创建img, utilsHandler
    Menu, utilsDOM, Add, 插入body前面, utilsHandler
    Menu, utilsDOM, Add, 插入body后面, utilsHandler
    Menu, utilsDOM, Add, img判断加载完成, utilsHandler
    Menu, utilsDOM, Add, 克隆dom的认知：深浅克隆 document.querySelector('.layer').cloneNode(true), utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, getElementPosition 获取元素的定位, utilsHandler
    Menu, utilsDOM, Add, gettop 获取距离顶部的相对距离, utilsHandler
    Menu, utilsDOM, Add, scrollToTop 滚动到头部, utilsHandler
    Menu, utilsDOM, Add, scrollIntoView 滚动到元素可视区域, utilsHandler
    Menu, utilsDOM, Add, scrollIntoView 滚动到元素可视区域（代码实现）, utilsHandler
    Menu, utilsDOM, Add, isBottom 是否滚动到底部, utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, injectCss 往页面插入style, utilsHandler
    Menu, utilsDOM, Add, getScriptPath, utilsHandler
    Menu, utilsDOM, Add, onscript/loadscript 加载脚本并等待加载完成, utilsHandler
    Menu, utilsDOM, Add, addcss/link 样式加载器, utilsHandler
    Menu, utilsDOM, Add, 是否隐藏：$('#div').is(':hidden'), utilsHandler
    Menu, utilsDOM, Add, 是否显示：$('#div').is(':visible'), utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    
    Menu, utilsDOM, Add, mask蒙版, utilsHandler
    Menu, utilsDOM, Add, clickOutSide：!el.contains(event.target), utilsHandler
    Menu, utilsDOM, Add, HTML缓存数据：e.dataset 与 data-fuck-you, utilsHandler
    Menu, utilsDOM, Add, 获取当前所在的<script>：document.currentScript, utilsHandler
    Menu, utilsDOM, Add, 获取当前所在的<iframe>：window.frameElement, utilsHandler
    Menu, utilsDOM, Add, mvDOM：移动dom元素到指定目标位置, utilsHandler
    Menu, utilsDOM, Add, document.activeElement.blur(), utilsHandler
    Menu, utilsDOM, Add, 滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop, utilsHandler
    
    Menu, utilsPosition, Add, 获取网页被卷去的位置, utilsHandler
    Menu, utilsPosition, Add, isVisualRange：是否处于可视视图中, utilsHandler


    Menu, utilsPosition, Add, 🍁🍁🍁🍁🍁🍁🍁🍁 element 的定位要素 🍁🍁🍁🍁🍁🍁🍁🍁, utilsHandler
    Menu, utilsPosition, Add, - el.clientHeight：可视高度 , utilsHandler
    Menu, utilsPosition, Add, - el.scrollHeight：真实高度（含滚动条） , utilsHandler
    Menu, utilsPosition, Add, - el.getBoundingClientRect().top：相对窗口的距离 , utilsHandler
    Menu, utilsPosition, Add, - el.scrollTop: 视口可见的顶部，到绝对顶部的距离, utilsHandler 
    
    Menu, utilsPosition, Add, 🍁🍁🍁🍁🍁🍁🍁🍁 event 的定位要素 🍁🍁🍁🍁🍁🍁🍁🍁, utilsHandler
    Menu, utilsPosition, Add, - e.clientY：客户端浏览器视口所在的位置, utilsHandler
    Menu, utilsPosition, Add, - e.pageY：页面所在的位置, utilsHandler
    Menu, utilsPosition, Add, - e.screenY：屏幕所在的位置, utilsHandler
    
    Menu, utilsPosition, Add, 🍁🍁🍁🍁🍁🍁🍁🍁 offset 系列 🍁🍁🍁🍁🍁🍁🍁🍁, utilsHandler
    Menu, utilsPosition, Add, - offsetWidth：getComputedStyle(el).width 返回的可能是百分比，offsetWidth总是返回数值, utilsHandler
    Menu, utilsPosition, Add, - offsetTop：元素相对于定位元素（position默认是body）的偏移量（含scroll）, utilsHandler

    Menu, utilsPosition, Add, 🍁🍁🍁🍁🍁🍁🍁🍁 综合实战 🍁🍁🍁🍁🍁🍁🍁🍁, utilsHandler
    Menu, utilsPosition, Add, 滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop, utilsHandler
    

    Menu, utilsObject, Add, cleanProps: 清空值为 undefined 的数据, utilsHandler
    Menu, utilsObject, Add, 双向数据绑定原理：Object.defineProperty, utilsHandler
    Menu, utilsObject, Add, 对象交集 , utilsHandler
    Menu, utilsObject, Add, flattenObject 以键的路径扁平化对象, utilsHandler
    Menu, utilsObject, Add, dataSet, utilsHandler
    

    Menu, utilsObject, Add,, utilsHandler
    Menu, utilsObject, Add,, utilsHandler

    Menu, utilsObject, Add, for#Object.keys, utilsHandler
    Menu, utilsObject, Add, for#o in obj, utilsHandler
    Menu, utilsObject, Add, for#Object.entries(), utilsHandler
    Menu, utilsObject, Add, for#Object.values(), utilsHandler
    Menu, utilsObject, Add, for#Object.keys(), utilsHandler

    Menu, utilsObject, Add,, utilsHandler
    Menu, utilsObject, Add,, utilsHandler

    Menu, utilsObject, Add, (〜￣△￣)〜认知～(￣▽￣～)：({a = 123`, b = 321`, c = 456} = {}) 对象解构 与 参数默认值, utilsHandler
    Menu, utilsObject, Add, delete person.age 删除对象的属性, utilsHandler
    Menu, utilsObject, Add, Object.assign({}`, ), utilsHandler
    Menu, utilsObject, Add, Object.is 比 === 更严格的比较, utilsHandler
    Menu, utilsObject, Add, 'tail' in cat / cat.hasOwnProperty('tail') 判断对象是否包含某属性, utilsHandler
    
    Menu, utilsObject, Add,, utilsHandler
    Menu, utilsObject, Add,, utilsHandler

    Menu, utilsObject, Add, Object.defineProperty 属性的权限设置 writable（可写） / configurable（可配置）/enumerable（可枚举）, utilsHandler
    Menu, utilsObject, Add, Object.defineProperties 属性的批量权限设置, utilsHandler
    Menu, utilsObject, Add, Object.getOwnPropertyDescriptor({a: 123}`, 'a') 获取属性的配置, utilsHandler
    Menu, utilsObject, Add, getter / setter , utilsHandler

    Menu, utilsSolution, Add, setTitle: 解决微信、QQ、闪银等内置浏览器单页应用无法刷新title的问题, utilsHandler
    Menu, utilsSolution, Add, cookie 库, utilsHandler
    Menu, utilsSolution, Add, Model 类, utilsHandler
    Menu, utilsSolution, Add, rem 解决方案 / 淘宝解决方案, utilsHandler

    Menu, utilsSolution, Add
    Menu, utilsSolution, Add

    Menu, utilsSolution, Add, AMD/CommonJS/factory/module, utilsHandler
    Menu, utilsSolution, Add, UMD、AMD, utilsHandler
    Menu, utilsSolution, Add, cache request axios 缓存请求, utilsHandler

    Menu, utilsSolution, Add
    Menu, utilsSolution, Add

    Menu, utilsSolution, Add, $.autoscroll 自动滚动, utilsHandler
    Menu, utilsSolution, Add, $.scrollforevery 无缝滚动, utilsHandler
    Menu, utilsSolution, Add, dragscroll 拖拽滚动, utilsHandler

    Menu, utilsSolution, Add
    Menu, utilsSolution, Add

    Menu, utilsSolution, Add, lazyload 图片懒加载, utilsHandler
    Menu, utilsSolution, Add, preloadimg 图片预加载, utilsHandler

    Menu, utilsSolution, Add
    Menu, utilsSolution, Add

    Menu, utilsSolution, Add, countDown 倒计时, utilsHandler
    Menu, utilsSolution, Add, copyToClipboard 剪切板, utilsHandler
    Menu, utilsSolution, Add, 全屏F11最新解决方案, utilsHandler
    Menu, utilsSolution, Add, 滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop, utilsHandler

    ; @认知 @renzhi

    Menu, utilspractice, Add, obj 也有 get/set 的 API 了, utilsHandler
    Menu, utilspractice, Add, navigator.geolocation获取地理位置信息, utilsHandler
    Menu, utilspractice, Add, 使用 combinate 生成所有可能的组合, utilsHandler
    Menu, utilspractice, Add, isPointInPolygon: 如何验证坐标点是否在多边形内, utilsHandler
    Menu, utilspractice, Add, 数字格式化:.toLocaleString('en-US'), utilsHandler
    Menu, utilspractice, Add, iframe 沙盒化组件：自定义内容, utilsHandler
    Menu, utilspractice, Add, isOverlap： 判断两个矩形 DIV 元素是否交集？, utilsHandler
    Menu, utilspractice, Add, looseEqual： 判断两个对象是否一致, utilsHandler
    Menu, utilspractice, Add, noop 优雅的使用空函数, utilsHandler
    Menu, utilspractice, Add, pipeAsyncFunctions：管道异步处理工具, utilsHandler
    Menu, utilspractice, Add, DeepMapKey：深度遍历所有的key, utilsHandler
    Menu, utilspractice, Add, 三元表达式正确换行套路 —— 问号换行，与冒号齐飞, utilsHandler
    Menu, utilspractice, Add, 最大数:ary.indexOf(0) >>> 0  // => 4294967295, utilsHandler
    Menu, utilspractice, Add, 新的多个变量初始化方式: var [obj`, max`, name] = [{}`, 1`, ''], utilsHandler
    Menu, utilspractice, Add, Array.prototype.maps：优化解决一个数组返回多个对象的, utilsHandler
    Menu, utilspractice, Add, 快速取整的新思路：1553 / 10 | 0, utilsHandler
    Menu, utilspractice, Add, window.onunload 刷新/关闭页面之前发送请求, utilsHandler
    Menu, utilspractice, Add, ...args参数和fn(...args) 入参的技巧和认知, utilsHandler
    Menu, utilspractice, Add, ...args参数和fn.apply(null`, args) 的数组套路, utilsHandler
    Menu, utilspractice, Add, 函数参数对象深度结构与重命名： var a = ({ state: { nums:list`, numGroup`, map } }) => {}, utilsHandler
    Menu, utilspractice, Add, !function(){}()：被遗忘的另一个IIFE, utilsHandler
    
    Menu, utilspractice, Add,
    Menu, utilspractice, Add,
    
    Menu, utilspractice, Add, koajs 核心函数compose的超简单源码实现, utilsHandler
    Menu, utilspractice, Add, 多个异步操作时，请毫不犹豫用Promise.all, utilsHandler
    Menu, utilspractice, Add, Promise.allSettled：Promise.all的升级版，忽视reject报错也执行, utilsHandler
    Menu, utilspractice, Add, Promise.race只返回最快的一个, utilsHandler
    Menu, utilspractice, Add, FormData（multipart/form-data）与URLSearchParams（application/x-www-form-urlencoded）的区别, utilsHandler
    
    Menu, utilspractice, Add,
    Menu, utilspractice, Add,
    
    Menu, utilspractice, Add, promise.catch 全局处理与局部传播：在第一次catch的时候throw错误即可, utilsHandler
    Menu, utilspractice, Add, Promise.prototype.finally已经存在了, utilsHandler
    Menu, utilspractice, Add, async/await与箭头函数：async (to`, from`, next) => {}, utilsHandler
    Menu, utilspractice, Add, async/await与传统函数：async function bootstrap() {}, utilsHandler
    Menu, utilspractice, Add, 对象字面量如何使用async/await标记, utilsHandler
    
    
    Menu, utilspractice, Add,
    Menu, utilspractice, Add,
    
    
    Menu, utilspractice, Add, 对象字面量的变量键：this.setState({ [fuckyou]: 'true' }), utilsHandler
    Menu, utilspractice, Add, 解构与split结合：const [language`, country] = locale.split('-'), utilsHandler
    Menu, utilspractice, Add, 强制转化为Boolean类型：!!(a && b), utilsHandler
    Menu, utilspractice, Add, parseInt/parseFloat可以直接移除字符串：parseFloat(layero.css('left')) // '162px' => 162, utilsHandler
    
    Menu, utilspractice, Add,
    Menu, utilspractice, Add,
    
    
    Menu, utilspractice, Add, 拖拽位置公式, utilsHandler
    Menu, utilspractice, Add, curry2 二元参数的手动柯里化, utilsHandler
    ; renzhi
    
    
    ; @my
    Menu, utilsmy, Add, 12345地图-聚合图解散-打散-散点图-闪开, utilsHandler
    Menu, utilsmy, Add, validateimg: 验证图片可访问性, utilsHandler
    Menu, utilsmy, Add, github 代码块翻译问题处理, utilsHandler
    Menu, utilsmy, Add, copyfn: 函数拷贝方案, utilsHandler

    Menu, utilsmy, Add, matchBy 批量匹配字符串规则, utilsHandler
    Menu, utilsmy, Add, 使用「适配器模式」链式解决多参数配置问题，类似建模, utilsHandler
    Menu, utilsmy, Add, createStore 自动 AUTO_SET 方案, utilsHandler
    Menu, utilsmy, Add, cleanProps: 清空值为 undefined 的数据, utilsHandler
    Menu, utilsmy, Add, toNumber: 转换 + 小数点（很常用）, utilsHandler
    Menu, utilsmy, Add, 自定义事件 on/off 可以实现自由删除事件, utilsHandler
    Menu, utilsmy, Add, lazyExec: 影武者懒执行模式, utilsHandler
    Menu, utilsmy, Add, colorRange: 获取颜色范围，类似 echarts visualMap, utilsHandler
    Menu, utilsmy, Add, killerQueen: 简单的超时关闭函数, utilsHandler
    Menu, utilsmy, Add, 仿 Echarts.visualMap 逻辑分组 + split分组, utilsHandler
    Menu, utilsmy, Add, like 函数多重筛选条件, utilsHandler
    Menu, utilsmy, Add, partial 偏应用（_bind）：自由占位符, utilsHandler
    Menu, utilsmy, Add, 图片转base64:img2base64, utilsHandler
    Menu, utilsmy, Add, 反转函数参数：我的函数我做主, utilsHandler
    Menu, utilsmy, Add, 经典 token 解决方案：cookie-token-http, utilsHandler
    Menu, utilsmy, Add, Promise.allSettled：Promise.all的升级版，忽视reject报错也执行, utilsHandler
    Menu, utilsmy, Add, loadingdec, utilsHandler
    Menu, utilsmy, Add, IntersectionObserver  template 懒注入、懒加载, utilsHandler
    Menu, utilsmy, Add, IntersectionObserver 无限滚动, utilsHandler
    Menu, utilsmy, Add, exclude: 从对象中排除某个属性, utilsHandler
    Menu, utilsmy, Add, deepset：超强！深度set（deepfind的兄弟方法）, utilsHandler
    Menu, utilsmy, Add, 求同存异：金强的对象特殊合并, utilsHandler
        
    
    Menu, utilsmy, Add
    Menu, utilsmy, Add
    
    Menu, utilsmy, Add, wait等待工具，必须配合 async/await使用, utilsHandler
    Menu, utilsmy, Add, delay延迟工具，必须配合 async/await使用, utilsHandler
    Menu, utilsmy, Add, 用 IIFE 解决 setInterval 首次不执行的尴尬, utilsHandler
    Menu, utilsmy, Add, setInterval 强大的解决方案, utilsHandler
    Menu, utilsmy, Add, setInterval Switch超简单开关, utilsHandler
    
    
    Menu, utilsmy, Add
    Menu, utilsmy, Add
    
    Menu, utilsmy, Add, loadExec：又是一个比较骚的工具函数 , utilsHandler
    Menu, utilsmy, Add, 堡垒模式：请求条件不满足则排队处理, utilsHandler
    Menu, utilsmy, Add, 轮询监听URL变化：onUrlChange, utilsHandler
    Menu, utilsmy, Add, 为函数注册全局事件: regEvent, utilsHandler
    Menu, utilsmy, Add, 前端日志上传新姿势 navigator.sendBeacon（信标）, utilsHandler
    Menu, utilsmy, Add, 随机在配色网站上获取颜色, utilsHandler
    Menu, utilsmy, Add, StorageEvent：监听 localStorage 数据变化的解决方案, utilsHandler
    Menu, utilsmy, Add, input动态宽度, utilsHandler
    
    
    Menu, utilsmy, Add
    Menu, utilsmy, Add
    
    Menu, utilsmy, Add, 通过URL判断是否本地开发环境, utilsHandler
    Menu, utilsmy, Add, 微信群组随机取人头, utilsHandler
    Menu, utilsmy, Add, 微信获取头像和人员名册, utilsHandler
    Menu, utilsmy, Add, 钉钉获取组织架构（不成熟）, utilsHandler
    

    Menu, utilsjuran, Add, document.designMode = 'on', utilsHandler
    Menu, utilsjuran, Add, 光标移动到最后，对于div contenteditable 特别有效果, utilsHandler
    Menu, utilsjuran, Add, 社会主义点击事件, utilsHandler
    Menu, utilsjuran, Add, anime.js 点击烟花绽放效果, utilsHandler
    Menu, utilsjuran, Add, holder占位图, utilsHandler
    Menu, utilsjuran, Add, HTML打印出一只怪兽, utilsHandler
    
    Menu, utilsmaybe, Add, 数字格式化函数：numberFormatter(11923.4521`, 2) => 12.02k, utilsHandler
    Menu, utilsmaybe, Add, 处理iOS 微信客户端6.7.4 键盘收起页面未下移bug, utilsHandler
    Menu, utilsmaybe, Add, Android 输入法键盘 和 input 问题:scrollIntoViewIfNeeded, utilsHandler
    Menu, utilsmaybe, Add, 获取手机归属地信息：中国移动/中国联通/中国电信, utilsHandler
    Menu, utilsmaybe, Add, js获取root（window）对象, utilsHandler
    Menu, utilsmaybe, Add, stackoverflow愚人节彩蛋效果, utilsHandler

    Menu, utilsmaybe, Add
    Menu, utilsmaybe, Add

    Menu, utilsmaybe, Add, H5 手机键盘弹出收起的处理, utilsHandler
    ;@maybe
    
    
    
    Menu, utilses5, Add, 类数组还需要 length 属性哦, utilsHandler
    Menu, utilses5, Add, 类数组转化为数组的N种方式, utilsHandler
    Menu, utilses5, Add, 将参数arguments转化为一个数组Array.prototype.slice.call(arguments), utilsHandler
    Menu, utilses5, Add, (...arr)数组解构的前辈：Array.prototype.push.apply(arr`, newArr), utilsHandler
    Menu, utilses5, Add, 函数调用注入args：successFn.apply(this`, arguments), utilsHandler
    Menu, utilses5, Add, 简写Array.prototype.push.apply的方法：[].push.apply, utilsHandler
    Menu, utilses5, Add, Function.prototype.call：除了参数为数组/类数组以外的都应该使用call，如map/reduce/filter（因为他们的参数都是函数）等, utilsHandler

    Menu, utilsJstest, Add, match 捕获匹配, utilsHandler
    Menu, utilsJstest, Add, 认知：用数组来保存const [`, city`, zipCode] = address.match(cityZipCodeRegex) || [];, utilsHandler

    Menu, utilsJstest, Add, 要匹配多个果然还是要用 match, utilsHandler
    Menu, utilsJstest, Add, //g.exec, utilsHandler

    Menu, utilsJstest, Add
    Menu, utilsJstest, Add

    Menu, utilsJstest, Add, replace 与 回调函数, utilsHandler
    
    Menu, utilswebpack, Add, require.context vue, utilsHandler
    Menu, utilswebpack, Add, require.context, utilsHandler
    Menu, utilswebpack, Add, 异步引入：await import(/* webpackChunkName: 'lodash' */ 'lodash'), utilsHandler
    Menu, utilswebpack, Add, vue动态加载组件和资源, utilsHandler
    
    
    Menu, utils2, Add, debug 黑魔法神器, utilsHandler    
    Menu, utils2, Add, pm: 回调地狱转promise解决方案, utilsHandler    
    Menu, utils2, Add, uuid 超简易版, utilsHandler
    Menu, utils2, Add, urlparams 获取路由参数, utilsHandler
    Menu, utils2, Add, device 获取设备信息, utilsHandler
    Menu, utils2, Add, 获取localStorage剩余容量和最大容量, utilsHandler
    Menu, utils2, Add, 获得电脑内存和浏览器使用的存储, utilsHandler

    Menu, utils2, Add, , utilsHandler
    Menu, utils2, Add, , utilsHandler



    Menu, utils2, Add, debounce 函数去抖, utilsHandler
    Menu, utils2, Add, throttle 函数节流, utilsHandler
    Menu, utils2, Add, memoized 函数缓存, utilsHandler
    Menu, utils2, Add, timeChunk 分时分批处理函数 , utilsHandler
    Menu, utils2, Add, compose 函数组合, utilsHandler
    Menu, utils2, Add, memoized：函数缓存器, utilsHandler

    Menu, utils2, Add, , utilsHandler
    Menu, utils2, Add, , utilsHandler

    Menu, utils2, Add, JSON.parse(JSON.stringify(...)) 超简易拷贝, utilsHandler
    Menu, utils2, Add, window.requestAnimFrame, utilsHandler
    Menu, utils2, Add, poll 递归, utilsHandler
    Menu, utils2, Add, pad 自动补全, utilsHandler
    Menu, utils2, Add, 首字母大写 _.charAt(0) 的使用, utilsHandler

    Menu, utils2, Add, , utilsHandler
    Menu, utils2, Add, , utilsHandler

    Menu, utils2, Add, filterhtml: 移除html标签，只提取文本text(), utilsHandler
    Menu, utils2, Add, encodeURI URI过滤, utilsHandler
    Menu, utils2, Add, escapeHTML 防止XSS, utilsHandler

    Menu, utils2, Add, , utilsHandler
    Menu, utils2, Add, , utilsHandler

    Menu, utils2, Add, parsePath: 对象路径解析器, utilsHandler
    Menu, utils2, Add, diff: 对比两个json对象是否一致, utilsHandler
    Menu, utils2, Add, fixPos: 根据父层界限调整宽高和位置, utilsHandler
    Menu, utils2, Add, e.dataset 给元素设置数据, utilsHandler
    Menu, utils2, Add, 颜色逻辑转换：hex2rgba, utilsHandler
    Menu, utils2, Add, 获取一个颜色的反色：#000 = #fff, utilsHandler
    Menu, utils2, Add, 路径获取文件名和后缀, utilsHandler
    Menu, utils2, Add, 前端加解密：btoa 和 atob, utilsHandler
    Menu, utils2, Add, 求两个时间之间的有效日期, utilsHandler
    Menu, utils2, Add, 用 settimeout 模拟 setInterval, utilsHandler
    Menu, utils2, Add, dialog 对话框类，支持拖拽, utilsHandler
    Menu, utils2, Add, 求两个数的最大公约数与比例, utilsHandler
    Menu, utils2, Add, 统计 String 每个单词出现的次数, utilsHandler
    Menu, utils2, Add, allColor：获取页面所有颜色, utilsHandler
    
    Menu, utils2, Add, html 新闻、文本多个换行符\r\n换成一个, utilsHandler


    
    ; @A @main @fuck @util @utils
    Menu, utilsMenu , Add, 第二页, :utils2
    Menu, utilsMenu, Add, (〜￣△￣)〜认知～(￣▽￣～), :utilspractice    
    Menu, utilsMenu, Add, (=・ω・=) 我的 (｀・ω・´), :utilsmy
    Menu, utilsMenu , Add, es5时代的技巧, :utilses5
    Menu, utilsMenu , Add, is 判断, :utilsIs
    Menu, utilsMenu , Add, DOM 操作, :utilsDOM
    Menu, utilsMenu , Add, Position 操作, :utilsPosition
    Menu, utilsMenu , Add, Object 操作, :utilsObject
    Menu, utilsMenu , Add, 正则表达式 与 replace, :utilsJstest
    Menu, utilsMenu , Add, webpack与动态引入, :utilswebpack
    Menu, utilsMenu , Add, 时间相关工具, :utilsTime
    
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    
    Menu, utilssf, Add, 栈（后入先出）: 客栈->酒店->洗盘子->开房->后入->鲜出->压入（push）->弹出（pop）->双p, utilsHandler
    Menu, utilssf, Add, 堆（先入先出）: 一堆人排队->奈何桥早死早投胎->排队, utilsHandler
    
    Menu, utilssf, Add, 
    Menu, utilssf, Add, 
    
    Menu, utilssf, Add, 欧几里得算法（分而治之）：目标使土地分配最大化，不断让宽与高求余，直到整数倍为止, utilsHandler
    
    Menu, utilsMenu , Add, (#-_-)┯━┯  解决方案, :utilsSolution
    Menu, utilsMenu , Add, _(:3」∠)_算法与数据结构, :utilssf

    ; @jiqiao
    Menu, utilsjiqiao, Add, JOJO - 砸瓦鲁多：浏览器暂停术 —— 直接在控制台输入debugger;, utilsHandler
    Menu, utilsjiqiao, Add, console.save 在控制台保存json变量到本地, utilsHandler

    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, !!Σ(゜Д゜) 居然还有这种操作？ Σ(ﾟдﾟ;), :utilsjuran
    Menu, utilsMenu, Add, ╮(￣▽￣)╭ 先收起来再说，没准将来会有用呢？ ╮(￣▽￣)╭, :utilsmaybe
    Menu, utilsMenu, Add, ←_←前端小技巧→_→, :utilsjiqiao
    Menu, utilsMenu, Add, 不要让你的业务代码白费, :utilsworker
    
    Menu, utilsMenu, Show
	Menu, utilsMenu, DeleteAll
    Menu, utils2, DeleteAll
    Menu, utilsIs, DeleteAll
    Menu, utilsDOM, DeleteAll
    Menu, utilsObject, DeleteAll
    Menu, utilssf, DeleteAll
    Menu, utilspractice, DeleteAll
    Menu, utilses5, DeleteAll
    Menu, utilsSolution, DeleteAll
    Menu, utilsmy, DeleteAll
    
return


utilsHandler:
; MsgBox You selected  from the menu .
v := A_ThisMenuItem
Var :=

; @1
if (v == "") {
Var = 
(
)
}

if (v == "12345地图-聚合图解散-打散-散点图-闪开") {
Var =
(
// 缓存函数
var singeFn = function (fn, maxPollTime = 20) {
  // 缓存
  var cache = []
  // 轮询次数
  var pollTime = 0
  // 返回随机数生成器
  return function _() {
    // 获取随机数
    var data = fn.apply(this, arguments)
    // 如果存在则递归
    if (~cache.indexOf(data)) {
      // 递归调用（如果递归次数大于阈值，那么直接返回False）
      return ++pollTime > maxPollTime ? false : _.apply(this, arguments)
    } else {
      // 重置轮询次数
      pollTime = 0
      // 添加缓存并且返回data
      return cache.push(data), data
    }
  }
}

var random = function (min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  return min + Math.floor(Math.random() * (max - min + 1));
}


// 聚合图点击事件
state.streetDot.on("click", e => {
  // 符合 「强制解散聚合图为散点」 的条件
  if (...) {
    // 获取数组长度
    const len = e.markers.length

    // 假如长度为7，那么就是从-7 到 7 的区间取随机数
    const rangeRadom = random.bind(-len, len)

    // 构建一个新的函数：生成不重复的随机数
    var singeRangeRadom = singeFn(rangeRadom)

    // 重新生成散点
    const new_markers = e.markers.map((v, index, array) => {
      // 返回一个新坐标的散点
      return new T.Marker({
        position: new T.LngLat(
          // 除了第一位，在当前点的基础上添加纬度
          e.lnglat.lng + (index === 0 ? 0 : 0.0001 * singeRangeRadom()),
          // 除了第一位，在当前点的基础上添加经度
          e.lnglat.lat + (index === 0 ? 0 : 0.0001 * singeRangeRadom()),
        `),
        icon: startIcon
      }).on('click', e => {
        dispatch('setMsgbox', v.orderId)
      })
    })

    // 删除原本的聚合图
    state.streetDot.removeMarkers(e.markers)

    // 渲染散点图
    state.newClusterer = new T.MarkerClusterer(state.streetmap, { markers: new_markers })
  }
})
)
}

if (v == "toLocaleString：获取中文后缀的时间（1月/一月）") {
Var =
(
const date = new Date(2020, 0, 1);
const short_month = date.toLocaleString('default', { month: 'short' })
const long_month = date.toLocaleString('default', { month: 'long' })

// 20200817100822 "1月" "一月"
console.log(20200817100822, short_month, long_month)
)
}

if (v == "获得电脑内存和浏览器使用的存储") {
Var =
(
function dislayStorageSpace(){
  navigator.storage.estimate().then(function (estimate) {
    console.info("Estimated quota: ", estimate.quota)
    console.info("Estimated usage: ", estimate.usage)
    const percent = (estimate.usage / estimate.quota * 100).toFixed(2)
    console.info("Your currently used storage: ", percent,"`%");
  })
}
)
}

if (v == "obj 也有 get/set 的 API 了") {
Var =
(
const obj = {
  get foo() {
    return this.val
  },

  set bar(value) {
    this.val = value
  }
}

obj.bar = 'hello world'

console.log(obj.foo) // =>hello world
)
}

if (v == "validateimg: 验证图片可访问性") {
_send("validateimg", true, true)
return
}

if (v == "matchBy 批量匹配字符串规则") {
_send("matchBy", true, true)
return
}

if (v == "超灵活的insert：insertAdjacentElement/insertAdjacentHTML") {
Var =
(
/* 
    <!-- beforebegin --> 
    <element> 
        <!-- afterbegin -->
        html content
        <!-- beforeend -->
    </element>
    <!-- afterend -->
 */
el.insertAdjacentElement('beforebegin', el)
el.insertAdjacentHTML('beforebegin', el.outerHTML)
)
code(Var)
}

if (v == "github 代码块翻译问题处理") {
_send("github", true, true)
return
}

if (v == "copyfn: 函数拷贝方案") {
_send("copyfn", true, true)
return
}

if (v == "navigator.geolocation获取地理位置信息") {
_send("geo", true, true)
return
}

if (v == "使用「适配器模式」链式解决多参数配置问题，类似建模") {
Var =
(
class Frog {
  constructor(name, gender, eyes, legs, scent, tongue, heart, weight, height) {
    this.name = name
    this.gender = gender
    this.eyes = eyes
    this.legs = legs
    this.scent = scent
    this.tongue = tongue
    this.heart = heart
    if (weight) {
      this.weight = weight
    }
    if (height) {
      this.height = height
    }
  }
}
---
class FrogBuilder {
  constructor(name, gender) {
    this.name = name
    this.gender = gender
  }
  setEyes(eyes) {
    this.eyes = eyes
    return this
  }
  setLegs(legs) {
    this.legs = legs
    return this
  }
  setScent(scent) {
    this.scent = scent
    return this
  }
  setTongue(tongue) {
    this.tongue = tongue
    return this
  }
  setHeart(heart) {
    this.heart = heart
    return this
  }
  setWeight(weight) {
    this.weight = weight
    return this
  }
  setHeight(height) {
    this.height = height
    return this
  }
  build() {
      return new Frog(
        this.name,
        this.gender,
        this.eyes,
        this.legs,
        this.scent,
        this.tongue,
        this.heart,
        this.weight,
        this.height,
      `)
    }
}

const larry = new FrogBuilder('larry', 'male')
  .setEyes([{ volume: 1.1 }, { volume: 1.12 }])
  .setScent('sweaty socks')
  .setHeart({ rate: 22 })
  .setWeight(6)
  .setHeight(3.5)
  .setLegs([
    { size: 'small' },
    { size: 'small' },
    { size: 'small' },
    { size: 'small' },
  ])
  .setTongue({ tongueWidth: 18, color: 'dark red', type: 'round' })
  .build()
)
txtit(Var)
}

if (v == "createStore 自动 AUTO_SET 方案") {
_send("createStore", true, true)
return
}

if (v == "使用 combinate 生成所有可能的组合") {
_send("combi", true, true)
return
}

if (v == "cleanProps: 清空值为 undefined 的数据") {
_send("cleanProps", true, true)
return
}

if (v == "获取网页被卷去的位置") {
Var =
(
function getScrollXY() {
  return document.body.scrollTop
    ? {
        x: document.body.scrollLeft,
        y: document.body.scrollTop
      }
    : {
        x: document.documentElement.scrollLeft,
        y: document.documentElement.scrollTop
      };
}
)
}

if (v == "isPointInPolygon: 如何验证坐标点是否在多边形内") {
_send("ispip", true, true)
return
}

if (v == "isRegExp 是否为正则表达式") {
Var =
(
// 是否正则表达式
const isRegExp = exp => exp instanceof RegExp
)
}

if (v == "数字格式化:.toLocaleString('en-US')") {
Var =
(
(123456789).toLocaleString('en-US')  // 1,234,567,890
)
}

if (v == "iframe 沙盒化组件：自定义内容") {
_send("iframe", true, true)
return
}

if (v == "isOverlap： 判断两个矩形 DIV 元素是否交集？") {
Var =
(
// isOverlap： 判断两个矩形 DIV 元素是否交集？
// 原理：http://www.geeksforgeeks.org/find-two-rectangles-overlap/
const isOverlap = (rect1, rect2) => {
    const l1 = { x: rect1.x, y: rect1.y }
    const r1 = { x: rect1.x + rect1.width, y: rect1.y + rect1.height }
    const l2 = { x: rect2.x, y: rect2.y }
    const r2 = { x: rect2.x + rect2.width, y: rect2.y + rect2.height }
    if ( l1.x > r2.x || l2.x > r1.x || l1.y > r2.y || l2.y > r1.y ) return false
    return true
}
)
}

if (v == "noop 优雅的使用空函数") {
_send("noop", true, true)
return
}

if (v == "toNumber: 转换 + 小数点（很常用）") {
_send("toNumber", true, true)
return
}

if (v == "looseEqual： 判断两个对象是否一致") {
_send("iseq", true, true)
return
}

if (v == "require.context vue") {
_send("import", true, true)
return
}

if (v == "H5 手机键盘弹出收起的处理") {
Var =
(
// 判断平台
const ua = window.navigator.userAgent.toLocaleLowerCase();
const isIOS = /iphone|ipad|ipod/.test(ua);
const isAndroid = /android/.test(ua);


// IOS 处理
let isReset = true; //是否归位

this.focusinHandler = () => {
  isReset = false; //聚焦时键盘弹出，焦点在输入框之间切换时，会先触发上一个输入框的失焦事件，再触发下一个输入框的聚焦事件
};

this.focusoutHandler = () => {
  isReset = true;
  setTimeout(() => {
    //当焦点在弹出层的输入框之间切换时先不归位
    if (isReset) {
        window.scroll(0, 0); //确定延时后没有聚焦下一元素，是由收起键盘引起的失焦，则强制让页面归位
    }
  }, 30);
};

document.body.addEventListener('focusin', this.focusinHandler);
document.body.addEventListener('focusout', this.focusoutHandler);

// Android 处理
const originHeight = document.documentElement.clientHeight || document.body.clientHeight;

this.resizeHandler = () => {
  const resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;
  const activeElement = document.activeElement;
  if (resizeHeight < originHeight) {
    // 键盘弹起后逻辑
    if (activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA")) {
      setTimeout(()=>{
        activeElement.scrollIntoView({ block: 'center' });//焦点元素滚到可视区域的问题
      },0)
    }
  } else {
    // 键盘收起后逻辑
  }
};

window.addEventListener('resize', this.resizeHandler);
)
}


if (v == "自定义事件 on/off 可以实现自由删除事件") {
Var =
(
/* 自定义事件 on/off 可以实现自由删除事件 */
const on = (target, event, handler, passive = false) => {
    target.addEventListener(event, handler, { capture: false, passive })
    target[`__EVENT_${event.toUpperCase()}__`] = handler
}

const off = (target, event) => {
    const handler = target[`__EVENT_${event.toUpperCase()}__`]

    if (handler) {
        target.removeEventListener(event, handler)
        delete target[`__EVENT_${event.toUpperCase()}__`]
    }
}
)
}

if (v == "pipeAsyncFunctions：管道异步处理工具") {
Var = 
(
const pipeAsyncFunctions = (...fns) => arg => fns.reduce((p, f) => p.then(f), Promise.resolve(arg))

// EXAMPLES
const sum = pipeAsyncFunctions(
  x => x + 1,
  x => new Promise(resolve => setTimeout(() => resolve(x + 2), 1000)),
  x => x + 3,
  async x => (await x) + 4
`);

(async() => {
  console.log(await sum(5)); // 15 (after one second)
})()
)
}

if (v == "DeepMapKey：深度遍历所有的key") {
Var = 
(
const deepMapKeys = (obj, f) =>
  Array.isArray(obj)
    ? obj.map(val => deepMapKeys(val, f))
    : typeof obj === 'object'
      ? Object.keys(obj).reduce((acc, current) => {
        const val = obj[current];
        acc[f(current)] =
          val !== null && typeof val === 'object' ? deepMapKeys(val, f) : (acc[f(current)] = val);
        return acc;
      }, {})
      : obj;
      
// EXAMPLES
const obj = {foo: '1', nested: {child: {withArray: [{grandChild: ['hello'] } ] } } }; 

// { "FOO":"1", "NESTED":{"CHILD":{"WITHARRAY":[{"GRANDCHILD":[ 'hello' ] } ] } } }
const upperKeysObj = deepMapKeys(obj, key => key.toUpperCase());
)
}

if (v == "lazyExec: 影武者懒执行模式") {
_send("lazyExec", true, true)
return
}

if (v == "replace 与 回调函数") {
Var =
(
// 回调函数只有匹配表达式才会触发，所以可以放心使用 args[1]
ext.replace(/<(.+)>/, (...args) => {
    // 获取 <title> 作为标题
    this.levelTitle = args[1]
    // 返回的内容等于替换的内容，我当然是替换为空了
    return ''
})
)
}

if (v == "colorRange: 获取颜色范围，类似 echarts visualMap") {
Var =
(
const colorRange = (colorList, min, max) => {
    // 初始化透明度 rgba
    // 虽然强制将 『透明度的单位』 和 『rgb颜色的255单位』 对齐很离谱
    // 但其实是可以的，因为原理都是通过两个数值『相减』 得出 『距离』，然后再根据距离进行演变。
    colorList = colorList.map(([r, g, b, a = 1]) => [r, g, b, a * 255])

    // 提前准备好还原 Opacity 的工具
    const restoreOpacity = ([r, g, b, a]) => [r, g, b, (a / 255).toFixed(2)]
    
    // 获取距离
    const distance = max - min

    // 获取 『每个颜色之间的距离』
    // 为什么要长度 -1 ？ 想想 『为什么说八岐大蛇是9个头？』 ,因为 『岐』 的意思是头与头之间的 『区间』
    // Orochi，即八岐大蛇（Yamata no Orochi）是日本神话中的著名怪物
    const Orochi = distance / (colorList.length - 1)

    // 初始化所有的 『数值区间』 和 『颜色区间』
    const { vSection, cSection } = colorList.reduce((p, c, i, a, next = a[i + 1]) => {
        // 没有下一个了，说明是最后一个了      
        if (!next) return p

        // 颜色区间
        p.cSection.push([ c, next ])

        // 数值区间
        p.vSection.push([ min + Orochi * i, min + Orochi * (i + 1) ])

        return p
    }, { vSection: [], cSection: [] })


    // 获取颜色的单位距离
    const getUnitColor = ([r1, g1, b1, a1], [r2, g2, b2, a2], distance) => [
        Math.abs(r1 - r2) / distance,
        Math.abs(g1 - g2) / distance,
        Math.abs(b1 - b2) / distance,
        Math.abs(a1 - a2) / distance,
    ]

    return v => {
        // ...
        if (v <= min) return restoreOpacity(colorList[0])

        // ...
        if (v >= max) return restoreOpacity(colorList[colorList.length - 1])

        // 获取 v 命中哪个 『数值区间』
        const index = vSection.findIndex(([a, b]) => (v === a || v === b) || (v > a && v < b))

        // 获取当前数值区间
        const [leftV, rightV] = vSection[index]

        // 获取当前颜色区间
        const [leftC, rightC] = cSection[index]

        // 获取该区间距离
        const _distance = rightV - leftV

        // 返回单位颜色
        const unit_rgba = getUnitColor(leftC, rightC, _distance)

        // 获得当前值与左界的距离（有点 margin/padding 的味道，命名参考 css grid 的 grid-gap）
        const gap = v - leftV

        // 步进的颜色 = 单位颜色 * 左界距离
        const stepColor = unit_rgba.map(c => parseInt(c * gap))

        // 最终颜色 = 左界颜色 + 步进颜色
        const color = leftC.map((c, i) => c + stepColor[i])

        // 还原 Opacity
        return restoreOpacity(color)
    }
}

// 颜色列表
const colorList = [[0, 4, 156, 0.25], [23, 0, 241, 0.3], [0, 90, 255, 0.65], [0, 114, 255, 1]]

// 数据
const data = [{ name:'万江', count: 400 }, { name:'东坑', count: 300 }, { name:'东城', count: 890 }, { name:'中堂', count: 270 }, { name:'企石', count: 170 }, { name:'凤岗', count: 700 }, { name:'南城', count: 650 }, { name:'厚街', count: 950 }, { name:'塘厦', count: 810 }, { name:'大岭山', count: 425 }, { name:'大朗', count: 1200 }, { name:'寮步', count: 560 }, { name:'常平', count: 640 }, { name:'望牛墩', count: 200 }, { name:'松山湖', count: 220 }, { name:'桥头', count: 350 }, { name:'横沥', count: 380 }, { name:'沙田', count: 700 }, { name:'洪梅', count: 70 }, { name:'清溪', count: 450 }, { name:'石排', count: 400 }, { name:'石碣', count: 400 }, { name:'石龙', count: 170 }, { name:'茶山', count: 365 }, { name:'莞城', count: 330 }, { name:'虎门', count: 1300 }, { name:'谢岗', count: 170 }, { name:'道滘', count: 220 }, { name:'长安', count: 1345 }, { name:'高埗', count: 300 }, { name:'麻涌', count: 230 }, { name:'黄江', count: 330 }]

// ...
const _data =  data.map(_ => _.count)

// 最大值 / 最小值
const min = Math.min(..._data), max = Math.max(..._data)

// ...
const make = colorRange(colorList, min, max)

// ...
const finalData = data.map(item => Object.assign({}, item, { color: make(item.count) }))

// ...
console.log(finalData)
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://cdn.staticfile.org/vue/2.6.9/vue.js"></script>
</head>

<body>
    <div id="app">
        <ul><li v-for='(item, index) in colorList' :style='color(item)' :key='index'>{{ item }}</li></ul>
        
        <ul><li v-for='(item, index) in items' :style='color(item.color)' :key='index'>{{ item.color }} - {{ item.name }} - {{ item.count }}</li></ul>
    </div>
</body>

<script src="./colorRange.js"></script>
<script>
var vue = new Vue({
    el: '#app',
    data: {
        colorList: colorList,
        items: finalData.sort((a, b) => +b.count - +a.count),
    },
    methods: {
        color (item) {
            return ``background: rgba(${item.join(',')})``
        }
    },
    beforeMount: function () {

    }
})
</script>
</html>
)
txtit(Var)
return
}

if (v == "获取半小时前") {
Var =
(
// 获取当前和半小时前的数据
const dateHHmmss = () => {
    const date = new Date()
    // 时
    const hours = date.getHours()
    // 分
    const minu = date.getMinutes()
    // 秒
    const second = date.getSeconds()

    // 设置半小时前
    date.setMinutes(date.getMinutes() - 30)

    // 获取半小时前
    const _minu = date.getMinutes()
    
    return [[hours, minu, second].join(':'), [hours, _minu, second].join(':')]
}
)
}

if (v == "killerQueen: 简单的超时关闭函数") {
Var =
(
/**
 * 简单的超时关闭函数 ...
 *
 * @param  {Function} 
 * @param  {Function} 
 * @param  {Number}   
 *
 * const close = killerQueen(
 *   () => console.log('开启打火机'),
 *   () => console.log('熄灭打火机'),
 *   10000,
 * )
 */
const killerQueen = (fn = () => {}, cancel = () => {}, time = 10000) => {
    // 先执行操作
    fn()

    // 定时炸弹
    const timer = setTimeout(() => {
        // 败者食尘！
        cancel()
        // 消除痕迹
        cancel = () => console.warn(`Bite The Dust`)
    }, time)

    return () => {
        // 取消炸弹
        clearTimeout(timer)
        // 正常调用
        cancel()
    }
}
)
}

if (v == "toggleClass") {
Var =
(
const toggleClass = (target, classList, condition) => {
  if (!target || !classList) {
    return
  }
  if (typeof classList === 'string') {
    classList = classList.split(/\s+/).filter(Boolean)
  }
  classList.forEach((className) => {
    if (target.forEach) {
      target.forEach((elem) => {
        condition ? elem.classList.add(className) : elem.classList.remove(className)
      })
    } else {
      condition ? target.classList.add(className) : target.classList.remove(className)
    }
  })
}
)
}

if (v == "debug 黑魔法神器") {
_send("debug", true, true)
return
}

if (v == "vue动态加载组件和资源") {
_send("async.import", true, true)
return
}

if (v == "仿 Echarts.visualMap 逻辑分组 + split分组") {
_send("visualMap", true, true)
return
}

if (v == "like 函数多重筛选条件") {
_send("like", true, true)
return
}

if (v == "html 新闻、文本多个换行符\r\n换成一个") {
Var =
(
content.replace(/(\r\n(\s)*\r\n)+/g, '\r\n\r\n')


记得结合css
.u-pre-line { white-space: pre-line; }
)
}

if (v == "获取指定时间戳") {
Var = 
(
var timestamp = (new Date(" 2019/10/24 08:00:00")).getTime();
)
}

if (v == "格式化当前时间") {
Var = 
(
/***
 *  @return {string} timeText 返回系统时间字符串
 */
function getdataTimeSec() {
    let time = new Date();
    let weekDay;
    let year = time.getFullYear();
    let month = time.getMonth() + 1;
    let day = time.getDate();
    //获取时分秒
    let h = time.getHours();
    let m = time.getMinutes();
    let s = time.getSeconds();
    //检查是否小于10
    h = check(h);
    m = check(m);
    s = check(s);
    let now_day = time.getDay();
    switch (now_day) {
        case 0: {
            weekDay = "星期日"
        }
            break;
        case 1: {
            weekDay = "星期一"
        }
            break;
        case 2: {
            weekDay = "星期二"
        }
            break;
        case 3: {
            weekDay = "星期三"
        }
            break;
        case 4: {
            weekDay = "星期四"
        }
            break;
        case 5: {
            weekDay = "星期五"
        }
            break;
        case 6: {
            weekDay = "星期六"
        }
            break;
        case 7: {
            weekDay = "星期日"
        }
            break;
    }
    let timeText = year + "年" + month + "月" + day + "日  " + " " + weekDay + " " + h + ":" + m +":" + s;

    return timeText
}
)
}

if (v == "返回指定时间戳之间的时间间隔") {
Var = 
(
/**
 *  @param {*} startTime 开始时间的时间戳
 *  @param {*} endTime 结束时间的时间戳
 *  @return {string} str 返回时间字符串
 */
function getTimeInterval(startTime, endTime) {
    let runTime = parseInt((endTime - startTime) / 1000);
    let year = Math.floor(runTime / 86400 / 365);
    runTime = runTime `% (86400 * 365);
    let month = Math.floor(runTime / 86400 / 30);
    runTime = runTime `% (86400 * 30);
    let day = Math.floor(runTime / 86400);
    runTime = runTime `% 86400;
    let hour = Math.floor(runTime / 3600);
    runTime = runTime `% 3600;
    let minute = Math.floor(runTime / 60);
    runTime = runTime `% 60;
    let second = runTime;
    let str = '';
    if (year > 0) {
        str = year + '年';
    }
    if (year <= 0 && month > 0) {
        str = month + '月';
    }
    if (year <= 0 && month <= 0 && day > 0) {
        str = day + '天';
    }
    if (year <= 0 && month <= 0 && day <= 0 && hour > 0) {
        str = hour + '小时';
    }
    if (year <= 0 && month <= 0 && day <= 0 && hour <= 0 && minute > 0) {
        str = minute + '分钟';
    }
    if (year <= 0 && month <= 0 && day <= 0 && hour <= 0 && minute <= 0 && second > 0) {
        str += second + '秒';
    }
    str += '前';
    return str;
}
)
}

if (v == "按类型格式化日期") {
Var = 
(
/**
 * @param {*} date 具体日期变量
 * @param {string} dateType 需要返回类型
 * @return {string} dateText 返回为指定格式的日期字符串
 */
function getFormatDate(date, dateType) {
    let dateObj = new Date(date);
    let month = dateObj.getMonth() + 1;
    let strDate = dateObj.getDate();
    let hours = dateObj.getHours();
    let minutes = dateObj.getMinutes();
    let seconds = dateObj.getSeconds();
    if (month >= 1 && month <= 9) {
        month = "0" + month;
    }
    if (strDate >= 0 && strDate <= 9) {
        strDate = "0" + strDate;

    }
    if (hours >= 0 && hours <= 9) {
        hours = "0" + hours
    }
    if (minutes >= 0 && minutes <= 9) {
        minutes = "0" + minutes
    }
    if (seconds >= 0 && seconds <= 9) {
        seconds = "0" + seconds
    }

    let dateText = dateObj.getFullYear() + '年' + (dateObj.getMonth() + 1) + '月' + dateObj.getDate() + '日';
    if (dateType == "yyyy-mm-dd") {
        dateText = dateObj.getFullYear() + '-' + (dateObj.getMonth() + 1) + '-' + dateObj.getDate();
    }
    if (dateType == "yyyy.mm.dd") {
        dateText = dateObj.getFullYear() + '.' + (dateObj.getMonth() + 1) + '.' + dateObj.getDate();
    }
    if (dateType == "yyyy-mm-dd MM:mm:ss") {
        dateText = dateObj.getFullYear() + '-' + month + '-' + strDate + ' ' + hours + ":" + minutes + ":" + seconds;
    }
    if (dateType == "mm-dd MM:mm:ss") {
        dateText = month + '-' + strDate + ' ' + hours + ":" + minutes + ":" + seconds;
    }
    if (dateType == "yyyy年mm月dd日 MM:mm:ss") {
        dateText = dateObj.getFullYear() + '年' + month + '月' + strDate + '日' + ' ' + hours + ":" + minutes + ":" + seconds;
    }
    return dateText;
 }
)
}

if (v == "验证一个日期是不是今天") {
Var = 
(
/**
* @param  {string} val 需要验证的日期
* @return {boolean} 返回布尔值
*/
function isToday(val){
    return new Date().toLocaleDateString() == new Date(val).toLocaleDateString();
}
)
}

if (v == "本月最后一天") {
Var = 
(
/***
 *  @return {*} MonthLastDay 返回本月最后一天的时间
 */
function showMonthLastDay(){
    let Nowdate=new Date();
    let MonthNextFirstDay=new Date(Nowdate.getFullYear(),Nowdate.getMonth()+1);
    let MonthLastDay=new Date(MonthNextFirstDay-86400000);
    return MonthLastDay;
}
)
}

if (v == "今日最晚时间 23:59:59 的时间戳") {
Var = 
(
let timestamp = new Date(new Date().toLocaleDateString()).getTime()+24*60*60*1000-1;
)
}

if (v == "获取当前时间的前一天/后一天的时间戳") {
Var = 
(
var timestamp = +new Date() - 24*60*60*1000;
var timestamp = +new Date() + 24*60*60*1000;
)
}

if (v == "验证日期大小") {
Var = 
(
/**
* 例："2019-10-24" 和 "2019-10-25"
* @param  {string} d1需要验证的日期1
* @param  {string} d2需要验证的日期2
* @return {boolean} 返回布尔值
*/
function compareDate(d1, d2) {
    return ((new Date(d1.replace(/-/g, "\/"))) < (new Date(d2.replace(/-/g, "\/"))));
}
)
}

if (v == "设置几天后的日期") {
Var = 
(
/**
* @param  {string} date 起始日期
* @param  {number} day 向后的天数
* @return {string} 返回想要得到的日期
*/
function convertDate (date, day) {
    let tempDate = new Date(date);
    tempDate.setDate(tempDate.getDate()+day);
    let Y = tempDate.getFullYear();
    let M = tempDate.getMonth()+1 < 10 ? '0'+(tempDate.getMonth()+1) : tempDate.getMonth()+1;
    let D = tempDate.getDate() < 10 ? '0'+(tempDate.getDate()) : tempDate.getDate();
    let result = Y + "-" + M + "-" + D
    return result;
}
)
}


if (v == "三元表达式正确换行套路 —— 问号换行，与冒号齐飞") {
Var =
(
formatComponentName = vm => {
    var name = vm.isValue ? vm.$options.name : vm.name
    return name
        ? ' (found in component: <)' + hyphente(name) + '>)'
        : ''
}
)
}


if (v == "document.createComment 往DOM插入一个注释") {
_send("dc", true, true)
}

if (v == "虚拟节点 document.createDocumentFragment") {
_send("df", true, true)
}

if (v == "allColor：获取页面所有颜色") {
_send("allcolor", true, true)
return
}

if (v == "类数组还需要 length 属性哦") {
Var =
(
let likeArray = { 1: "foo", 2: "bar" }

// 如果不包含length 属性的话，手动注入
if (!likeArray.hasOwnProperty('length')) {
    // 获取所有的key并且转化为数字类型
    const keys = Object.keys(likeArray).map(_ => +_)
    // 获取最大值作为length + 1
    likeArray.length = Math.max(...keys) + 1
}
)
}

if (v == "类数组转化为数组的N种方式") {
Var =
(
let likeArray = {0: "foo", 1: "bar", length: 2}

// 1
Array.prototype.slice.call(likeArray, 0)

// 2
Array.from(likeArray)
)
}

if (v == "partial 偏应用（_bind）：自由占位符") {
_send("pianyingyong", true, true)
return
}

if (v == "最大数:ary.indexOf(0) >>> 0  // => 4294967295") {
Var =
(
ary.indexOf(0) >>> 0  // => 4294967295
)
}

if (v == "新的多个变量初始化方式: var [obj, max, name] = [{}, 1, '']") {
Var =
(
var [obj, max, name] = [{}, 1, '']
)
}

if (v == "钉钉获取组织架构（不成熟）") {
Var =
(
const preview = async () => {
    // 面包屑导航栏
    const breadcrumb = [...document.querySelectorAll('.breadcrumb')]

    // 找到上一级
    const prevIndex = breadcrumb.findIndex(e => e.querySelector('[ng-if="$last"]')) - 1

    if (prevIndex >= 0) {
        // 返回上一级
        breadcrumb[prevIndex].querySelector('a').click()

        // 延迟 click 这个动作的时间
        await wait(_ => {}, 1000)

        // 等待渲染完成
        await waitWhen(_ => document.querySelectorAll('.info').length)
    }
}

class ChainWork {
    constructor(list = [], work = () => {}, master_next = null) {
        this.list = list
        this.work = work
        this.master_next = master_next
        this.current = 0
    }

    async next(next) {
        this.current = this.current + 1
        // 超出长度了
        if (this.current > this.list.length - 1) {
            await preview()
            // 继续上游分支的任务
            this.master_next && this.master_next()
        } else {
            this.exec()
        }
    }

    exec() {
        const cursor = this.list[this.current]
        this.work(cursor, this.next.bind(this))
    }
}

var hasClass = (el, className) => {
  if (el.classList)
    return el.classList.contains(className);
  else
    return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
}

var wait = async (fn = () => {}, t = 0) => {
    // 计时器（开始）
    const startTime = +new Date
    // 执行并等待该函数
    const result = await fn()
    // 计时器停止
    const endTime = +new Date
    // 获取请求消耗的时间
    const intervalTime = t - (endTime - startTime)
    // 返回
    return new Promise((resolve, reject) => setTimeout(() => resolve(result), intervalTime))
}

/**
 ;(async function(){
    var a = await waitWhen(_ => document.getElementById('1234'))
    console.log(20191212102924, a)
 }())
 */
var waitWhen = (conditionFn = () => false, wait = 4000, interval = 10, startTime = Date.now()) => new Promise((resolve, reject) => {
    (function poll() {
        // 获取回调结果
        var result = conditionFn()

        // 获取是否超时
        var isTimeout = Date.now() - startTime > wait

        // 如果条件成立，那么立刻 resolve
        if (result) return resolve(result)

        // 如果时间超时，立刻 reject
        if (isTimeout) return reject(result)

        // 否则继续轮询
        setTimeout(poll, interval)
    }())
})



var poll = async (target, next) => {
    let { index } = target

    // 点击进入子级
    // fixbug：每次都不一样。
    document.querySelectorAll('.team-item .name')[index].click()

    // 延迟 click 这个动作的时间
    await wait(_ => {}, 1000)

    // 等待渲染完成
    await waitWhen(_ => document.querySelectorAll('.info').length, 60 * 1000)

    // 当前列表
    var cur_list = [...document.querySelectorAll('.member-item')]

    // 遍历第一轮
    target.children = cur_list.map((_el, _index) => Object.assign({}, { 
        // 记录当前的索引
        index: _index,
        // 记录名字（可能是用户名或者部门名）
        name: _el.querySelector('.info').innerText.trim(), 
        // 是否具备 children 
        children:  hasClass(_el, 'team-item') ? [] : null,
    }))

    // 找到所有具备子列表的元素
    const childrenList = target.children.filter(_ => _.children)

    // 如果存在则继续深入
    if (childrenList.length) {
        // 开启子分支
        const chain = new ChainWork(childrenList, poll, next)

        // 子分支开始执行
        chain.exec()
    
    // 否则，回到首页
    } else {
        // 返回上一页
        await preview()

        // 开始下一波
        next()
    }
}


var list = [...document.querySelectorAll('.team-item .name')].map((el, index) => ({ index, name: el.innerText,  children: [] }))
const chain = new ChainWork(list, poll)
chain.exec()
)
}

if (v == "图片转base64:img2base64") {
_send("img2base64", true, true)
return
}

if (v == "反转函数参数：我的函数我做主") {
_send("fanzhuan", true, true)
return
}

if (v == "Array.prototype.maps：优化解决一个数组返回多个对象的") {
Var =
(
// 判断是否为函数
const isFunction = v => Object.prototype.toString.call(v) === '[object Function]'

// map 方法只能返回一个参数，这个方法是用来返回多个的。
Array.prototype.maps = function(...args) {
    // 初始化空数组，这是一个二维数组，长度与参数一致
    let ary = args.map(_ => [])

    // 开始遍历自身
    this.forEach((val, index, array) => {
        // 依次执行 fn
        for (let i = 0, len = args.length; i < len; i++) {
            // 获取当前函数
            const fn = args[i]
            // 调用函数，如果不是函数的话，就直接返回本身
            const result = isFunction(fn) ? fn(val, index, array) : fn
            // 插入第n个里边
            ary[i].push(result)
        }
    })

    // 返回最终结果
    return ary
}

const list = [{ a: 'a1', b: 'b1' }, { a: 'a2', b: 'b2' }, ]
const [a, b] = list.maps(_ => _.a, _ => _.b)
console.log(a, b)

// 也可以使用 this
// [this.a, this.b] = list.maps(_ => [_.a, _.b])
)
}

if (v == "新的数组工具：maps") {
_send("maps", true, true)
return
}

if (v == "Promise.allSettled：Promise.all的升级版，忽视reject报错也执行") {
_send("Promise.all2", true, true)
return
}

if (v == "经典 token 解决方案：cookie-token-http") {
Var =
(
/**
 请求的时候：

 1、 要获取 refreshToken ，并且判断是否超时？

 2、 如果没有超时，重置过期时间（25分钟）, 如果已经超时，那么跳转到登陆页面重新登陆

 3、 获取 token 如果超时了，那么重新获取。

 5、 如果没有超时，继续请求。加入该 token

 6、 如果后端返回 token失效，则跳转登陆
 */

import axios from 'axios'
import VueCookies from 'vue-cookies'

const warn = msg => {
    // 提示错误
    Message.error(msg)

    // 取消请求
    throw new Error(msg)
}


const kill = msg => {
    // 清空cookie
    clearToken()

    // 跳转到登录页
    router.push('/login')

    // 提示错误
    Message.error(msg)

    // 取消请求
    throw new Error(msg)
}

/**
 * 清空 cookie
 */
const clearToken = () => {
    VueCookies.remove('HTCMP_token')
    VueCookies.remove('HTCMP_refreshToken')
}


/**
 * axios 全局配置
 */
const http = axios.create({
    baseURL: Constant.BASEURL,
    headers: { 'app': 'HTCMP', 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/json; charset=utf-8' },
    timeout: 1000 * 10,
})

/**
 * 请求拦截
 */
http.interceptors.request.use(async request => {
    // ✖️ 如果是登录是不需要 『Authorization』 或者 『token』 的
    if ('/uaa/auth/login' === request.url) {
        return request

    // 📝 如果是 『重新获取token』，则 『Authorization』 需要设置为 『refreshToken』
    } else if ('/uaa/auth/token' === request.url) {
        const refreshToken = getRefreshToken()
        request.headers['Authorization'] = 'Bearer ' + refreshToken
        return request

    // 🚀 其余 API 的 Authorization 全部都必须用 token
    } else {
        const refreshToken = getRefreshToken()
        const token = await getToken()
        request.headers['Authorization'] = 'Bearer ' + token
        return request
    }
})

/**
 * 响应拦截
 */
http.interceptors.response.use(response => {
    // 获取后端的状态码和数据
    const { code, data } = response

    // 根据后端约定，如果状态码 code 为 9926 的话，就是登陆 token 失效
    if (code === '9926') {
        return kill('登录过期，请重新登录！')
    }

    // 正常返回数据
    return data
})


/**
 * 获取 refreshToken
 */
const getRefreshToken = () => {
    // 从 cookie 中获取 refreshToken
    const refreshToken = VueCookies.get('HTCMP_refreshToken')    

    // 如果 refreshToken 正常则重置一下过期时间
    if (refreshToken) {
        // 重置为120分钟
        VueCookies.set('HTCMP_refreshToken', refreshToken, { expires: '120m' })

        // 返回 refreshToken
        return refreshToken

    // 否则跳转登录
    } else {
        kill('登录超时，请重新登录。')
    }
}


/**
 * 获取 token
 */
const getToken = () => {
    // 从cookie中获取token
    const __TOKEN__ = VueCookies.get('HTCMP_token')

    // 如果 token 失效，则重新获取
    if (!__TOKEN__) {
        // 请求最新的 token
        return http.get('/uaa/auth/token').then(data => {
            // 获取新token
            const token = data.token

            // 重置 token
            VueCookies.set('HTCMP_token', token, { expires: '118m' })

            // 返回token
            return token

        }).catch(err => {
            kill('重新获取 token 失败，请重新登录！')
        })
    }

    // 一切正常，返回 token
    return __TOKEN__
}
)
}

if (v == "认知：用数组来保存const [, city, zipCode] = address.match(cityZipCodeRegex) || [];") {
Var =
(
const address = "One Infinite Loop, Cupertino 95014";
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
const [, city, zipCode] = address.match(cityZipCodeRegex) || [];
saveCityZipCode(city, zipCode);
)
}

if (v == "isVisualRange：是否处于可视视图中") {
_send("isVR", true, true)
return
}

if (v == "document.designMode = 'on'") {
Var =
(
document.designMode = 'on'
)
}

if (v == "IntersectionObserver 无限滚动") {
Var =
(
<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <!-- mockjs -->
    <script src="https://cdn.staticfile.org/Mock.js/1.0.0/mock-min.js"></script>
    <!-- axios -->
    <script src="https://cdn.staticfile.org/axios/0.19.0/axios.min.js"></script>

    <style>
        li { display: block; height: 100px; }
        footer { height: 100px; background-color: #000; }
    </style>
</head>

<body>
    <ul id='app'>
        <li>英国发生捅人事件新</li>
        <li>周琦首次回应指责新</li>
        <li>北京地铁临时封闭</li>
        <li>高晓松闹笑话</li>
        <li>郑州彩虹桥拆除新</li>
        <li>复盘最强医保谈判</li>
        <li>北京初雪</li>
        <li>网曝张亮假离婚</li>
        <li>滴滴美团严重失信</li>
        <li>网易又一员工被逼</li>
        <li>呼伦贝尔五彩光柱</li>
        <li>悍匪冯学华判死刑</li>
        <li>曹阳退役</li>
        <li>网银回应罚2943万</li>
        <li>苹果设计师离职</li>
    </ul>
    <footer></footer>
</body>

<script>
Mock.mock("/news/list", "get", {
    "newslist|10": [
        { "news_id|+1": 101, "news_name": "@ctitle", "news_price|50-100.1-2": 0, "news_time": "@date('yyyy-mm-dd')" }
    ]
}).setup({
    timeout: '1000-3000'
})

// loading 装饰器
var loadingDec = (fn, loading = false) => [_ => loading, async (...args) => {
    // 开启Loading
    loading = true
    // 等待函数执行结果
    const result = await fn(...args)
    // 关闭loading
    loading = false
    // 返回结果
    return result
}]

// 模拟请求后端
const loadData = () => axios.get("/news/list")

// 装饰函数
const [isLoading, _loadData] = loadingDec(loadData)

// 渲染列表
const render = items => items.forEach(item => {
    let node = document.createElement('li')
    node.innerText = item.news_name
    document.getElementById('app').appendChild(node)
})

const io = new IntersectionObserver(async elements => {
    // 当前演示只有一个监听对象 footer
    const footer = elements[0]

    // 如果可见，就插入新的内容
    if (footer.isIntersecting && !isLoading()) {
        // 加载十条数据
        const { data } = await _loadData(10)
        // 渲染
        render(data.newslist)
    }
}, {
    /* opts */
})

// 只监听 footer 是否显示即可
io.observe(document.querySelector('footer'))
</script>
</html>
)
}

if (v == "IntersectionObserver  template 懒注入、懒加载") {
Var =
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <style>

    img {
        width: 100`%;
        height: 100`%;
    }

    p {
        height: 500px;
    }
    </style>
</head>

<body>
    <div id="app">
        <p class='lazy-load'><template><img src="https://iph.href.lu/400x400" alt="..." /></template></p>
        <p class='lazy-load'><template><img src="https://iph.href.lu/400x400" alt="..." /></template></p>
        <p class='lazy-load'><template><img src="https://iph.href.lu/400x400" alt="..." /></template></p>
        <p class='lazy-load'><template><img src="https://iph.href.lu/400x400" alt="..." /></template></p>
        <p class='lazy-load'><template><img src="https://iph.href.lu/400x400" alt="..." /></template></p>
        <p class='lazy-load'><template><img src="https://iph.href.lu/400x400" alt="..." /></template></p>
        <p class='lazy-load'><template><img src="https://iph.href.lu/400x400" alt="..." /></template></p>
        <p class='lazy-load'><template><img src="https://iph.href.lu/400x400" alt="..." /></template></p>
    </div>
</body>

<script>
const io = new IntersectionObserver(elements => {
    // 所有的监听对象
    console.log(elements)

    // 打印对象的所处情况
    elements.forEach(e => {
        // 如果显示了
        if (e.isIntersecting) {
            // 获取显示的dom
            const target = e.target;
            // 获取 dom 下面 <template> 的内容
            const content = target.querySelector('template').content;
            // 插入到真实内容
            target.appendChild(content);
            // 取消监听
            io.unobserve(target)
        }
    })
}, {
    // 属性决定了什么时候触发回调函数
    threshold: [0, 0.25, 0.5, 0.75, 1],
})

document.querySelectorAll('.lazy-load').forEach((el, key) => {
    io.observe(el)
})

</script>
</html>
)
}



if (v == "loadingdec") {
_send("loadingdec", true, true)
return
}

if (v == "dataSet") {
_send("dataSet", true, true)
return
}

if (v == "pm: 回调地狱转promise解决方案") {
_send("pm", true, true)
return
}

if (v == "统计 String 每个单词出现的次数") {
Var =
(
const map = {}
const str = 'hello world'

str.split('').forEach(key => {
  map[key] = -~map[key]
})

console.log(map)
)
}

if (v == "要匹配多个果然还是要用 match") {
Var =
(
var str = "linear-gradient(to bottom left, cyan 50`%, palegoldenrod 50`%)"
var str2 = "linear-gradient(to bottom,rgba(228, 24, 24, 1), rgba(72, 213, 12, 1))"

var getColor = str => {
	var test_index = /\((.+?),/g

	// 执行结果
	var result = test_index.exec(str)

	// 匹配角度
	var angle = result[1].split(' ').slice(1)

	// 获取颜色字符串
	var color_str = str.substring(result.index + result[0].length, str.length - 1).trim()

	var colors = []

	// 如果出现百分号，说明是类型1
	if (color_str.includes('`%')) {
		// 匹配 `% 百分号
		colors = color_str.match(/(\w+.+?)`%/g)
	// 如果没有，则假设是 rgba/rgb 的情况
	} else if (color_str.includes('rgb')) {
		// 直接按照 rgb/rgba来匹配即可。
		colors = color_str.match(/rgb(a)?\((.+?)\)/g)
	}

	return { angle, colors }
}

console.log(20191118171701, getColor(str))
console.log(20191118171701, getColor(str2))
)
return
}

if (v == "//g.exec") {
Var =
(
// 是否具备规则？ fuckyou-${abc}
const rule = /\$\{(.+?)\}/g.exec(tag)

// 确实有自定义规则：
if (rule) {
  // 获取匹配的 key
  const key = rule[1]

  // 从插槽的实例中获取值
  const data = this.$parent[key]

  // 替换内容
  tag = tag.replace(rule[0], data)
}
)
return
}


if (v == "...args参数和fn.apply(null, args) 的数组套路") {
Var =
(
const arrayPrototype = Array.prototype

// 使用的其实是这个数组原型
export const arrayMethods = Object.create(arrayPrototype)

['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(method => {
    // 保存原始方法
    const originalMethod = arrayPrototype[method]

    // 监听数组方法
    Object.defineProperty(arrayMethods, method, {
        enumerable: true,
        writable: true,
        configurable: true,
        value: function (...args) {
            return originalMethod.apply(this, args)
        }
    })
})
)
}

if (v == "flattenObject 以键的路径扁平化对象") {
_send("flatobj", true, true)
return
}

if (v == "collapse折叠面板") {
_send("zhedie", true, true)
return
}

if (v == "求两个数的最大公约数与比例") {
Var = 
(
// 求最大公约数
const greatestCommonDivisor = function(m, n) {
	var u = +m,
	    v = +n,
	    t = v;

	while (v != 0) {
	    t = u `% v;
	    u = v;
	    v = t;
	}

	return u
}

const proportion = function (m, n) {
	const v = greatestCommonDivisor(m, n)
	return ``${m/v}:${n/v}``
}

/*
proportion(1920, 1080)
"16:9"

proportion(17280, 4320)
"4:1" 

proportion(12288, 3456)
"32:9"
*/
)
}


if (v == "document.activeElement.blur()") {
_send("da", true, true)
return
}

if (v == "获取当前时间的秒数") {
Var = 
(
// 每一秒等于行走这样的百分比
const unit = 100 / 24 / 60 / 60

// 获取当前时间的秒数
const getDistance = (t = new Date) => t.getHours() * 60 * 60 + t.getMinutes() * 60 + t.getSeconds()

// 单位距离（初始化）
unit * getDistance()
)
}

if (v == "获取12345的时间选择器") {
Var = 
(
export const shortcuts = (function(){
    let ary = [{
        text: '第一季度',
        onClick(picker) {
            const year = moment(picker.date).year()
            const start = new Date(`${year}/01/01`);
            const end = new Date(`${year}/03/31`);
            picker.$emit('pick', [start, end]);
        }
    }, {
        text: '第二季度',
        onClick(picker) {
            const year = moment(picker.date).year()
            const quarter = moment(`${year}0401`).format()
            const now = moment().format()
            if (now > quarter) {
                const start = new Date(`${year}/04/01`);
                const end = new Date(`${year}/06/30`);
                picker.$emit('pick', [start, end]);
            } else {
                return Message(`未找到 ${year}年第2季度的数据`)
            }
        }
    }, {
        text: '第三季度',
        onClick(picker) {
            const year = moment(picker.date).year()
            const quarter = moment(`${year}0701`).format()
            const now = moment().format()
            if (now > quarter) {
                const start = new Date(`${year}/07/01`);
                const end = new Date(`${year}/09/30`);
                picker.$emit('pick', [start, end]);
            } else {
                return Message(`未找到 ${year}年第3季度的数据`)
            }
        }
    }, {
        text: '第四季度',
        onClick(picker) {
            const year = moment(picker.date).year()
            const quarter = moment(`${year}1001`).format()
            const now = moment().format()
            if (now > quarter) {
                const start = new Date(`${year}/10/01`);
                const end = new Date(`${year}/12/31`);
                picker.$emit('pick', [start, end]);
            } else {
                return Message(`未找到 ${year}年第4季度的数据`)
            }
        }
    }, {
        text: '近三个月',
        onClick(picker) {
            // 三个月前的月初
            const threeMonthsAgo = moment().subtract(2, 'month').format('YYYY/MM/01')
            // 转换为date类型
            const start = new Date(threeMonthsAgo)
            // 当天
            const end = moment()._d
            picker.$emit('pick', [start, end])
        }
    },{
        text: '上半年',
        onClick(picker) {
            const year = moment(picker.date).year()
            const start = new Date(`${year}/01/01`);
            const end = new Date(`${year}/06/30`);
            picker.$emit('pick', [start, end]);
        }
    }, {
        text: '下半年',
        onClick(picker) {
            const year = moment(picker.date).year()
            const secondHalf = moment(`${secondHalf}0615`).format()
            const now = moment().format()
            if (now < secondHalf) {
                const start = new Date(`${year}/7/1`);
                const end = new Date(`${year}/12/31`);
                picker.$emit('pick', [start, end]);
            } else {
                return Message(`未找到 ${year}下半年的数据`)
            }
        }
    }, {
        text: '一年',
        onClick(picker) {
            const year = moment(picker.date).year()
            const month = moment().month() + 1
            const day = moment().endOf('month').format('DD')
            const start = new Date(`${year}/01/01`)
            // 如果选择的年小于当前年，那么就是全年，否则就是直到这个月
            const end = year < moment().year() ? new Date(`${year}/12/31`) : new Date(`${year}/${month}/${day}`);
            picker.$emit('pick', [start, end]);
        }
    }]

    return ary
}());

)
}

if (v == "findSameByProperty：对比两个数组找出相同特征的成员") {
Var = 
(
var ary1 = [{qid: 1, serviceitem: 1, bb: []}, {qid: 2, serviceitem: 2, bb: []}, {qid: 3, serviceitem: 3, bb: []},]
var ary2 = [{qid: 2, serviceitem: 2}, {qid: 3, serviceitem: 3},]

var findSameByProperty = (master, slave, property) => {
    // 获取特征
    var propertys = master.map(_ => _[property])
    // 只保留满足特征的元素
    return slave.filter(_ => propertys.includes(_[property]))
}

// 对号入座，小蝌蚪找妈妈的环节
findSameByProperty(ary1, ary2, 'qid').forEach((val, key) => {
    // 找到匹配项目
    var target = ary1.find(_ => _.qid === val.qid)
    // 新组合
    const v = { value: val.qid, label: val.serviceitem }
    // 设置属性
    target['bb'] = Array.isArray(target['bb']) ? [...target['bb'], v] : [v]
})

console.log(ary1)
)
}

if (v == "dialog 对话框类，支持拖拽") {
_send("dialog", true, true)
return
}

if (v == "用 settimeout 模拟 setInterval") {
Var = 
(
const _setInterval = (fn, interval) => {
	_setInterval.timer = setTimeout(() => {
		fn()
		_setInterval(fn, interval)
	}, interval)
}

_setInterval.clear = () => clearTimeout(_setInterval.timer)

// demo 
_setInterval(() => console.log(1), 1000)

// 5秒后清除
setTimeout(() => _setInterval.clear(), 5000);
)
}

if (v == "求两个时间之间的有效日期") {
_send("rangeDate", true, true)
return
}



if (v == "is-mobile:判断是否为移动端") {
_send("is-mobile", true, true)
return
}


if (v == "parents") {
_send("parents", true, true)
}

if (v == "HTML打印出一只怪兽") {
Var = 
(
<!---

                                            ████████
                                            ████████
                                        ████████
                                        ████████
            ████████████    ████    ████████
            ████████████    ████    ████████
        ████████████████████████████████
        ████████████████████████████████
    ████████████████████████████████████
    ████████████████████████████████████
████████████████████████░░░░░░░░████████████
████████████████████████░░░░░░░░████████████
████████████████████████░░░░░░░░████████
████████████████████████░░░░░░░░████████
████████████████████████████████████████
████████████████████████████████████████
████████████████████████████████████████████
████████████████████████████████████████████
████████████████████████████████████████████
████████████████████████████████████████████
████████████████████████████████████████████
████████████████████████████    ████████████
████████████████████████████    ████████████
████████████████████████████████
████████████████████████████████
████████████████████████████████████
████████████████████████████████████

   – @lzh
   – 928532756@qq.com

        very semver 2.0.606-->
)
}

if (v == "loadExec：又是一个比较骚的工具函数") {
_send("loadexec", true, true)
return
}


if (v == "求同存异：金强的对象特殊合并") {
Var = 
(
var a = {a: 1, b: 2}
var b = {a: 3, c: 5}

// 是否是一个对象？
const isObject = input => input != null && Object.prototype.toString.call(input) === '[object Object]'

// 判断两个对象的属性是否重合？
const isKeysRepeat = (a, b) => Object.keys(a).filter(_ => Object.keys(b).includes(_)).length

/**
 * 求同存异 ...
 */
const f = (...args) => args.reduce((prev, curr) => {
    // 如果不是对象，直接返回进入下一次
    if (!isObject(curr)) {
        return prev
    }

    // 判断属性是否重复，如果不重复的话，直接合并即可。
    if (!isKeysRepeat(prev, curr)) {
        return Object.assign({}, prev, curr)
    }

    // 对象遍历，如果是相同的属性，则相加（前提是需要是Number类型），但这里就不判断了。
    for (let [key, val] of Object.entries(curr)) {
        // 如果包含key，那么这两个属性相加
        if (key in prev) {
            // ⚠️ 相加. 这里没有判断是否为Number类型
            prev[key] += val
        // 否则直接迭代
        } else {
            prev[key] = val
        }
    }

    // 返回修改后的 prev
    return prev
}, {})

f(a, b) // => {a: 4, b: 2, c: 5}
)
}

if (v == "判断两个数组是否互相包含") {
_send("arrbaohan", true, true)
return
}

if (v == "为函数注册全局事件: regEvent") {
_send("regEvent", true, true)
return
}


if (v == "前端日志上传新姿势 navigator.sendBeacon（信标）") {
_send("xinbiao", true, true)
return
}


if (v == "前端加解密：btoa 和 atob") {
_send("atob", true, true)
return
}


if (v == "ObjectSearch:深度搜索对象/数组") {
Var = 
(
// 是否为对象
const isObject = input => input != null && Object.prototype.toString.call(input) === '[object Object]'

// 是否为数组
const isArray = input => input instanceof Array || Object.prototype.toString.call(input) === '[object Array]'

/**
 * 深度搜索对象/数组的key ...
 * @target           {Object}   要搜索的对象/数组
 * @searchExpression {Function} 搜索表达式
 * @targetHande      {Function} 命中后的回调函数
 * @maxDeep          {Number}   深入的层级
 *
 */
const ObjectSearch = (target, searchExpression, targetHande, maxDeep = 10) => {
    // 是否为一个对象或者数组
    if (isObject(target) || isArray(target)) {
        // 目标是否满足表达式，如果满足直接操作
        searchExpression(target) && targetHande(target)
        // 遍历
        for (let k in target) {
            // 递归
            ObjectSearch(target[k], searchExpression, targetHande, maxDeep)
        }
    }
}

const demo1 = { a: {b: {c: {fuckyou: 'demo1'}}} }
const demo2 = [ { a: {b: {c: {fuckyou: 'demo2'}}} } ]
const demo3 = { a: { b: { c: [ { a: {b: {c: {fuckyou: 'demo3'}}} } ] } } }

ObjectSearch(demo1, target => 'fuckyou' in target, v => { console.log(20190716140318, v) })
ObjectSearch(demo2, target => 'fuckyou' in target, v => { console.log(20190716140319, v) })
ObjectSearch(demo3, target => 'fuckyou' in target, v => { console.log(20190716140319, v) })

// update demo
ObjectSearch(demo1, target => 'fuckyou' in target, v => { 
    v.fuckyou = 'thinkyou'
    console.log(20190716140939, JSON.stringify(demo1))
})
)
}

if (v == "随机在配色网站上获取颜色") {
Var = 
(
// 从数组中随机获取指定数量的成员
var getRandomArrayElements = (arr, count) => {
    var shuffled = arr.slice(0), i = arr.length, min = i - count, temp, index;
    while (i-- > min) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}

// 反色
var colorReverse = oldColor => {
    var oldColor = '0x' + oldColor.replace(/#/g, '');
    var str = '000000' + (0xFFFFFF - oldColor).toString(16);
   return str.substring(str.length - 6, str.length);
}

// 随机在 https://colorhunt.co/palettes/random 中获取
var randColorHunt = num => getRandomArrayElements([...document.querySelectorAll('span[onclick]')].map(_ => _.innerText), num)

// 获取10个
var randColors = randColorHunt(10)

// 打印出颜色的结果
randColors.forEach((val, key) => console.log('`%c' + val, ``background: ${val}; color: #${colorReverse(val.substr(1))}; font-size: 20px``))

// 打印出所有颜色
console.log(randColors)
)
}


if (v == "获取一个颜色的反色：#000 = #fff") {
Var = 
(
function colorReverse(oldColor){
    var oldColor = '0x' + oldColor.replace(/#/g, '');
    var str = '000000' + (0xFFFFFF - oldColor).toString(16);
   return str.substring(str.length - 6, str.length);
}
)
}


if (v == "!function(){}()：被遗忘的另一个IIFE") {
_send("iife", true, true)
return
}


if (v == "光标移动到最后，对于div contenteditable 特别有效果") {
Var = 
(
// https://blog.csdn.net/arthurwanggang/article/details/62416283
// https://segmentfault.com/a/1190000005869372
setTimeout(() => {
	// 先聚焦
    e.target.focus()
	// 获取当前的光标
    var range = window.getSelection()
	// 获取所有内容
    range.selectAllChildren(e.target)
	// 跳转到最后光标
    range.collapseToEnd()
}, 10)
)
}


if (v == "异步引入：await import(/* webpackChunkName: 'lodash' */ 'lodash')") {
Var =
(
const _ = await import(/* webpackChunkName: "lodash" */ 'lodash')
---
button.onclick = e => import(/* webpackChunkName: "print" */ './print').then(module => {
  var print = module.default
  print()
})
)
txtit(Var)
return
}


if (v == "require.context") {
Var = 
(
/**
 * 1. directory {String} -读取文件的路径 
 * 2. useSubdirectories {Boolean} -是否遍历文件的子目录
 * 3. regExp {RegExp} -匹配文件的正则  
 */
const charts = require.context('.', true, /\.js$/)

// 准备导出的模块
let __CHARTS__ = {}

// 1. 必须使用 key() 获取所有路径
// 2. 我获取了除了 ./Chart.js 和 ./index.js 以外所有模块js内容
// 3. 使用 charts(path).default 获取真实模块内容
charts.keys().filter(path => path.lastIndexOf('/') != 1).forEach(path => {
	// 获取 『文件名』 和 『后缀名』
	const [name, ext] = path.substring(path.lastIndexOf('/') + 1).split('.')
	// 以 『文件名』 为 key，模块内容为 value
	__CHARTS__[name] = charts(path).default
})

export default __CHARTS__
)
}

if (v == "路径获取文件名和后缀") {
Var = 
(
const path = './BarChart/HorizontalBarChart.js'
const [name, ext] = path.substring(path.lastIndexOf('/') + 1).split('.')
console.log(20190711100013, name)
)
}

if (v == "match 捕获匹配") {
Var = 
(
match (value) {
    const type = Object.prototype.toString.call(value)
    return type.match(/\[object (.+?)\]/)[1]
},
)
}

if (v == "hex2rgba") {
_send("color2Rgb", true, true)
return
}

if (v == "双向数据绑定原理：Object.defineProperty") {
_send("odf", true, true)
return
}

if (v == "对象交集") {
_send("objectjiaoji", true, true)
return
}

if (v == "setTitle: 解决微信、QQ、闪银等内置浏览器单页应用无法刷新title的问题") {
_send("setTitle", true, true)
return
}





if (v == "wait等待工具，必须配合 async/await使用") {
_send("wait", true, true)
return
}

if (v == "delay延迟工具，必须配合 async/await使用") {
_send("delay", true, true)
return
}


if (v == "console.save 在控制台保存json变量到本地") {
_send("console.save", true, true)
return
}


if (v == "微信获取头像和人员名册") {
Var = 
(
// data:image/png;base64,
const getBase64Image = img => {
    const { width, height } = img
    const canvas = document.createElement('canvas')
    canvas.width = width
    canvas.height = height
    const ctx = canvas.getContext('2d')
    ctx.drawImage(img, 0, 0, width, height)
    const ext = img.src.substring(img.src.lastIndexOf('.') + 1).toLowerCase()
    const dataURL = canvas.toDataURL('image/' + ext)
    return dataURL
}

const img2Base64 = url => new Promise((resolve, reject) => {
   const img = new Image()
   img.setAttribute('crossOrigin', 'anonymous')
   img.src = url
   img.onload = () => resolve(getBase64Image(img))
   img.onerror = () => reject('err')
})

;(async function(){
    const users = [...document.querySelectorAll('.member.ng-scope')]
    const info = users.map(_ => {
        const name = _.querySelector('.nickname').innerText
        const icon = _.querySelector('.avatar').getAttribute('src')
        return { name, icon: ``https://wx.qq.com${icon}``}
    })

    var promise_data = info.map(async (_, index) => {
        var avatar = await img2Base64(_.icon)
        console.log(``已收录${_.name}的头像：${index}``)
        return Object.assign({}, _, { avatar })
    })

    var _data = await Promise.all(promise_data)

    // cosole.save
    console.log('所有数据', _data)
}())

//////////////////////////////////////////////
// 将 base64 转换为头像
//////////////////////////////////////////////
const fs = require('fs').promises
const json = require('./wx.js')

json.forEach(val => {
    const { name, avatar } = val
    const base64Data = avatar.replace(/^data:image\/\w+;base64,/, '')
    const dataBuffer = new Buffer.alloc(base64Data.length, base64Data, 'base64')
    fs.writeFile(``${name}.jpg``, dataBuffer) 
})
)
}


if (v == "FormData（multipart/form-data）与URLSearchParams（application/x-www-form-urlencoded）的区别") {
Var = 
(
import ky from 'ky';
(async () => {
	// multipart/form-data
	const formData = new FormData();
	formData.append('food', 'fries');
	formData.append('drink', 'icetea');

	await ky.post(url, {
		body: formData
	});
})();


import ky from 'ky';
(async () => {
	// application/x-www-form-urlencoded
	const searchParams = new URLSearchParams();
	searchParams.set('food', 'fries');
	searchParams.set('drink', 'icetea');

	await ky.post(url, {
		body: searchParams
	});
})();
)
}

if (v == "数组成员排列：以大带小 drive") {
Var = 
(
/**
 * 以大带小
 *
 *  const data = drive(newV.data, (a, b) => +a.amount - +b.amount)
 *  this.render(data)
 */
var drive = (ary, fn) => {
    // 数组长度
    const len = ary.length
    // 偶数长度
    const isEven = len `% 2 === 0
    // 从大到小排序
    const _ary = ary.sort(fn)
    // 循环的次数
    const time = isEven ? len / 2 : Math.floor(len / 2) + 1
    // 返回新的数组
    return [...Array(time)].reduce((previousValue, currentValue, index) => {
        // 是否循环的最后一次
        const isLastTime = index === time - 1
        // 如果是奇数的，且最后一次的情况下
        if (!isEven && isLastTime) {
            // 没人可带，带我自己就够了
            return [...previousValue, _ary[index]]
        // 默认都带一个小弟
        } else {
            // 带上小弟
            return [...previousValue, _ary[index], _ary[len - 1 - index]]
        }
    }, [])
}
)
}

if (v == "StorageEvent：监听 localStorage 数据变化的解决方案") {
Var = 
(
// Storage 类
var Storage = {
    setItem(key, newVal) {
        // 获取旧值
        const oldVal = this.getItem(key)
        // 设置新值
        localStorage.setItem(key, newVal)
        // 推送
        this.fire(key, newVal, oldVal)
    },
    removeItem(key) {
        // 获取旧值
        const oldVal = this.getItem(key)
        // 删除
        localStorage.removeItem(key)
        // 推送
        this.fire(key, null, oldVal)
    },
    getItem(k) {
      return localStorage.getItem(k)
    },
    fire(...args) {
        var se = document.createEvent('StorageEvent')
        se.initStorageEvent('storage', false, false, ...args)
        window.dispatchEvent(se)
    }
}

// 监听 storage 事件
window.addEventListener('storage', ({ key, newValue, oldValue } = {}) => {
     console.log(key, newValue, oldValue)
}, false)

// 触发条件
Storage.setItem('a', 123)
)
}

if (v == "克隆dom的认知：深浅克隆 document.querySelector('.layer').cloneNode(true)") {
Var = 
(
document.querySelector('.layer').cloneNode(true)
)
}

if (v == "mvDOM：移动dom元素到指定目标位置") {
_send("mvDOM", true, true)
return
}


if (v == "拖拽位置公式") {
Var = 
(
https://github.com/vuegg/vuegg/blob/master/client/src/components/editor/main/Stage.vue#L123

拖拽位置公式 = pageY  - <容器到顶部的距离> + 容器scrollTop - 元素高度/2

容器到顶部的距离 = 容器offsetTop + 其他障碍高度
)
}

if (v == "堡垒模式：请求条件不满足则排队处理") {
_send("baoleimodel", true, true)
return
}

if (v == "滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop") {
Var = 
(
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    .box {
        height: 500px;
        overflow-y: scroll;
    }
    </style>
</head>

<body>
    <div id="app">
        
        <div class="box">
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
        </div>
        
        <button onclick='cf()'>test</button>
    </div>
</body>
<script>

const el = document.querySelector('.box')

el.addEventListener('scroll', (event) => {
   if (el.scrollHeight - el.clientHeight === el.scrollTop) {
    console.log(20190517110428, 123)
   }
})

function cf() {
    console.log(20190517105848, el.scrollHeight)
    console.log(20190517105848, el.clientHeight)
    console.log(20190517105848, el.scrollTop)
}

</script>
</html>
)
}

if (v == "把数组像分页一样分割为N段") {
_send("fenye", true, true)
return
}

if (v == "once函数装饰器") {
_send("once", true, true)
return
}

if (v == "获取当前所在的<iframe>：window.frameElement") {
Var = 
(
console.log(window.frameElement);
)
}


if (v == "e.dataset 给元素设置数据") {
Var = 
(
// 方法一：通过js设置（设置完之后，html会出现data-fuck-you="true"的字样。）
$0.dataset['fuckYou'] = 'true'

// 方法二：通过HTML属性设置：
data-fuck-you="true"

// 注意点：
// 1、可以设置多个Dataset
// 2、js设置值必须是驼峰，但HTML设置必须是小写和-相连

// 获取值：
$0.dataset.fuckYou
)
}

if (v == "获取当前所在的<script>：document.currentScript") {
Var = 
(
https://github.com/lukeed/dimport/blob/master/src/module.js#L70
document.currentScript
)
}

if (v == "const { log， warn， info， error， assert  } = console") {
_send("log", true, true)
return
}

if (v == "HTML缓存数据：e.dataset 与 data-fuck-you") {
Var = 
(
<div id="app" data-fuck-you="true"></div>
document.getElementById('app').dataset.fuckYou    
)
}

if (v == "fixPos: 根据父层界限调整宽高和位置") {
_send("fixpos", true, true)
return
}


if (v == "- el.scrollHeight：真实高度（含滚动条）") {
Var = 
(
el.scrollHeight
)
}


if (v == "- el.scrollTop: 视口可见的顶部，到绝对顶部的距离") {
Var = 
(
/**
 * scrollTop 新认知：https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop
 *
 * 1、他不是固定不变的，这个数据是根据滚动条的位置而定的（float）。
 * 2、如果没有滚动条，那么值为0.
 * 3、scrollTop 值是视口可见的顶部，到绝对顶部的距离。
 * 4、但当我们向上滚的时候，实质是视口向上相对平移运动，由于该运动导致与容器顶部的距离拉近了。所以说：视口越接近顶部，数值越小（趋于0）。
 */
el.scrollTop
)
}

if (v == "getComputedStyle(el)['height']") {
Var = 
(
getComputedStyle(el)['height']
)
}

if (v == "将 if/else 转化为三元表达式示例") {
Var = 
(
return (
  (!parent)
    ? parseInt(window.getComputedStyle(document.getElementById(element.id))[prop])
    : (typeof element[prop] !== 'string')
      ? element[prop]
      : (typeof parent[prop] !== 'string')
        ? parent[prop] * parseInt(element[prop]) / 100
        : parseInt(window.getComputedStyle(document.getElementById(parent.id))[prop]) * parseInt(element[prop]) / 100
`)
)
}

if (v == "- el.clientHeight：可视高度") {
Var = 
(
el.clientHeight
)
}

if (v == "- el.getBoundingClientRect().top：相对窗口的距离") {
Var = 
(
el.getBoundingClientRect().top
)
}
if (v == "- e.clientY：客户端浏览器视口所在的位置") {
Var = 
(
e.clientY
)
}
if (v == "- e.pageY：页面所在的位置") {
Var = 
(
e.pageY
)
}
if (v == "- e.screenY：屏幕所在的位置") {
Var = 
(
e.screenY
)
}
if (v == "- offsetWidth：getComputedStyle(el).width 返回的可能是百分比，offsetWidth总是返回数值") {
Var = 
(
offsetWidth
)
}
if (v == "- offsetTop：元素相对于定位元素（position默认是body）的偏移量（含scroll）") {
Var = 
(
offsetTop
)
}

if (v == "任意值的__proto__拦截器：数组为例") {
Var = 
(
const arrayProto = Array.prototype

// export 
const arrayMethods = Object.create(arrayProto)

;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach((key) => {
	// raw
	const original = arrayProto[key]
	Object.defineProperty(arrayMethods, key, {
		// 不可枚举
	    enumerable: false,
	    configurable: true,
	    writable: true,
	    value: function mutator (...args) {
	    	console.log('mutator')
	    	return original.apply(this, args)
	    }
	})
})

var a = []
a.__proto__ = arrayMethods
a.push(1) // mutator
)
}


if (v == "diff: 对比两个json对象是否一致") {
_send("diff", true, true)
}

if (v == "parsePath: 对象路径解析器") {
Var = 
(
function parsePath(obj, path) {
    const segments = path.split('.')
    for (let i = 0, len = segments.length; i < len; i++) {
        obj = obj[segments[i]]
    }
    return obj
}

var obj = {
    "a": {
        "b": {
            "c": {
                "d": 123
            }
        }
    }
}
parsePath(obj, 'a.b.c.d') // 123
)
}
if (v == "全屏F11最新解决方案") {
_send("fullpage", true, true)
return
}

if (v == "async/await与传统函数：async function bootstrap() {}") {
Var = 
(
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
)
}


if (v == "promise.catch 全局处理与局部传播：在第一次catch的时候throw错误即可") {
Var = 
(
new Promise((resolve, reject) => {
   setTimeout(function () {
        reject('fail')
   }, 1000);
}).catch(err => {
    alert("全局错误处理");
    // 继续传播错误，让下一个catch可以捕获
    throw new Error(err)
}).catch(err => {
    alert("局部处误处理");
})
)
}


if (v == "JOJO - 砸瓦鲁多：浏览器暂停术 —— 直接在控制台输入debugger;") {
Var = 
(
debugger;
)
}

if (v == "Promise.prototype.before") {
Var = 
(
Promise.prototype.before = function (fn) {
	(fn instanceof Function || Object.prototype.toString.call(fn) === '[object Function]') && fn()
	return this
}

// 注意，你必须resolve或reject才可以执行.then()
new Promise((resolve, reject) => {
   setTimeout(function () {
        reject('fail')
   }, 1000);
}).before(() => {
	console.log(20190422151455, 'before?')
}).finally(() => {
	console.log(20190422145923, 123)
})
)
}


if (v == "Promise.prototype.finally已经存在了") {
Var = 
(
new Promise((resolve, reject) => {
   setTimeout(function () {
        reject('fail')
   }, 1000);
}).finally(() => {
	console.log(20190422145923, 123)
})
)
}

if (v == "memoized：函数缓存器") {
_send("fncache", true, true)
return
}

if (v == "input动态宽度") {
Var = 
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    #test {
        min-width: 160px;
    }
    </style>
</head>

<body>
    <input type="text" id='test'>
    <div id='test2'></div>
</body>
<script>

const autoWidth = input => {
    // valiteda the input type
    if (input instanceof HTMLInputElement === false) 
        // target must be a input element
        return console.warn('target must be a input element')

    // function
    const setWidth = e => {
        // self or target
        const { style, value } = e.target || e
        // set the width style
        style.width = value.length + 'em'
    }

    // init
    setWidth(input)

    // event
    input.addEventListener('input', setWidth)
}

// 获取input
const target = document.querySelector('#test')

// 设置自动根据文本提高宽度
autoWidth(target)

</script>

</html>
)
}

if (v == "isdom：div instanceof HTMLElement") {
Var = 
(
return div instanceof HTMLElement
)
}


if (v == "数字格式化函数：numberFormatter(11923.4521, 2) => 12.02k") {
Var = 
(
/* 数字 格式化*/
export function numberFormatter(num, digits) {
  const si = [
    { value: 1E18, symbol: 'E' },
    { value: 1E15, symbol: 'P' },
    { value: 1E12, symbol: 'T' },
    { value: 1E9, symbol: 'G' },
    { value: 1E6, symbol: 'M' },
    { value: 1E3, symbol: 'k' }
  ]
  for (let i = 0; i < si.length; i++) {
    if (num >= si[i].value) {
      return (num / si[i].value + 0.1).toFixed(digits).replace(/\.0+$|(\.[0-9]*[1-9])0+$/, '$1') + si[i].symbol
    }
  }
  return num.toString()
}
)
}

if (v == "exclude: 从对象中排除某个属性") {
Var = 
(
export const exclude = (obj, ...attribute) =>  {
  // copy
  let _ = JSON.parse(JSON.stringify(obj))
    // 删除属性
  for (let i = 0, len = attribute.length; i < len; i++) {
    const attr = attribute[i]
      delete _[attr]
  }
  // pure obj
  return _
}
)
}

if (v == "快速取整的新思路：1553 / 10 | 0") {
Var = 
(
1553 / 10 | 0
)
}


if (v == "deepset：超强！深度set（deepfind的兄弟方法）") {
_send("deepset", true, true)
return
}

if (v == "async/await与箭头函数：async (to, from, next) => {}") {
Var = 
(
router.beforeEach(async (to, from, next) => {
  // 这里获取 permissionList
  await store.dispatch('getPermissionList')
})
)
}

if (v == "dom.js") {
_send("dom.js", true, true)
return
}

if (v == "scrollIntoView 滚动到元素可视区域（代码实现）") {
_send("scrollIntoView", true, true)
return
}


if (v == "判断是否为数字：!isNaN(+params.id)") {
Var = 
(
// 如果不是数字的话，那么清空
if (!isNaN(+v) === false) {
  e.target.value = ''
  return
}
)
}

if (v == "stackoverflow愚人节彩蛋效果") {
Var = 
(
	/*!
 * Fairy Dust Cursor.js
 * - 90's cursors collection
 * -- https://github.com/tholman/90s-cursor-effects
 * -- https://codepen.io/tholman/full/jWmZxZ/
 */

(function fairyDustCursor() {
  
  var possibleColors = ["#D61C59", "#E7D84B", "#1B8798"]
  var width = window.innerWidth;
  var height = window.innerHeight;
  var cursor = {x: width/2, y: width/2};
  var particles = [];
  
  function init() {
    bindEvents();
    loop();
  }
  
  // Bind events that are needed
  function bindEvents() {
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('touchmove', onTouchMove);
    document.addEventListener('touchstart', onTouchMove);
    
    window.addEventListener('resize', onWindowResize);
  }
  
  function onWindowResize(e) {
    width = window.innerWidth;
    height = window.innerHeight;
  }
  
  function onTouchMove(e) {
    if( e.touches.length > 0 ) {
      for( var i = 0; i < e.touches.length; i++ ) {
        addParticle( e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random()*possibleColors.length)]);
      }
    }
  }
  
  function onMouseMove(e) {    
    cursor.x = e.clientX;
    cursor.y = e.clientY;
    
    addParticle( cursor.x, cursor.y, possibleColors[Math.floor(Math.random()*possibleColors.length)]);
  }
  
  function addParticle(x, y, color) {
    var particle = new Particle();
    particle.init(x, y, color);
    particles.push(particle);
  }
  
  function updateParticles() {
    
    // Updated
    for( var i = 0; i < particles.length; i++ ) {
      particles[i].update();
    }
    
    // Remove dead particles
    for( var i = particles.length -1; i >= 0; i-- ) {
      if( particles[i].lifeSpan < 0 ) {
        particles[i].die();
        particles.splice(i, 1);
      }
    }
    
  }
  
  function loop() {
    requestAnimationFrame(loop);
    updateParticles();
  }
  
  /**
   * Particles
   */
  
  function Particle() {

    this.character = "*";
    this.lifeSpan = 120; //ms
    this.initialStyles ={
      "position": "absolute",
      "display": "block",
      "pointerEvents": "none",
      "z-index": "10000000",
      "fontSize": "16px",
      "will-change": "transform"
    };

    // Init, and set properties
    this.init = function(x, y, color) {

      this.velocity = {
        x:  (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2),
        y: 1
      };
      
      this.position = {x: x - 10, y: y - 20};
      this.initialStyles.color = color;

      this.element = document.createElement('span');
      this.element.innerHTML = this.character;
      applyProperties(this.element, this.initialStyles);
      this.update();
      
      document.querySelector('body').appendChild(this.element);
    };
    
    this.update = function() {
      this.position.x += this.velocity.x;
      this.position.y += this.velocity.y;
      this.lifeSpan--;
      
      this.element.style.transform = "translate3d(" + this.position.x + "px," + this.position.y + "px, 0) scale(" + (this.lifeSpan / 120) + ")";
    }
    
    this.die = function() {
      this.element.parentNode.removeChild(this.element);
    }
    
  }
  
  /**
   * Utils
   */
  
  // Applies css `properties` to an element.
  function applyProperties( target, properties ) {
    for( var key in properties ) {
      target.style[ key ] = properties[ key ];
    }
  }
  
  init();
})();
)
}

if (v == "utils.js") {
_send("utils.js", true, true)
return
}

if (v == "UMD、AMD") {
_send("UMD", true, true)
return
}

if (v == "对象字面量的变量键：this.setState({ [fuckyou]: 'true' })") {
Var = 
(
var visible = 'fuckyou'
console.log({[visible]: 'true'}) // { fuckyou: 'true' }
)
}

if (v == "微信群组随机取人头") {
Var = 
(
/**
 * 1、打开微信网页版
 * 2、打开一个群，点击下拉菜单。
 * 3、打开控制台输入该脚本：[...document.querySelectorAll('.members .nickname')].map(_ => _.innerText)
 * 
 */
// 费雪耶兹（Fisher–Yates） 也被称作高纳德（ Knuth）随机置乱算法
function shuffle(target) {
    var j, x, i = target.length;
    for (; i > 0; j = parseInt(Math.random() * i), x = target[--i], target[i] = target[j], target[j] = x) {}
    return target
}
var peoples = shuffle([...document.querySelectorAll('.members .nickname')].map(_ => _.innerText))
peoples.slice(0, 6)

//////////////////////////////////////////////
// 或者用这种更快一点
//////////////////////////////////////////////
// 目标人数
const target = 10
// 组所有成员
const people = [...document.querySelectorAll('.members .nickname')].map(_ => _.innerText)
// 组成员人数
const len = people.length
// 被选中的孩子们
let beSelectPeoples = new Set()
// 直到满足目标人数
while(beSelectPeoples.size != target) {
  // 随机数
  const rand = ~~(0 + Math.random() * (len + 1))
  // 被选中的孩子
  const beSelectPeople = people[rand]
  // 加入队列
  beSelectPeoples.add(beSelectPeople)
}
)
}

if (v == "setInterval Switch超简单开关") {
Var = 
(
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ECharts</title>
    <script src="https://lib.baomitu.com/echarts/4.1.0/echarts.min.js"></script>
</head>
<body>
    <div id="app" style="width: 600px; height:400px;"></div>
</body>

<script>
// 基于准备好的dom，初始化echarts实例
var myChart = echarts.init(document.getElementById('app'))

// mock data
var data = [
    { value: 10, name: '就业保障类' },
    { value: 15, name: '城市建设类' },
    { value: 25, name: '民政救济类' },
    { value: 20, name: '市场监管类' },
    { value: 35, name: '市容城管类' },
    { value: 30, name: '公共安全类' },
    { value: 40, name: '公安消防类' },
]

// 核心配置
var option = {
    legend: {
        x: 'center',
        y: 'bottom',
        data: data.map(_ => _.name)
    },
    series: [{
        type: 'pie',
        radius: [25, 95],
        center: ['50`%', 140],
        roseType: 'area',
        clockWise: false,
        itemStyle: {
            normal: {
                label: {
                    formatter: ['{b}', '占比{d}`%'].join('\n'),
                    textStyle: { color: '#000', fontSize: 12 }
                },
            },
            emphasis: {
                label: {
                    textStyle: { color: '#000', fontSize: 24 }
                }
            }
        },
        data: data
    }]
}

myChart.setOption(option)

function Switch () {
    // 当前索引
    let current = 0;
    // 节点数量
    let len = myChart.getOption().series[0].data.length
    // 开始轮播
    let timer = null

    // 返回一个开始按钮
    const start = function () {
        // 如果已经存在，则不重复执行
        if (timer)
            return timer

        return timer = setInterval(() => {
               // 先取消上一次高亮
               myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: current `% len })
               // 高亮当前节点
               myChart.dispatchAction({ type: 'highlight', seriesIndex: 0, dataIndex: ++current `% len })
        }, 1500)
    }

    // 返回一个关闭按钮
    const stop = function () {
        // 消除定时器
        timer = clearInterval(timer)
        // 关闭高亮
        myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: current `% len })
    }

    return { start, stop }
}

// 获取开关
let _switch = Switch()

// 开启
_switch.start()

/**
 * 虽然 Echarts 有提供 mycharts.on('mouseover') 和 mycharts.on('mouseout')。
 * 但建议还是直接用 DOM 来主导 mouseover/mouseout，否则有一些麻烦的问题。
 * 请自行斟酌选择使用。
 */

// 移动过去就暂停
document.getElementById('app').addEventListener('mouseover', () => {
    _switch.stop()
})

// 移动过去就开启
document.getElementById('app').addEventListener('mouseout', () => {
    _switch.start()
})
</script>
</html>
)
}

if (v == "setInterval 强大的解决方案") {
Var = 
(
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ECharts</title>
    <script src="https://lib.baomitu.com/echarts/4.1.0/echarts.min.js"></script>
</head>
<body>
    <div id="app" style="width: 600px; height:400px;"></div>
</body>

<script>
// 基于准备好的dom，初始化echarts实例
var myChart = echarts.init(document.getElementById('app'))

// mock data
var data = [
    { value: 10, name: '就业保障类' },
    { value: 15, name: '城市建设类' },
    { value: 25, name: '民政救济类' },
    { value: 20, name: '市场监管类' },
    { value: 35, name: '市容城管类' },
    { value: 30, name: '公共安全类' },
    { value: 40, name: '公安消防类' },
]

// 核心配置
var option = {
    legend: {
        x: 'center',
        y: 'bottom',
        data: data.map(_ => _.name)
    },
    series: [{
        type: 'pie',
        radius: [25, 95],
        center: ['50`%', 140],
        roseType: 'area',
        clockWise: false,
        itemStyle: {
            normal: {
                label: {
                    formatter: ['{b}', '占比{d}`%'].join('\n'),
                    textStyle: { color: '#000', fontSize: 12 }
                },
            },
            emphasis: {
                label: {
                    textStyle: { color: '#000', fontSize: 24 }
                }
            }
        },
        data: data
    }]
}

myChart.setOption(option)

/**
 * MerryGoRound
 *
 * @param  {Function} 需要轮询的函数
 * @param  {Number}   轮询间隔
 * @param  {Number}   索引开始位置
 */
function MerryGoRound (fn, interval = 1500, current = 0) {
    // 时间器
    let timer = null

    // 开始
    const start = function (reset = false, IIFE = false) {
        // 是否重置？
        if (reset) {
            timer = null
            current = 0
        }

        // 如果旋转木马已经启动，那么不重复开启
        if (timer) {
            return timer
        }

        // 如果不是函数那么返回错误
        if (fn instanceof Function === false) {
            return console.warn('First arguments must be a function.')
        }

        // 是否使用 IIFE 解决 setInterval 首次不执行的尴尬
        IIFE && fn(current++)

        // 设置计时器timer
        timer = setInterval(() => fn(current++), interval)

        // 还是要返回timer好一点
        return timer
    }

    // 停止
    const stop = function (reset = false, stopfn) {
        // 停止回调函数
        stopfn && stopfn(current)

        // 是否重置索引为0
        if (reset) {
            current = 0
        }

        // 清空轮播器
        timer = clearInterval(timer)
    }

    // 返回开关
    return { start, stop }
}

// 我的echarts的轮播器核心函数
var wheelPlanting = (len, current) => {
    // 先取消上一次高亮
    myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: current `% len })
    // 高亮当前节点
    myChart.dispatchAction({ type: 'highlight', seriesIndex: 0, dataIndex: ++current `% len })
}

// 获取节点的数量
const len = myChart.getOption().series[0].data.length

// 预设值（参考【偏应用】和【科里化】的简易做法）
var _wheelPlanting = wheelPlanting.bind(null, len)

// 返回一个开关
var _switch = new MerryGoRound(_wheelPlanting)

// 按下 “开”
_switch.start()

/**
 * 虽然 Echarts 有提供 mycharts.on('mouseover') 和 mycharts.on('mouseout')。
 * 但建议还是直接用 DOM 来主导 mouseover/mouseout，否则有一些麻烦的问题。
 * 请自行斟酌选择使用。
 */

// 移动过去就暂停
document.getElementById('app').addEventListener('mouseover', () => {
    // 停止，实际上这个stopfn回调，最好也是用一下预设值，但为了简单还是直接使用了位于全局的len。特殊情况再特殊处理吧。
    _switch.stop(false, current => {
        // 先取消上一次高亮
        myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: current `% len })
    })
})

// 移动过去就开启
document.getElementById('app').addEventListener('mouseout', () => {
    _switch.start()
})
</script>
</html>
)
}


if (v == "参数缓存器") {
_send("paramscache", true, true)
return
}


if (v == "用 IIFE 解决 setInterval 首次不执行的尴尬") {
Var = 
(
(function(fn, t) {
    // 立即执行一次，这也是这个IIFE的目的：为了解决 setInterval 首次不执行的尴尬
    fn && fn()
    // 返回计时器timer
    return setInterval(fn, t)
})(() => {
    // your logic...

}, 5 * 1000)
)
}

if (v == "通过URL判断是否本地开发环境") {
Var = 
(
const baseUrl = (function(){
	if (window.location.origin === 'file://' || ~window.location.host.indexOf("localhost") || ~window.location.host.indexOf("192.168")) {
		return 'http://12345v1.dgdatav.com:6080'
	} else {
		return '/api'
	}
}());
)
}

if (v == "将参数arguments转化为一个数组Array.prototype.slice.call(arguments)") {
Var = 
(
Array.prototype.slice.call(arguments)
)
}

if (v == "首字母大写 _.charAt(0) 的使用") {
Var = 
(
['lee', 'mp'].map(_ => _.charAt(0).toUpperCase() + _.substr(1)) //  ["Lee", "Mp"]
)
}


if (v == "欧几里得算法（分而治之）：目标使土地分配最大化，不断让宽与高求余，直到整数倍为止") {
_send("oujilide", true, true)
return
}

if (v == "timeChunk 分时分批处理函数") {
Var = 
(
var timeChunk = function ( ary, fn, count, wait) {
	var start = function () {
		// 每次循环count次数，如果长度不够count时，就取剩余长度。这是个不错的判断思维。用Main.min
		for (var i = 0; i < Math.min( count || 1, ary.length ); i++) {
			// 不断从数组取出内容进行操作
			var obj = ary.shift()
			fn(obj)
		}
	}

	return function () {
		var timer = setInterval(function () {
			if (ary.length === 0) {
				return clearInterval(timer);
			}
			start()
		}, wait || 200);
	}
}

var ary = [...Array(1000)].map((v, index, array) => index)

var render = timeChunk( ary, function ( n ) {
	var div = document.createElement('div')
	div.innerHTML = n;
	document.body.appendChild( div );
}, 8)

render();
)
}

if (v == "超简单的currying与理财花销实例") {
Var = 
(
var currying = function (fn) {
	var args = [];
	return function () {
		// 新设计：如果不传参数则立刻返回当前计算结果
		if ( arguments.length === 0 ) {
			// 返回执行结果
			return fn.apply(this, args);
		} else {
			// 将参数加入缓存
			Array.prototype.push.apply( args, arguments );
			// 返回本函数
			return arguments.callee;
		}
	}
}

// 测试：理财函数
var cost = function(){
	return Array.prototype.reduce.call(arguments, function (previousValue, currentValue, index, array) {
		return previousValue + currentValue
	}, 0)
};

// cost(100, 200, 300, 400)

var curring_cost = currying(cost)

curring_cost( 1000 )
curring_cost( 1000 )
curring_cost( 1000 )
curring_cost( 1000 )

curring_cost(  )
)
}

if (v == "Function.prototype.call：除了参数为数组/类数组以外的都应该使用call，如map/reduce/filter（因为他们的参数都是函数）等") {
Var = 
(
var cost = (function(){
	var money = 0;
	return function () {
		return Array.prototype.reduce.call(arguments, function (previousValue, currentValue, index, array) {
		    return previousValue + currentValue
		}, 0)
	}
}());

cost(100, 200, 300, 400)
)
}

if (v == "简写Array.prototype.push.apply的方法：[].push.apply") {
Var = 
(
[].push.apply
)
}

if (v == "(...arr)数组解构的前辈：Array.prototype.push.apply(arr, newArr)") {
Var = 
(
Array.prototype.push.apply(arr, newArr)
)
}


if (v == "函数调用注入args：successFn.apply(this, arguments)") {
Var = 
(
successFn.apply(this, arguments)
)
}


if (v == "去重复版本的axios") {
_send(singaxios, true, true)
return
}

if (v == "(=・ω・=)我的单例版ajax") {
_send(singeajax, true, true)
return
}
if (v == "强制转化为Boolean类型：!!(a && b)") {
Var = 
(
var a = 1, b = 0
console.log(!!(a && b))
)
}

if (v == "img判断加载完成") {
_send(imgonload, true, true)
return
}


if (v == "create 创建img") {
_send(createimg, true, true)
return
}


if (v == "mask蒙版") {
_send(mask, true, true)
return
}

if (v == "create 创建元素") {
Var = 
(
var div = document.createElement('div')
div.style = 'position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 199307100337; background-color: rgba(0,0,0,.3);'
document.body.append(div)
// document.body.insertBefore(div, document.body.firstChild)
)
}

if (v == "插入body前面") {
Var = 
(
var div = document.createElement('div')
div.style = 'position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 199307100337; background-color: rgba(0,0,0,.3);'
div.innerHTML = '123'
// document.body.append(div)
document.body.insertBefore(div, document.body.firstChild)
)
}

if (v == "插入body后面") {
Var = 
(
var div = document.createElement('div')
div.style = 'position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 199307100337; background-color: rgba(0,0,0,.3);'
div.innerHTML = '123'
document.body.append(div)
// document.body.insertBefore(div, document.body.firstChild)
)
}


if (v == "函数参数对象深度结构与重命名： var a = ({ state: { nums:list, numGroup, map } }) => {}") {
Var = 
(
var a = ({ state: { nums: list, numGroup, map } }) => {
	console.log('num重命名为list了', list, numGroup, map)
}

a({state: {nums: 1, numGroup: 2, map: 3 } })
)
}

if (v == "模拟真实点击click，专门对付clickoutside") {
_send("mockclick", true, true)
return
}

if (v == "koajs 核心函数compose的超简单源码实现") {
_send("compose", true, true)
return
}


if (v == "Promise.race只返回最快的一个") {
Var = 
(
const getName = new Promise((resolve, reject) => {
   setTimeout(function () {
        resolve('success') // reject('fail')
   }, 50);
})

const getNumber = Promise.resolve(1)

Promise.race([getName, getNumber])
	.then(console.log) // 输出 1 只输出最快返回的一个
	.catch(console.log)
)
}

if (v == "anime.js 点击烟花绽放效果") {
Var = 
(
<script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<canvas class="fireworks" style="position: fixed; left: 0px; top: 0px; z-index: 1; pointer-events: none;" width="2880" height="832"></canvas>

// fireworks.js

"use strict";
function updateCoords(e) {
    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left,
    pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top
}
function setParticuleDirection(e) {
    var t = anime.random(0, 360) * Math.PI / 180
      , a = anime.random(50, 180)
      , n = [-1, 1][anime.random(0, 1)] * a;
    return {
        x: e.x + n * Math.cos(t),
        y: e.y + n * Math.sin(t)
    }
}
function createParticule(e, t) {
    var a = {};
    return a.x = e,
    a.y = t,
    a.color = colors[anime.random(0, colors.length - 1)],
    a.radius = anime.random(16, 32),
    a.endPos = setParticuleDirection(a),
    a.draw = function() {
        ctx.beginPath(),
        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),
        ctx.fillStyle = a.color,
        ctx.fill()
    }
    ,
    a
}
function createCircle(e, t) {
    var a = {};
    return a.x = e,
    a.y = t,
    a.color = "#F00",
    a.radius = .1,
    a.alpha = .5,
    a.lineWidth = 6,
    a.draw = function() {
        ctx.globalAlpha = a.alpha,
        ctx.beginPath(),
        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),
        ctx.lineWidth = a.lineWidth,
        ctx.strokeStyle = a.color,
        ctx.stroke(),
        ctx.globalAlpha = 1
    }
    ,
    a
}
function renderParticule(e) {
    for (var t = 0; t < e.animatables.length; t++)
        e.animatables[t].target.draw()
}
function animateParticules(e, t) {
    for (var a = createCircle(e, t), n = [], i = 0; i < numberOfParticules; i++)
        n.push(createParticule(e, t));
    anime.timeline().add({
        targets: n,
        x: function(e) {
            return e.endPos.x
        },
        y: function(e) {
            return e.endPos.y
        },
        radius: .1,
        duration: anime.random(1200, 1800),
        easing: "easeOutExpo",
        update: renderParticule
    }).add({
        targets: a,
        radius: anime.random(80, 160),
        lineWidth: 0,
        alpha: {
            value: 0,
            easing: "linear",
            duration: anime.random(600, 800)
        },
        duration: anime.random(1200, 1800),
        easing: "easeOutExpo",
        update: renderParticule,
        offset: 0
    })
}
function debounce(e, t) {
    var a;
    return function() {
        var n = this
          , i = arguments;
        clearTimeout(a),
        a = setTimeout(function() {
            e.apply(n, i)
        }, t)
    }
}
var canvasEl = document.querySelector(".fireworks");
if (canvasEl) {
    var ctx = canvasEl.getContext("2d")
      , numberOfParticules = 30
      , pointerX = 0
      , pointerY = 0
      , tap = "mousedown"
      , colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"]
      , setCanvasSize = debounce(function() {
        canvasEl.width = 2 * window.innerWidth,
        canvasEl.height = 2 * window.innerHeight,
        canvasEl.style.width = window.innerWidth + "px",
        canvasEl.style.height = window.innerHeight + "px",
        canvasEl.getContext("2d").scale(2, 2)
    }, 500)
      , render = anime({
        duration: 1 / 0,
        update: function() {
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)
        }
    });
    document.addEventListener(tap, function(e) {
        "sidebar" !== e.target.id && "toggle-sidebar" !== e.target.id && "A" !== e.target.nodeName && "IMG" !== e.target.nodeName && (render.play(),
        updateCoords(e),
        animateParticules(pointerX, pointerY))
    }, !1),
    setCanvasSize(),
    window.addEventListener("resize", setCanvasSize, !1)
}
)
}

if (v == "...args参数和fn(...args) 入参的技巧和认知") {
Var = 
(
emit (name, ...args) {
    // 遍历数组中的所有函数并且执行，注入args
    this.map[name].forEach(_ => _(...args))
    // 能形成链式
    return this
}
)
}

if (v == "多个异步操作时，请毫不犹豫用Pormise.all") {
Var = 
(
const getName = new Promise((resolve, reject) => {
   setTimeout(function () {
        resolve('success') // reject('fail')
   }, 50);
})
Promise.all([getName, getName])
	.then(console.log)
	.catch(console.log)
)
}

if (v == "对象字面量如何使用async/await标记") {
Var = 
(
// 其实很简单，最最前面加入即可。
async init ({ commit, state, dispatch, rootState })  {
    // 获取部门id列表（包含重映射部门id）
    await dispatch('getAllDepartmentItems')
    // 获取事项id列表（包含重映射事项id）
    await dispatch('getAllMatterItems')
},

// 如果是传统的也可以这样
init: async function  ({ commit, state, dispatch, rootState }) {
    // 获取部门id列表（包含重映射部门id）
    await dispatch('getAllDepartmentItems')
    // 获取事项id列表（包含重映射事项id）
    await dispatch('getAllMatterItems')
}
)
}


if (v == "获取localStorage剩余容量和最大容量") {
Var = 
(
// 获取localStorage最大容量
(function(sum = '') {
    // 1kb 
    const unit = (function poll(num) {
        return num.length == 10240 ? num : poll(num += num)
    }('0123456789'))
    // 轮询
    const timer = setInterval(function() {
        const prev = sum
        // 叠加字符串
        sum += unit
        // 开始
        try {
            // 先删除旧的缓存，这样会加快测试速度
            window.localStorage.removeItem('test')
            // 设置新缓存
            window.localStorage.setItem('test', sum)
            // 打印当前进度
            console.log(sum.length / 1024 + 'KB')
        } catch (e) {
            // （可选）保存最后一次可行的缓存
            window.localStorage.setItem('test', prev)
            // 打印出总缓存大小
            console.log(sum.length / 1024 + 'KB超出最大限制')
            // 清除定时器
            clearInterval(timer)
        }
    }, 1)
}())


// 获取sessionStorage的剩余容量
(function(){
    if(!window.sessionStorage) {
        console.log('浏览器不支持sessionStorage');
    }
    var size = 0;
    for(item in window.sessionStorage) {
        if(window.sessionStorage.hasOwnProperty(item)) {
            size += window.sessionStorage.getItem(item).length;
        }
    }
    console.log('当前sessionStorage剩余容量为' + (size / 1024).toFixed(2) + 'KB');
})()
)
}

if (v == "memoized 函数缓存") {
_send(funcache, true, true)
return
}

if (v == "是否隐藏：$('#div').is(':hidden')") {
Var = 
(
$('#div').is(':hidden')
)
}

if (v == "是否显示：$('#div').is(':visible')") {
Var = 
(
$('#div').is(':visible')
)
}

if (v == "clickOutSide：!el.contains(event.target)") {
Var = 
(
handle = e => {
  const el = this.container
  // 核心: el.contains()，这里的el就是弹窗本身，换句话就是inSide
  if (el && !el.contains(e.target)) onClickOutside(e)
}

// 点击事件函数
const func = e => {
  // 如果点击的不是弹窗本身，那么关闭它
  if (!this.$refs.tabbar.contains(e.target)) {
    // 取消显示
    this.isShow = false
    // 取消点击事件
    document.removeEventListener('mouseup', func)
  }
}
// clickoutside
document.addEventListener('mouseup', func)
)
}


if (v == "parseInt/parseFloat可以直接移除字符串：parseFloat(layero.css('left')) // '162px' => 162") {
Var = 
(
dict.offset = [
    e.clientX - parseFloat(layero.css('left')),
    e.clientY - parseFloat(layero.css('top'))
;
)
}

if (v == "filterhtml: 移除html标签，只提取文本text()") {
_send(filterhtml, true, true)
return
}

if (v == "window.onunload 刷新/关闭页面之前发送请求") {
_send(window.onunload, true, true)
return
}

if (v == "js获取root（window）对象") {
Var = 
(
var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};
)
}


if (v == "高度从0到auto的伸缩特效魔法") {
Var =
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    .el {
        transition: max-height 0.5s;
        overflow: hidden;
        max-height: 0;
    }

    .trigger:hover>.el {
        max-height: var(--max-height);
    }
    </style>
</head>

<body>
    <div class="trigger">
        Hover me to see a height transition.
        <div class="el">content</div>
    </div>
</body>
<script>
var el = document.querySelector('.el')
var height = el.scrollHeight
el.style.setProperty('--max-height', height + 'px')
</script>

</html>
)
}

if (v == "获取前6个月/前15天数据") {
Var = 
(
// 数值补全0
// 迭代：如果实际长度超出length，那么使用实际长度，否则使用lenght
// 比如： PrefixInteger(123456, 5); 实际长度是6，那么还是会返回123456.
const PrefixInteger = (num, length) => {
    const n = (Array(length).join('0') + num)
    const len = num.toString().length
    const l = len > length ? len : length
    return n.slice(-l)
}


/**
 * 生成日报模式下的 xAxisDate 数据，
 * 业务需求:  如果是日报（day）则是取前半个月的数据，即15条数据
 * @param {String} str 当前用户选择的日报时间
 * @param {Number} len 往前获取多少天？
 * @return {Array} 如：["20181211","20181210","20181209","20181208","20181207", "20181206","20181205","20181204","20181203","20181202", "20181201","20181130","20181129","20181128","20181127"] 
 */
getDayxAxisDate(str, len) {
    // 转化为date对象
    const _date = new Date(str.substring(0, 4), str.substring(4, 6) - 1, str.substring(6, 8))

    // 往前取半个月15天
    return [...Array(len)].map((v, index, array) => {
        // 不断地回退day
        _date.setDate(_date.getDate() - 1)
        // YYYYMMDD
        return _date.getFullYear() + PrefixInteger(_date.getMonth() + 1, 2) + PrefixInteger(_date.getDate(), 2)
        // 翻转一下顺序，让数组符合desc顺序的直觉
    }).reverse()
},

/**
 * 生成月报模式下的 xAxisDate 数据，
 * 业务需求:  如果是月报（month）则是取前半年的数据，即6条数据
 * @param {String} str 当前用户选择的月报时间
 * @param {Number} len 往前获取几个月？
 * @return {Array} 如： ["20181207","20181208","201809","201810","201811","201812"]
 */
getMonthxAxisDate(str, len) {
    // 转化为date对象
    const _date = new Date(str.substring(0, 4), str.substring(4, 6) - 1)
    // 往前取半年6个月
    return [...Array(len)].map((v, index, array) => {
        // 不断地回退month
        _date.setMonth(_date.getMonth() - 1)
        // MM
        return PrefixInteger(_date.getMonth() + 1) + '月'
        // 翻转一下顺序，让数组符合desc顺序的直觉
    }).reverse()
},
---

/**
 * 获取近半年6个月
 */
const getMonthxAxisDate = (len = 6) => {
    // 转化为date对象
    const _date = new Date()
    // 往前取半年6个月
    return [...Array(len)].map((v, index, array) => {
        // MM
        const month = _date.getMonth() + 1 + '月'

        // 不断地回退month
        _date.setMonth(_date.getMonth() - 1)

        return month
        // 翻转一下顺序，让数组符合desc顺序的直觉
    }).reverse()
}

)
txtit(Var)
return
}




if (v == "获取手机归属地信息：中国移动/中国联通/中国电信") {
Var = 
(
/**
 * @func
 * @desc - 获取手机归属地信息
 * @param {string} phoneNo - 手机号码
 * @param {string} callback - 回调函数
 */
var getPhoneData = function(phoneNo, callback) {
    $.ajax({
        url: 'http://tcc.taobao.com/cc/json/mobile_tel_segment.htm',
        type: 'get',
        data: {
            tel: phoneNo
        },
        success: function(result) {
            if (result) {
                var _data = result.split('=')[1]
                _data = _data.replace(/\s+/g, "").replace(/<\/?.+?>/g, "").replace(/[\r\n]/g, "").replace(/\'/g, '"').replace(/\:/g, '":').replace(/\,/g, ',"').replace('{', '{"')
                var phoneData = JSON.parse(_data);
                console.log(phoneData)
                if (phoneData.catName === '中国移动') {
                    applyData.PhoneType = 1;
                } else if (phoneData.catName === '中国联通') {
                    applyData.PhoneType = 2
                } else if (phoneData.catName === '中国电信') {
                    applyData.PhoneType = 3
                } else {
                    applyData.PhoneType = 0
                }
                applyData.PhoneAddress = phoneData.province
            }
        },
        error: function(result) {
            console.info('无法获取手机归属地信息');
        },
        complete: function() {
            typeof callback === 'function' && submitApply();
        }
    })
}

)
}


if (v == "Android 输入法键盘 和 input 问题:scrollIntoViewIfNeeded") {
Var = 
(
/**
 * Android 输入法键盘 和 input 问题
 */
if(getSys() === 'Android') {
    window.addEventListener("resize", function() {
        if(document.activeElement.tagName=="INPUT" || document.activeElement.tagName=="TEXTAREA") {
           window.setTimeout(function() {
                document.activeElement.scrollIntoViewIfNeeded();
           }, 0);
       }
    })
}
)
}




if (v == "解构与split结合：const [language, country] = locale.split('-')") {
Var = 
(
const [language, country] = locale.split('-')
)
}

if (v == "模块模式：现代模块实现的基石") {
Var = 
(
var Module = (function($){
    var _$body = $("body");     // we can use jQuery now!
    var foo = function(){
        console.log(_$body);    // 特权方法
    }

    // Revelation Pattern
    return {
        foo: foo
    }
})(jQuery)

Module.foo();
)
}

if (v == "社会主义点击事件") {
Var = 
(
(function() {
    var coreSocialistValues = ["富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"]
      , index = Math.floor(Math.random() * coreSocialistValues.length);
    document.body.addEventListener('click', function(e) {
        if (e.target.tagName == 'A') {
            return;
        }
        var x = e.pageX
          , y = e.pageY
          , span = document.createElement('span');
        span.textContent = coreSocialistValues[index];
        index = (index + 1) `% coreSocialistValues.length;
        span.style.cssText = ['z-index: 9999999; position: absolute; font-weight: bold; color: #ff6651; top: ', y - 20, 'px; left: ', x, 'px;'].join('');
        document.body.appendChild(span);
        animate(span);
    });
    function animate(el) {
        var i = 0
          , top = parseInt(el.style.top)
          , id = setInterval(frame, 16.7);
        function frame() {
            if (i > 180) {
                clearInterval(id);
                el.parentNode.removeChild(el);
            } else {
                i += 2;
                el.style.top = top - i + 'px';
                el.style.opacity = (180 - i) / 180;
            }
        }
    }
}());
)
}

if (v == "urlparams 获取路由参数") {
_send(urlparams, true, true)
return
}





if (v == "基于原型模式的继承") {
Var = 
(
var A = function(){};
var B = function(){};
A.prototype = { name: 'sven' };

// 核心
B.prototype = new A();
var b = new B();
console.log( b.name ); // 输出：sven
)
}


if (v == "call 和 apply") {
Var = 
(
)
}


if (v == "AOP - 面向切面编程") {
Var = 
(
// （A）定义原始函数
var func = function() {
    console.log(2);
};

Function.prototype.before = function(beforefn) {
    // 保存原始函数（A）的引用
    var __self = this;

    // （B）
    return function() { 
        // 执行 before 函数
        beforefn.apply(this, arguments); 

        // 执行原始函数（A）
        return __self.apply(this, arguments);
    }
};

Function.prototype.after = function(afterfn) {
    // 保存函数（B）的引用
    var __self = this;

    // （C）
    return function() {
        // 执行函数（B）并获取执行结果，而实际上函数（B）的返回的是原始函数（A）的执行结果
        var ret = __self.apply(this, arguments);

        // 执行 after 函数
        afterfn.apply(this, arguments);

        // 返回原函数（A）的执行结果
        return ret;
    }
};

func = func.before(function() {
    console.log(1);
}).after(function() {
    console.log(3);
});

// 执行函数（C）
func();
)
}



if (v == "加强版map遍历:bettermap") {
_send(fuckmap, true, true)
return
}

if (v == "injectCss 往页面插入style") {
_send(addstyle, true, true)
return
}


if (v == "getScriptPath") {
Var = 
(
// http://stackoverflow.com/questions/2161159/get-script-path
function getScriptPath() {
    var scripts = _doc.currentScript || (function () { var s = _doc.getElementsByTagName('script'); return (s.length) ? s[s.length - 1] : false; })();
    var path = scripts ? scripts.src.split('?')[0] : '';
    return (path.split('/').length > 0) ? path.split('/').slice(0, -1).join('/') + '/' : '';
}
)
}


if (v == "处理iOS 微信客户端6.7.4 键盘收起页面未下移bug") {
Var = 
(
/**
 * 处理iOS 微信客户端6.7.4 键盘收起页面未下移bug
 */
;(/iphone|ipod|ipad/i.test(navigator.appVersion)) && document.addEventListener('blur', (e) => {
    // 这里加了个类型判断，因为a等元素也会触发blur事件
    ['input', 'textarea'].includes(e.target.localName) && document.body.scrollIntoView(false)
}, true)
)
}

if (v == "holder占位图") {
Var = 
(
<script src="https://cdn.bootcss.com/holder/2.9.6/holder.min.js"></script>
<img class="card-img-top" data-src="holder.js/100px225?theme=thumb&bg=55595c&fg=eceeef&text=Thumbnail" alt="Card image cap">
)
}

if (v == "dragscroll 拖拽滚动") {
Var = 
(
export const dragScroll = el => {
    var _window = window
        ,_document = document
        ,mousemove = 'mousemove'
        ,mouseup = 'mouseup'
        ,mousedown = 'mousedown'
        ,EventListener = 'EventListener'
        ,addEventListener = 'add'+EventListener
        ,removeEventListener = 'remove'+EventListener
        ,newScrollX, newScrollY;

    // HERE
    var startx,starty, endx, endy;


    return (function(el, lastClientX, lastClientY, pushed, scroller, cont) {
        (cont = el.container || el)[addEventListener](
            mousedown,
            cont.md = function(e) {
                if (!el.hasAttribute('nochilddrag') ||
                    _document.elementFromPoint(
                        e.pageX, e.pageY
                    `) == cont
                `) {
                    pushed = 1;
                    startx = lastClientX = e.clientX;
                    starty = lastClientY = e.clientY;

                    e.preventDefault();
                }
            }, 0
        `);

        el[addEventListener](
            mouseup, cont.mu = function(e) { 
                pushed = 0;  
                // HERE
                endx = e.clientX;
                endy = e.clientY;
                // setTimeout(function(){ el.classList.remove("dragging"); }, 100);
            }, 0
        `);

        el[addEventListener](
            mousemove,
            cont.mm = function(e) {
                if (pushed) {
                    // HERE
                    // el.classList.add("dragging");
                    (scroller = el.scroller || el).scrollLeft -= newScrollX = (-lastClientX + (lastClientX = e.clientX));
                    scroller.scrollTop -= newScrollY = (-lastClientY + (lastClientY = e.clientY));
                    if (el == _document.body) {
                        (scroller = _document.documentElement).scrollLeft -= newScrollX;
                        scroller.scrollTop -= newScrollY;
                    }
                }

            }, 0
        `)

        return function (CLICKHANDLER) {
            if (Math.abs(starty - endy) <= 1) {
                CLICKHANDLER && CLICKHANDLER(el)
            }
        }
    })(el);
}
)
}

if (v == "$.scrollforevery 无缝滚动") {
Var = 
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/dragscroll/0.0.8/dragscroll.min.js"></script>
    <script src="https://cdn.staticfile.org/jquery.nicescroll/3.7.6/jquery.nicescroll.min.js"></script>
    <script>
    </script>
    <style>
    html,
    body {
        margin: 0;
        padding: 0;
    }

    *,
    ::after,
    ::before {
        box-sizing: border-box;
    }

    #app {
        height: 200px;
        background: thin;
        width: 200px;
        overflow: scroll;
        cursor: move;
    }

    p {
        height: 40px;
        margin: 0;
        padding: 0;
    }
    </style>
</head>
<body>
    <div id="app" class='dragscroll'>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
    </div>
</body>
<script>
const $app = $('#app')
const innerHeight = 40
const len = 5
const distance = innerHeight * len
let timer = null
const start = () => {
 timer = setInterval(function() {
     const scrollDistance = $app.scrollTop();
     if (scrollDistance >= distance) {
         $app.scrollTop(0)
     } else {
         $app.scrollTop(scrollDistance + 1)
     }
 }, 10);
}

start()

$('#app').niceScroll({ cursorcolor: 'rgba(0,0,0,0.2)', autohidemode: 'hidden' })

$('#app').mouseover(e => {
    clearInterval(timer);
}).mouseleave(e => {
    start()
})
</script>

</html>
)
}

if (v == "$.autoscroll 自动滚动") {
Var = 
(
$.fn.extend({
    'autoScroll': function (options) {
	    // 配置参数
	    var opt = $.extend({}, {speed: 1500, size: 4, height: 40, time: 10000}, options)
	    // jQuery对象
	    var $el = this;
	    // 时间器
	    var timer = null;
	    // 核心函数
	    var _autoScroll = function () {
	        // 自动滚动
	        timer =  setInterval(function () {
	            // 滚动的速度
	            const speed = opt.speed
	            // 每次滚动多少条
	            const size = opt.size;
	            // 每条的高度是多少
	            const height = opt.height;
	            // 每次滚动的距离
	            const distance = size * height;
	            // 当前滚动的高度
	            const currentScrollTop = $el.scrollTop()
	            // 底部位置
	            const bottom = $el.prop('scrollHeight') - $el.height()
	            // 如果已经滚到底了
	            if (Math.floor(currentScrollTop) === Math.floor(bottom)) {
	                // 滚回头部
                    // $el.animate({ scrollTop: 0 }, 0).animate({ scrollTop: distance + 'px' }, speed);
                    // 滚回头部
                    $el.animate({ scrollTop: 0 }, speed);
	            } else {
	                // 余数
	                const remainder = currentScrollTop `% height
	                // 下一次滚动的位置 = 当前位置 + 每次滚动的位置 - 余数
	                const nextScrollTop = currentScrollTop + distance - remainder
	                // 开始滚动
	                $el.animate({ scrollTop: nextScrollTop + 'px' }, speed);
	            }
	        // 滚动间隔
	        }, opt.time + opt.speed);
	        // 鼠标移入的时候，删除自动滚动, 鼠标移出的时候，自动滚动
	        $el.one('mouseover', function () { clearInterval(timer)}).one('mouseleave', _autoScroll)
	        // 将timer放入jQuery对象的缓存中，方便后续操作
	        $el.data('timer', timer)
	    }
	    // 开始滚动
	    _autoScroll()
	    // 返回时间器，方便后续操作
	    return timer
	},
	'stopScroll': function () {
	     // jQuery对象
	    var $el = this;
	    // 时间器
	    var timer = $el.data('timer')
	    // 消除它就是停止它（其实这里还需要结束动画，但就不做那么麻烦了）
	    clearInterval(timer);
	}
});

$('.trajectoryTable').autoScroll()
)
}

if (v == "window.requestAnimFrame") {
_send("requestanimate", true, true)
return
}

if (v == "encodeURI URI过滤") {
Var = 
(
function urlencode (str) {  
    str = (str + '').toString();   

    return encodeURIComponent(str)
            .replace(/!/g, '`%21')
            .replace(/'/g, '`%27')
            .replace(/\(/g, '`%28').  
            replace(/\)/g, '`%29')
            .replace(/\*/g, '`%2A')
            .replace(/`%20/g, '+');  
}
)
}

if (v == "deepfind 深度递归搜索") {
Var = 
(
var fuck = [{"label": "占用道路问题", "value": 31, "children": [{"label": "经营占道", "value": 35, "children": [{"label": "店外经营占道", "value": 40, "children": null }, {"label": "流动摊贩占道", "value": 41, "children": null } ] }, {"label": "垃圾占道", "value": 36, "children": [{"label": "生活垃圾", "value": 42, "children": null }, {"label": "建筑垃圾", "value": 43, "children": null }, {"label": "工业垃圾", "value": 44, "children": null } ] }, {"label": "车辆占道", "value": 37, "children": [{"label": "机动车占道", "value": 45, "children": null }, {"label": "非机动车占道", "value": 46, "children": null } ] }, {"label": "霸占车位", "value": 38, "children": [] }, {"label": "其他占道", "value": 39, "children": [] } ] }, {"label": "“两违”问题", "value": 32, "children": [{"label": "违法建筑", "value": 58, "children": [{"label": "房屋违建", "value": 61, "children": null }, {"label": "小区违建", "value": 62, "children": null }, {"label": "违建棚架", "value": 63, "children": null } ] }, {"label": "违法用地", "value": 59, "children": [] }, {"label": "其他违建", "value": 60, "children": [] } ] }, {"label": "市容设施管理问题", "value": 33, "children": [{"label": "道路损坏", "value": 47, "children": [] }, {"label": "垃圾桶损坏", "value": 48, "children": [] }, {"label": "下水道堵塞", "value": 49, "children": [] }, {"label": "井盖损坏", "value": 50, "children": [] }, {"label": "路灯损坏", "value": 51, "children": [] }, {"label": "树木修剪", "value": 52, "children": [] }, {"label": "水电气", "value": 53, "children": [] }, {"label": "户外广告牌", "value": 54, "children": [] }, {"label": "隔音屏损坏", "value": 55, "children": [] }, {"label": "洒水车问题", "value": 56, "children": [] }, {"label": "其他", "value": 57, "children": [] } ] }, {"label": "其他问题", "value": 34, "children": [] } ]
const deepFind = ({ arr = [], key = '', val = '', children = 'children'} = {}) => {
    // 即将返回的数组
    var main = []
    // 如果没有键也没有值，那么还是直接返回吧
    if (!val || !key) return main
    // 用try方案方便直接中止所有递归的程序
    try {
        // 开始轮询
        (function poll(arr, level) {
            // 如果传入非数组
            if (!Array.isArray(arr)) return
            // 遍历数组
            for (var i = 0; i < arr.length; i++) {
                // 获取当前项
                var item = arr[i]
                // 先占位预设值
                main[level] = item[key]
                // 如果已经找到了
                if (item[key] === val) {
                    // 直接抛出错误中断所有由父及子的所有轮询
                    throw Error
                // 如果存在children，那么深入递归
                } else if (item[children] && item[children].length) {
                    poll(item[children], level + 1)
                // 如果是最后一个了且没有找到值，那么删除之
                } else if (i === arr.length - 1) {
                   // 删除占位预设值
                   main.length = main.length - 1
                }
            }
        })(arr, 0)
    // 错误捕捉仅为程序正常执行
    } catch (err) {}

    // 返回最终数组
    return main
}
var myarr = deepFind({ arr: fuck, key: 'value', val: 63, children: 'children' })
console.log(20181115092957, myarr)
)
}


if (v == "compose 函数组合") {
Var = 
(
function compose () {
	let args = arguments
	let start = args.length - 1

	return function () {
		let i = start
		let result = args[start].apply(this, arguments)
		while (i--)
			result = args[i].call(this, result)
		return result
	}
}

const explode = _ => _.split(/\s+/)
const count = _ => _.length
const countWords = compose(count, explode);
countWords(``a
			b
			c
			d``); // => 4
)
}


if (v == "(〜￣△￣)〜认知～(￣▽￣～)：({a = 123, b = 321, c = 456} = {}) 对象解构 与 参数默认值") {
Var =
(
var abc = ({a = 123, b = 321, c = 456} = {}) => console.log(20181109155055, a)
abc()
)
}

if (v == "Object.assign({}, )") {
Var =
(
Object.assign({}, )
)
}
if (v == "Object.is 比 === 更严格的比较") {
Var =
(
0 === -0 // true
NaN === NaN // false（这也是NaN的特性）

Object.is(0, -0) // false
Object.is(NaN, NaN) // true
)
}

if (v == "'tail' in cat / cat.hasOwnProperty('tail') 判断对象是否包含某属性") {
Var =
(
'tail' in cat
cat.hasOwnProperty('tail')
)
}
if (v == "Object.getOwnPropertyDescriptor({a: 123}, 'a') 获取属性的配置") {
Var =
(
// {value: 123, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({a: 123}, "a")
)
}
if (v == "Object.defineProperty 属性的权限设置 writable（可写） / configurable（可配置）/enumerable（可枚举）") {
Var =
(
var myObject = {};

Object.defineProperty(myObject, "a", {
  value: 2,
  writable: true,  // 可写
  configurable: true, // 可配置
  enumerable: true  // 可枚举
});

myObject.a // 2
)
}
if (v == "Object.defineProperties 属性的批量权限设置") {
Var =
(

)
}

if (v == "getter / setter") {
Var =
(

)
}

if (v == "delete person.age 删除对象的属性") {
Var =
(
delete person.age
)
}


if (v == "cache request axios 缓存请求") {
_send("request.js", true, true)
return
}

if (v == "AMD/CommonJS/factory/module") {
Var = 
(
(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['exports', 'echarts'], factory);
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports, require('echarts'));
    } else {
        // Browser globals
        factory({}, root.echarts);
    }
}(this, function(exports, echarts) {
    if (!echarts) {
        log('ECharts is not Loaded');
        return;
    }
}));

;(function (root, factory) {
  if (typeof exports === "object") {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define([], factory);
  } else {
    root.FUCKYOU = factory();
  }
}(this,function () {
　　// ...  这里编写你的代码
　　return {
      
   };
});
)
}

if (v == "JSON.parse(JSON.stringify(...)) 超简易拷贝") {
Var = 
(
JSON.parse(JSON.stringify(...))
)
}

if (v == "setattr") {
Var = 
(
el.setAttribute('tabindex', 3);
)
}

if (v == "removeattr") {
Var = 
(
document.querySelector('.fuck').removeAttribute('disabled');
)
}


if (v == "onscript/loadscript 加载脚本并等待加载完成") {
Var = 
(
/**
 * 加载script并且执行回调
 * @param {String} url 资源地址
 * @param {Function} cb 回调方法
 * https://www.cnblogs.com/_franky/archive/2010/06/20/1761370.html
 */
var onscriptload = function (url, cb) {
  var node = document.createElement("script")
  var head = document.getElementsByTagName('head')[0]
  var timeID
  var supportLoad = "onload" in node
  var onEvent = supportLoad ? "onload" : "onreadystatechange"
  node[onEvent] = function onLoad() {
      if (!supportLoad && !timeID && /complete|loaded/.test(node.readyState)) {
          timeID = setTimeout(onLoad)
          return
      }
      if (supportLoad || timeID) {
          clearTimeout(timeID)
          cb && cb()
      }
  }
  head.insertBefore(node, head.firstChild)
  node.src = url
}

onscriptload('https://cdn.bootcss.com/jquery/1.9.1/jquery.min.js', function () {
   console.log(jQuery.fn.jquery);
   console.log($('*').size())
})

)
}

if (v == "isNodeList") {
Var = 
(
Object.prototype.toString.call(v) === '[object NodeList]'
)
}

if (v == "is") {
Var = 
(
// 仿ramda: https://github.com/ramda/ramda/blob/master/source/is.js
const is = (type, val) => {
	return val != null && val.constructor === type || val instanceof type;
}

is(String, '123')     // => true
is(Number, 123)       // => true
is(Date, new Date())  // => true
is(Object, {})        // => true
is(Array, [])         // => true
)
}

if (v == "curry2 二元参数的手动柯里化") {
Var = 
(
// 二元参数的手动柯里化
function curry2(fn) {
	return function(firstArg){
		return function (secondArg) {
			return fn(firstArg, secondArg)
		}
	}
}
)
}

if (v == "es6.class") {
_send(js.class)
return
}

if (v == "for-- 循环中splice需要使用") {
Var = 
(
var Things = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
var arr = []
for (var i = Things.length - 1; i >= 0; i--) {
	if (Things[i] `% 2 === 0) {
		arr.push(...Things.splice(i, 1))
		console.log(Things, arr)
	}
}
)
}



if (v == "Model 类") {
Var = 
(
import { getUUID } from '@/utils/utils.js'

export default class Model {
	constructor ({ size = 20 } = {}) {
		// 核心数据
		this.data = null
		// token
		this.token = ''
		// 是否加载中
		this.loading = false
		// 是否数据为空
		this.empty = false
		// 是否正在加载更多
		this.loadingmore = false
		// 是否没有更多了
		this.nomore = false
		// 总数
		this.total = 0
		// 页码
		this.page = 0
		// 数量
		this.size = this._size = size
		// 是否报错了
		this.error = ''
	}

	// 重置
  resetWhere () {
	  this.token = ''
	  this.loading = false
	  this.empty = false
	  this.loadingmore = false
	  this.nomore = false
	  this.total = 0
	  this.page = 0
	  this.size = this._size
	  this.error = ''
  }

  // 显示loading并且返回token
  showLoading () {
    this.loading = true
  }

  // 显示loadingmore并且返回token
  showLoadingmore () {
    this.loadingmore = true
  }

  // 隐藏loading
  hideLoading () {
    this.loading = false
  }

  // 隐藏Loadingmore
  hideLoadingmore () {
    this.loadingmore = false
  }

  // 页码++
  pagePlus () {
	  this.page++
  }

  // 是否是第一次加载
  isFirstPage () {
    return this.page === 0
  }

  // 刷新token并且返回token
  refreshToken () {
    return this.token = getUUID()
  }

  // 设置data以及一系列逻辑
  setData ({ data = [], total = 0, token = ''} = {}, cb = null) {
    // 如果token不一致，说明请求被覆盖了。应该中止逻辑演变
    if (token && this.token != token) return

    this.total = total
    this.loading = false
    this.loadingmore = false

    const isEmptyData = data.length === 0

    // empty 表示没有数据
    if (this.isFirstPage() && isEmptyData)
      this.empty = true

    // nomore 表示没有更多数据
    if (data.length < this.size || (!this.isFirstPage() && isEmptyData))
      this.nomore = true

    // 如果有数据，应该重置标识
    if (!isEmptyData) {
      this.empty = false
      // 就算有数据，如果不够长度，也是数据nomore
      if (data.length === this.size)
        this.nomore = false
    }

    if (this.isFirstPage())
      this.data = data
    else
      this.data = Array.prototype.concat.call(this.data || [], data)

    // 执行回调
    cb && cb(this)
  }
}
)
}

if (v == "scrollIntoView 滚动到元素可视区域") {
Var = 
(
document.querySelector(".loadingmore").scrollIntoView();
)
}

if (v == "throttle 函数节流") {
Var = 
(

// 函数节流（throttle）
var throttle = function(func, wait, options) {
  var timeout, context, args, result;
  // 标记时间戳
  var previous = 0;
  // options可选属性 leading: true/false 表示第一次事件马上触发回调/等待wait时间后触发
  // options可选属性 trailing: true/false 表示最后一次回调触发/最后一次回调不触发
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : +(new Date());
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    // 记录当前时间戳
    var now = +(new Date());
    // 如果是第一次触发且选项设置不立即执行回调
    if (!previous && options.leading === false)
    // 将记录的上次执行的时间戳置为当前
    previous = now;
    // 距离下次触发回调还需等待的时间
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;

    // 等待时间 <= 0或者不科学地 > wait（异常情况）
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
          // 清除定时器
        clearTimeout(timeout);
        // 解除引用
        timeout = null;
      }
      // 将记录的上次执行的时间戳置为当前
      previous = now;

      // 触发回调
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    }
    // 在定时器不存在且选项设置最后一次触发需要执行回调的情况下
    // 设置定时器，间隔remaining时间后执行later
    else if (!timeout && options.trailing !== false)    {
      timeout = setTimeout(later, remaining);
    }
   return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
};

// demo
var fn = (data) => console.log(20180926160742, data);
// leading 为 true时，第一次执行立即触发，这比setTimeout好多了
// trailing 为 fasle时，不会触发最后一次。这样比较符合直觉。
const fn2 = throttle(fn, 3000, { leading: true, trailing: false });
fn2(123) // 请手动不停的执行这个函数
)
}

if (v == "debounce 函数去抖") {
_send("hanshuqudou", true, true)
return
}

if (v == "is-ie") {
Var = 
(
(function(){ //ie版本
    var agent = navigator.userAgent.toLowerCase();
    return (!!window.ActiveXObject || "ActiveXObject" in window) ? (
      (agent.match(/msie\s(\d+)/) || [])[1] || '11' //由于ie11并没有msie的标识
    `) : false;
}())
)
}

if (v == "cookie 库") {
Var = 
(
/**
 * @desc  设置Cookie
 * @param {String} name
 * @param {String} value
 * @param {Number} expires
 */
function setCookie(name, value, expires) {
    var cookieString = name + "=" + escape(value);
    //判斷是否設置過期時間,0代表關閉瀏覽器時失效
    if (expires > 0) {
        var date = new Date();
        date.setTime(date.getTime() + expires * 1000);
        cookieString = cookieString + ";expires=" + date.toUTCString();
    }
    document.cookie=cookieString;
}

/**
 * @desc 根据name读取cookie
 * @param  {String} name
 * @return {String}
 */
function getCookie(name) {
    var arr = document.cookie.replace(/\s/g, "").split(';');
    for (var i = 0; i < arr.length; i++) {
        var tempArr = arr[i].split('=');
        if (tempArr[0] == name) {
            return decodeURIComponent(tempArr[1]);
        }
    }
    return '';
}

/**
 * @desc 根据name修改cookie
 * @param  {String} name
 * @param  {String} value
 * @param  {Number} expires 
 */
function editCookie(name, value, expires){
    var cookieString = name + "=" + escape(value);
    if (expires > 0) {
        var date = new Date();
        date.setTime(date.getTime() + expires * 1000);
        cookieString = cookieString + ";expires=" + date.toGMTString();
    }
    document.cookie = cookieString;
}

/**
 * @desc 根据name删除cookie
 * @param  {String} name
 */
function removeCookie(name) {
    // 设置已过期，系统会立刻删除cookie
    setCookie(name, '', -1);
}
)
}

if (v == "countDown 倒计时") {
Var = 
(
/**
 * 開始倒計時
 * http://candy.dragonvein.io/frontend/web/site/signup
 * @param {jQuery DOM} $dom
 * <input type='button' id='second' value = '獲取驗證碼 | Get SMS Code'/>
 */
$(function () {
	// 触发按钮
	$("#second").click(function () {
	    sendCode();
	});
	// 獲取cookie值
	v = getCookie("secondsremained_login") ? getCookie("secondsremained_login") : 0;
	if (v > 0) {
		 // 開始倒計時
	    countDown($("#second")); 
	}
})

function sendCode () {
	// 设置默认时间
	setCookie('secondsremained_login', '60', 60)
	// 開始倒計時
    countDown($("#second")); 
}

function countDown ($dom) {
	var countdown = getCookie('secondsremained_login') ? getCookie('secondsremained_login') : 0;
	(function settime () {
		if (countdown == 0) {
		    $dom.removeAttr('disabled');
		    $dom.val('獲取驗證碼 | Get SMS Code');
		    return;
		} else {
		    $dom.attr('disabled', true);
		    $dom.val(countdown + '秒後重發 | Waiting ' + countdown + 's');
		    countdown--;
		    editCookie('secondsremained_login', countdown, countdown + 1);
		}
		setTimeout(function() { settime($dom) },1000) //每1000毫秒執行壹次
	}());
}
)
}

if (v == "rem 解决方案 / 淘宝解决方案") {
_send(taobao)
return 
}

if (v == "lazyload 图片懒加载") {
Var = 
(
/**
 * 图片懒加载
 * https://www.liaoxuefeng.com/article/00151045553343934ba3bb4ed684623b1bf00488231d88d000
 * <img src="https://loading.io/assets/img/ajax.gif" data-src="http://www.hongte.info/assets/images/banner2.jpg">
 * <div style="margin-top: 1000px;"></div>
 */
;(function(){
    // 获取包含data-src属性的img
    var lazyImgs = document.querySelectorAll('img[data-src]')
    // 将Node-List转化成数组类型
    lazyImgs = [].slice.apply(lazyImgs);
     // 定义事件函数
    var lazyload = function () {
        // 获取页面滚动的高度
        var wtop = window.scrollY;
        // 获取可视区域高度
        var wheight = document.documentElement.clientHeight;
        // 判断是否还有未加载的img
        if (lazyImgs.length > 0) {
            // 循环处理数组的每个img元素
            for (var i = lazyImgs.length - 1; i >= 0; i--) {
                // 获取图片信息
                var el = lazyImgs[i], rect = el.getBoundingClientRect(), src = el.getAttribute('data-src')
                // 判断是否在可视范围内:
                if (rect.top - wtop < wheight) {
                   // 设置src属性:
                   el.setAttribute('src', src);
                   // 删除对象
                   Array.prototype.splice.call(lazyImgs, i, 1);
                }
            }
        }
    };

    // 懒加载优化：滚动节流策略
    var __SCROLLTIMER__ = null
    // 绑定事件
    window.onscroll = function () {
        clearTimeout(__SCROLLTIMER__);
        __SCROLLTIMER__ = setTimeout(lazyload, 150);
    }

    // 手动触发一次, 因为页面显示时，并未触发scroll事件。
    lazyload();
}());
)
}

if (v == "copyToClipboard 剪切板") {
Var = 
(
// 剪切板
export const copyToClipboard = (text, cb) => {
    if(text.indexOf('-') !== -1) {
        let arr = text.split('-');
        text = arr[0] + arr[1];
    }
    var textArea = document.createElement("textarea");
      textArea.style.position = 'fixed';
      textArea.style.top = '0';
      textArea.style.left = '0';
      textArea.style.width = '2em';
      textArea.style.height = '2em';
      textArea.style.padding = '0';
      textArea.style.border = 'none';
      textArea.style.outline = 'none';
      textArea.style.boxShadow = 'none';
      textArea.style.background = 'transparent';
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();

      try {
        var successful = document.execCommand('copy');
        cb && cb()
      } catch (err) {
        console.log('该浏览器不支持点击复制到剪贴板');
      }
      document.body.removeChild(textArea);
}
)
}

if (v == "maybe 神奇的预设函数") {
Var = 
(
const maybe = (fn, n = '') => {
   try {
      const result = fn()
      return (result && result === result && result !== 'NaN' && result !== 'Invalid date') ? result : n
   } catch (err) {
      return n
   }
}

var obj = {
 a: 123
}
maybe(_=> obj.a, 0); // 123
maybe(_=> obj.b, 0); // 0
maybe(_=> obj.a.b.s.w.holy.shit.fuck.god, 0); // 0
)
}

if (v == "ClickOutside 点击外部冒泡") {
_send("clickoutside", true, true)
return
}

if (v == "addcss/link 样式加载器") {
Var = 
(
var link = function(href, fn, cssname){
	var that = this
	,link = doc.createElement('link')
	,head = doc.getElementsByTagName('head')[0];

	if(typeof fn === 'string') cssname = fn;

	var app = (cssname || href).replace(/\.|\//g, '')
	,id = link.id = 'layuicss-'+app
	,timeout = 0
	,time = 10;

	link.rel = 'stylesheet';
	link.href = href + (config.debug ? '?v='+new Date().getTime() : '');
	link.media = 'all';

	if(!doc.getElementById(id)){
	  head.appendChild(link);
	}

	if(typeof fn !== 'function') return that;

	//轮询css是否加载完毕
	;(function poll() {
	  if(++timeout > time * 1000 / 100){
	    return console.error(href + ' timeout');
	  };
	  <这里写上你的条件> ? fn() : setTimeout(poll, 100);
	}());

	return that;
};

var addcss = function(firename, fn, cssname){
	return link(config.dir + 'css/' + firename, fn, cssname);
};
)
}

if (v == "getstyle") {
Var = 
(
getComputedStyle(el)[ruleName];
)
}

if (v == "is-wx") {
Var = 
(
var is_weixn = function () {
    var ua = navigator.userAgent.toLowerCase();
    if(ua.match(/MicroMessenger/i)=="micromessenger") {
        return true;
    } else {
        return false;
    }
}
)
}

if (v == "poll 递归") {
Var = 
(
// 递归
var maxTimeout = 10,
    timeout = 0,
    wait = 4, 
    callback = function() {
       // ... 这样写上条件成功时执行的内容
    };
(function poll() {
    if (++timeout > maxTimeout * 1000 / wait) {
        return window.alert('超时');
    };
    <这里写上你的判断> ? callback() : setTimeout(poll, wait);
}());
)
}

if (v == "escapeHTML 防止XSS") {
Var = 
(
var escape = function(html){
  return String(html || '').replace(/&(?!#?[a-zA-Z0-9]+;)/g, '&amp;')
  .replace(/</g, '&lt;').replace(/>/g, '&gt;')
  .replace(/'/g, '&#39;').replace(/"/g, '&quot;');
}
)
}

if (v == "preloadimg 图片预加载") {
Var = 
(
var perloadimg = function(url, callback, error) {
    var img = new Image();
    img.src = url;
    if(img.complete){
      return callback(img);
    }
    img.onload = function(){
      img.onload = null;
      typeof callback === 'function' && callback(img);
    };
    img.onerror = function(e){
      img.onerror = null;
      typeof error === 'function' && error(e);
    };
};

const preLoadImages = (imgs) => {
  var imgWrap = [];
  imgs.forEach(function (path) {
       new Image().src = path;
  });
}
preLoadImages(['./bg.png', './bg2.png'])
)
}

if (v == "device 获取设备信息") {
Var = 
(
var device = function(key){
  var agent = navigator.userAgent.toLowerCase()

  //获取版本号
  ,getVersion = function(label){
    var exp = new RegExp(label + '/([^\\s\\_\\-]+)');
    label = (agent.match(exp)||[])[1];
    return label || false;
  }
  
  //返回结果集
  ,result = {
    os: function(){ //底层操作系统
      if(/windows/.test(agent)){
        return 'windows';
      } else if(/linux/.test(agent)){
        return 'linux';
      } else if(/iphone|ipod|ipad|ios/.test(agent)){
        return 'ios';
      } else if(/mac/.test(agent)){
        return 'mac';
      } 
    }()
    ,ie: function(){ //ie版本
      return (!!window.ActiveXObject || "ActiveXObject" in window) ? (
        (agent.match(/msie\s(\d+)/) || [])[1] || '11' //由于ie11并没有msie的标识
      `) : false;
    }()
    ,weixin: getVersion('micromessenger')  //是否微信
  };
  
  //任意的key
  if(key && !result[key]){
    result[key] = getVersion(key);
  }
  
  //移动设备
  result.android = /android/.test(agent);
  result.ios = result.os === 'ios';
  
  return result;
};
)
}



if (v == "isBottom 是否滚动到底部") {
_send(isbottom)
return
}

if (v == "isURL") {
Var = 
(
export const isString = input => Object.prototype.toString.call(input) === '[object String]'
)
}

if (v == "isString") {
Var = 
(
export const isString = input => Object.prototype.toString.call(input) === '[object String]'
)
}

if (v == "isBoolean") {
Var = 
(
export const isBoolean = input => Object.prototype.toString.call(input) === '[object Boolean]'
)
}

if (v == "isZH-Cn") {
Var = 
(
// 是否包含中文
const iszh = str => /[\u4e00-\u9fa5]+/.test(str)

// 必须全部是中文
const isZH = str => /^[\u4e00-\u9fa5]+$/.test(str)
)
}
if (v == "isIp") {
Var = 
(
body.match(/\d\.\d\.\d\.\d:\d/g);
)
}
if (v == "isPhone") {
Var = 
(
// 推荐第一个即可，其他的不靠谱
const isMobile = mobile => /^[1][3,4,5,7,8,9][0-9]{9}$/.test(mobile)
)
}
if (v == "isPwd") {
Var = 
(
/[A-Za-z].*[0-9]|[0-9].*[A-Za-z]/.test('123456a@') // 必须同时包含数字和字母,支持非法符号
)
}
if (v == "isUser") {
Var = 
(
 /^[a-zA-Z0-9-_]*$/.test('') // 由6-16位数字、 字母、 '_'、 '-'组成，不含特殊字符
)
}
if (v == "isId") {
Var = 
(
if (!/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/.test('445222199307100337')){
    throw new Error('非法身份证')
}
)
}
if (v == "isEmail") {
Var = 
(
)
}

if (v == "isZH-Cn") {
Var = 
(
if (!/^[\u4e00-\u9fa5]+$/.test('李钊鸿')) {
      throw new Error('请输入中文汉字')
}
)
}



if (v == "gettop 获取距离顶部的相对距离") {
Var = 
(
// 获取距离顶部的相对距离
function getElementTop(element){
    try {
　  　　　var actualTop = element.offsetTop;
　  　　　var current = element.offsetParent;
　  　　　while (current !== null){
　  　　　　　actualTop += current.offsetTop;
　  　　　　　current = current.offsetParent;
　  　　　}
　  　　　return actualTop;
    } catch (e) {}
}
)
}

if (v == "scrollToTop 滚动到头部") {
Var = 
(
var timer = null;
var goTop = function() {
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
            document.body.scrollTop = document.documentElement.scrollTop = oTop - 500;
            timer = requestAnimationFrame(fn);
        } else {
            cancelAnimationFrame(timer);
        }
    });
}
// es6
const scrollToTop = () => {
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c > 0) {
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  }
};
)
}


if (v == "pad 自动补全") {
Var = 
(
// 自动补全
function pad (target, n) {
    var zero = new Array(n).join('0');
    var str = zero + target;
    var result = str.substr(-n);
    return result;
}
)
}

if (v == "isArray") {
Var = 
(
// 是否为数组
const isArray = input => input instanceof Array || Object.prototype.toString.call(input) === '[object Array]'
)
}

if (v == "isDate") {
Var = 
(
export const isDate = input => input instanceof Date || Object.prototype.toString.call(input) === '[object Date]'
)
}

if (v == "isFunction") {
Var = 
(
export const isFunction = input => input instanceof Function || Object.prototype.toString.call(input) === '[object Function]'
)
}

if (v == "isNumber") {
Var = 
(
export const isNumber = input => (typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]') && input === input
)
}


if (v == "isPlainObject") {
Var = 
(
var isPlainObject = function isPlainObject(obj) {
  if (!obj || toStr.call(obj) !== '[object Object]') {
    return false;
  }

  var hasOwnConstructor = hasOwn.call(obj, 'constructor');
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
  // Not own constructor property must be Object
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  var key;
  for (key in obj) { /**/ }

  return typeof key === 'undefined' || hasOwn.call(obj, key);
};
)
}

if (v == "isPureObject") {
Var = 
(
export const isEmptyObject = obj => {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}
)
}

if (v == "isObject") {
Var = 
(
// 是否为对象
export const isObject = input => input != null && Object.prototype.toString.call(input) === '[object Object]'
)
}

if (v == "isPromise") {
Var = 
(
const isPromise = val => val && typeof val.then === 'function'
)
}

if (v == "isNaN") {
Var = 
(
function isNaN(obj) {
    return obj !== obj
}
)
}


if (v == "getElementPosition 获取元素的定位") {
Var = 
(
function getElementPosition (el: Element, offset: Object): Object {
  const docEl: any = document.documentElement
  const docRect = docEl.getBoundingClientRect()
  const elRect = el.getBoundingClientRect()
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}
)
}


if (v == "uuid 超简易版") {
Var = 
(
// 36位
function getUUID () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    return (c === 'x' ? (Math.random() * 16 | 0) : ('r&0x3' | '0x8')).toString(16)
  })
}

// 32位 正式版
const UUIDGeneratorBrowser = () => ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16));
UUIDGeneratorBrowser(); // '7982fcfe-5721-4632-bede-6000885be57d'

// 9位 简易版
const MdUuid = () => Math.random().toString(36).slice(4)
MdUuid() // "r1mca5d4z"
)
}


if (v == "hasClass") {
Var = 
(
export const hasClass = (el, className) => {
  if (el.classList)
    return el.classList.contains(className);
  else
    return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
}
)
}

if (v == "addClass") {
Var = 
(
export const addClass = (el, cls) => {
        if (el.classList) {
            el.classList.add(cls)
        } else {
            var cur = ' ' + utils.getClassName(el) + ' '
            if (cur.indexOf(' ' + cls + ' ') < 0) {
                el.setAttribute('class', (cur + cls).trim())
            }
        }
    }
)
}

if (v == "removeclass") {
Var = 
(
export const removeClass = (el, cls) => {
        if (el.classList) {
            el.classList.remove(cls)
        } else {
            var cur = ' ' + utils.getClassName(el) + ' ',
                tar = ' ' + cls + ' '
            while (cur.indexOf(tar) >= 0) {
                cur = cur.replace(tar, ' ')
            }
            el.setAttribute('class', cur.trim())
        }
    }
)
}

if (v == "getclassname") {
Var = 
(
export const getClassName = (el) => {
        return (el.className instanceof SVGAnimatedString ? el.className.baseVal : el.className)
    }
)
}

if (v == "setStyle") {
Var = 
(
export const setStyle = (element, styleName, value) => {
    if (!element || !styleName) return;

    if (typeof styleName === 'object') {
        for (var prop in styleName) {
            if (styleName.hasOwnProperty(prop)) {
                setStyle(element, prop, styleName[prop]);
            }
        }
    } else {
        if (styleName === 'opacity' && ieVersion < 9) {
            element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
        } else {
            element.style[styleName] = value;
        }
    }
};
)
}

if (v == "Vue 进度条组件") {
Var = 
(
<template>
    <div class="myprogress" :style='{ width: mywidth }'></div>
</template>

<script>
export default {
  name: 'myprogress',
  data () {
    return {
      mywidth: 0
    }
  },
  methods: {
      go () {
          console.log('go');
      }
  },
  props: {
    _width: {
      default: 0,
      type: String
    }
  },
  components: {

  },
  computed: {

  },
  watch: {
    _width (newV) {
      this.mywidth = 0
      setTimeout(_ => this.mywidth = newV, 50)
    }
  },
  mounted () {
      setTimeout(() => {
        this.mywidth = this._width
      }, 50);
  }
}
</script>

<style lang="scss" scoped>

.myprogress {
  transition: .5s all ease;
  width: 0;
}
</style>
)
}

code(Var)
return


::base64::
::img2base64::
Var =
(
var getBase64Image = img => {
    var { width, height } = img
    var canvas = document.createElement('canvas')
    canvas.width = width
    canvas.height = height
    var ctx = canvas.getContext('2d')
    ctx.drawImage(img, 0, 0, width, height)
    var ext = img.src.substring(img.src.lastIndexOf('.') + 1).toLowerCase()
    var dataURL = canvas.toDataURL('image/' + ext)
    return dataURL
}


var img2Base64 = url => new Promise((resolve, reject) => {
   var img = new Image()
   img.setAttribute('crossOrigin', 'anonymous')
   img.src = url
   img.onload = function() {
       var base64 = getBase64Image(img)
       resolve(base64)
   }
})


;(async function(){
    var promise_data = data.map(async (_, index) => {
        var avatar = await img2Base64(_.icon)
        console.log(`已收录${_.name}的头像：${index}`)
        return Object.assign({}, _, { avatar })
    })

    var _data = await Promise.all(promise_data)
  
    // cosole.save
    console.log('所有数据', _data)
}())
---
// 将base64转化为图片
const fs = require('fs')
const base64Data = avatar.replace(/^data:image\/\w+;base64,/, "")
const dataBuffer = new Buffer(base64Data, 'base64')
fs.writeFile('images.png', dataBuffer, function(err) {
  console.log('success：' + name)
})
---
// 最新nodejs语法
const { name, avatar } = val
const base64Data = avatar.replace(/^data:image\/\w+;base64,/, '')
const dataBuffer = new Buffer.alloc(base64Data.length, base64Data, 'base64')
fs.writeFile(`${name}.jpg`, dataBuffer) 
---
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADcAAABCCAYAAADzNE40AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAQHSURBVGhD7ZnLahRBFIZ1oyK4EFduFMUHcOHCB1Bw6QPoIwgufAOXbtzqJpJ4QTQLFRcqKCQbLwsRRAheMCIGEQUvCUqiv/MxfZhiqOmpqq6epJv+4UBSXafO/09Xnao6vUktRieuqejENRWduKaiE9dU1CZuZU269UE6/VQ69kA6MCvtuiZtme4bf9PGM/rQF5+cyCru2x9p6rV0/KG0faY3+FSc4YMvYzBWVWQRt9z7xc++kHZcHhDdfEk6fLfffuWd9GhJWvgu/VjtG3/TxjP60Bcf82cs2hk7FZXErf2TLixIu68PSB25129bWik6RQAffBnDxmNs2ogVi2RxH5elQ3cGJPjl5z4XDzOAsRjTxicWMWOQJO7xl8Hb2n9Tml0sHtQAxt7Xi0EsYhI7FNHiZt5K24pkwfTJsfDHgRg2VYkNhxBEiWNQAmCnnqStg1QQi5gWP0RgsDimg72x86+KxnUAseEAl3FTNEgcC9nWGL/eesPeIJzKksxYcUwHy4rM+0lOxVGAg61BuI3iNFYcewyDkBUnkTxCARc4wQ2OPpSK43Rg0zEm3R/t/arPvxb/1Ag4wQ2OvpNMqTiOPzizmcYAH45SJ+elxV9FY02wjR6uwxgpjtduZ8X5yJMHPmZbezeAM8/qm9JwIw5ch2OMFMfJHCcWbixccWY7r0rnXkq//xadMsKSC5xdjBTH1QOHiyMWaxlcUcO290Z/A86ZdC3pwdmFVxyXRu5WrJuU0/2wIJ8dvC3d/1Q4VAQc4Qpn98LrFcetGAKxicQwLKTMcmVWSyxwN3jFce2noy8DhcAlH2KWWd9XyKyW2eFu8IqjrkFHbskpcInHWJXMClfGgLvBK47CDR0pA6TAJZxiKZkVrvjC3eAVR2WKjtQ5UuASrWJk1uk3YZkVrvjA3eAVR+mNjj9Xi4ZIuARzWEhmhSt94W4oFUeVKgUusRwWIg6u9B0rbqNMyz11TMtWJ5RWbwXrsYmfmJvQJt7q41erD87Arjyj6hNlGBbiWszGHIqoKw9o9WXVLTPEfuBwRdVdZoAbcaLKDMAyUGxiwSfHNSYElkh8mb1UXKtLe2AjF2Xt01ZSURa0upwOWvshxNDaT1iG1n58NDCovUHm/SSSDDFsjRE7RBiIFgeYDrYGW/XB38BCtiyKsZnGfjApA2PZBo0Rqyx5+JAsDrAO2GPsLWJMH74vpNwm8MHXpiDG2MRIWd+VxBk4HXD8sbMoxvGLX552bsmUAahzUKXC+Js2ntGHvviYP2PR7jt5hCKLOAMLn5M5Vw/uVkY01PDBlzFyJKqs4lxwaeRWzLWfugaFGypTlN4w/qaNZ/Shr3vRzIHaxG0EdOKaik5cU9GJayo6cc2E9B9NjowYLE1gswAAAABJRU5ErkJggg==
)
txtit(Var)
return

::gongyueshu::
Var =
(
// 求最大公约数
const greatestCommonDivisor = function(m, n) {
	var u = +m,
	    v = +n,
	    t = v;

	while (v != 0) {
	    t = u `% v;
	    u = v;
	    v = t;
	}

	return u
}

const proportion = function (m, n) {
	const v = greatestCommonDivisor(m, n)
	return ``${m/v}:${n/v}``
}

/*
proportion(1920, 1080)
"16:9"

proportion(17280, 4320)
"4:1" 

proportion(12288, 3456)
"32:9"
*/
)
code(Var)
return

::webpack::
::webpack.config::
::webpack.config.js::
::webpack.cfg::
Var =
(
// webpack.config.js
const webpack = require('webpack')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')

const ENV = process.env.ENV
const isProd = ENV === 'production'

module.exports = {
    // 如果启动了mode，webpack 顺便会帮你设置好了 process.env.NODE_ENV 
    // 开发模式不压缩打包后代码，生产模式压缩打包后代码
    mode: ENV,

    /**
     * 🚀 启动source-map
     * - source-map：产生文件，产生行列
     * - eval-source-map：不产生文件，产生行类
     * - cheap-source-map：产生文件，不产生列
     * - cheap-module-eval-source-map：不产生文件，不产生列
     */
    devtool: isProd ? 'cheap-module-eval-source-map' : 'source-map',

    /**
     * 🚀 entry 有几种形式：『1. 字符串类型入口』、 『2. 数组类型入口』、 『3. 对象类型入口』、 『4. 数组对象类型入口』、 『5. (异步)函数类型入口』：
     * 1. entry: './src/app.js',
     * 2. entry: [ 'babel-polyfill', './src/index.js' ],
     * 3. entry: { index: './src/index.js', lib: './src/lib.js' },
     * 4. entry: { index: ['babel-polyfill', './src/index.js'], lib: './src/lib.js' },
     * 5. entry: () => new Promise(resolve => setTimeout(() => resolve('./src/index.js'), 1000)),
     *
     * 🚀 如果使用 『1. 字符串类型入口』 和 『2. 数组类型入口』，默认编译出来的文件名为：main.js 
     * 这一点无论你 output.filename 是否采用 [name].js 都是一样的。
     *
     * 🚀 提取 vendor（供应商）: 在 webpack 中一般指工程所使用的库、框架等第三方模块集中打包产生的 bundled
     * 将不会经常变动的文件抽取出来生成一个新的 bundled，有效利用客户端的缓存，在用户后续请求页面时会加快整体的渲染速度。
     * entry: { app: './src/app.js', vendor: ['react', 'react-dom', 'react-router'] }
     */
    entry: { 
        app: ['babel-polyfill', './src/app.js'],
    },

    /**
     * output.path 默认是 ./dist，所以通常我们不配置。
     * output.path 指定资源的输出目录，必须是绝对位置： path: path.join(__dirname, 'dist'),
     * output.filename 可以是相对路径譬如： './js/bundle.js' => ./dist/js/bundle.js
     * output.filename 可以加入指纹来防止浏览器缓存： '[name]@[chunkhash].js'
     *
     * 🚀 publicPath 是一个极其特别重要的配置项，容易和path混淆。 从功能上说： path 是指定资源输出路径，publicPath 是资源请求路径。
     * 假设当前地址是： http://www.google.com/fuck/index.html
     * - publicPath: ''           // => http://www.baidu.com/fuck/bundle.js
     * - publicPath: '/'          // => http://www.baidu.com/bundle.js
     * - publicPath: '/dist/'     // => http://www.baidu.com/dist/bundle.js
     * - publicPath: './js'       // => http://www.baidu.com/fuck/js/bundle.js
     * - publicPath: '../assets'  // => http://www.baidu.com/assets/bundle.js
     */
    output: {
        // filename: isProd ? '[name]@[chunkhash].js' : '[name].js',
        filename: '[name].js',
    },

    module: {
        rules: [{
            // npm install babel-loader @babel/core @babel/preset-env
            test: /\.js$/,
            exclude: /node_modules/,
            use: {
                loader: 'babel-loader',
                options: {
                    cacheDirectory: true,
                    'presets': ['@babel/preset-env']
                },
            },
        }, {
            // npm install ts-loader typescript --save-dev
            test: /\.ts$/,
            use: 'ts-loader',
        }, {
            // npm install url-loader --save-dev
            test: /\.(png|jpg|gif|jpeg|svg)$/,
            use: {
                loader: 'url-loader',
                options: {
                    limit: 10240,
                    name: '[name].[ext]',
                    publicPath: './assets/',
                }
            },
        }, {
            // npm install css-loader mini-css-extract-plugin --save-dev
            // npm config set sass_binary_site-https//npm.taobao.org/mirrors/node-sass
            // npm install sass-loader node-sass
            // 通过配合 html-webpack-plugin 插件的使用，生成的html就会自动引入css文件
            test: /\.(css|scss)$/,
            use: [ 
                isProd ? MiniCssExtractPlugin.loader : 'style-loader', 
                { loader: 'css-loader',  options: { sourceMap: true } },
                'postcss-loader',
                { loader: 'sass-loader', options: { sourceMap: true } },
            ],
        }],
    },

    plugins: [
        // 抽离css
        new MiniCssExtractPlugin({
            filename: '[name].css',
            chunkFilename: '[id].css',
        }),

        // 动态 html
        new HtmlWebpackPlugin({
            template: './src/index.html'
        }),

        // 定义环境变量
        new webpack.DefinePlugin({
            // ⚠️ 这里必须使用 JSON.stringify 输出
            // 在 app.js 中就可以使用了： console.log(20191229005300, ENV)
            // 也可以设置其他类型： JSON.stringify({ TYPE: ['foo', 'bar'] })
            ENV: JSON.stringify('test'),
        })
    ],

    devServer: {
        /**
         * devServer.publicPath 和 output.publicPath 不一样。
         * 前者指的是资源访问目录，譬如 /dist => http://localhost:8099/dist
         * 通常这个目录要和 output.path 目录保持一致。
         */
        publicPath: '/dist',
    },

    // 是否开启监听文件： webpack --watch
    watch: true,  
    // 监听配置
    watchOptions: {
        // 每秒询问多少次
        poll: 1000,
        // 防抖
        aggregateTimeout: 500,  
        // 忽略
        ignored: /node_modules/ 
    },
}
---
// tsconfig.json
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "es5",
    "sourceMap": true,

    "moduleResolution": "node",
    "esModuleInterop": true,
    "allowJs": true,
    "allowUnreachableCode": true,
    "allowUnusedLabels": true,
    "noStrictGenericChecks": true,
    "skipLibCheck": true
  }
}
---
// postcss.config.js
const autoprefixer = require('autoprefixer')

module.exports = {
    plugins: [
        autoprefixer({
            grid: true,
            browsers: [
                'last 99 versions',
            ],
        })
    ]
}
---

# 安装依赖

npm install webpack webpack-cli --save-dev
npm install cross-env --save-dev
npm install babel-polyfill --save-dev
npm install babel-loader @babel/core @babel/preset-env --save-dev
npm install webpack-dev-server --save-dev
npm install ts-loader typescript --save-dev
npm install url-loader --save-dev
npm install css-loader style-loader mini-css-extract-plugin --save-dev
cnpm install sass-loader node-sass --save-dev
cnpm install postcss-loader autoprefixer --save-dev

# package.json

"scripts": {
  "dev": "cross-env ENV=development webpack-dev-server",
  "build": "rm -rf dist && cross-env ENV=production webpack",
  "watch": "rm -rf dist && cross-env ENV=production webpack --watch"
},
)
txtit(Var)
return

::fetchnews::
::fetch_news::
::news::
::newsapi::
Var =
(
;(async function(){
    // 请求发起
    const res = await fetch('https://newsapi.org/v2/top-headlines?country=ch&apiKey=68f714e4d92748fc9c33258bf758e88b')
    // 解析json
    const json = await res.json()
    // 打印结果
    console.log(json)
    // 获取新闻列表： {"source": {"id": null, "name": "Www.srf.ch"}, "author": null, "title": '', "description": '', "url": '', "urlToImage": '', "publishedAt": '', "content": ''}
    const articles = json.articles
}())
)
code(Var)
return

::404::
Var =
(
<svg width="478" height="262" viewBox="0 0 478 262" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M296 241.412c27.583 1.286 56.126 3.405 85 6.178v4.018c-28.877-2.778-57.423-4.902-85-6.192v-4.004zm-114 0v4.004c-33.506 1.568-68.442 4.365-103.666 8.073a2028.323 2028.323 0 0 0-54.93 6.525c-5.85.778-11.063 1.5-15.57 2.15a885.689 885.689 0 0 0-5.176.76c-1.447.22-2.468-.53-2.635-1.621a2 2 0 0 1 1.674-2.28 889.659 889.659 0 0 1 5.567-.82c4.521-.65 9.747-1.374 15.613-2.154a2035.73 2035.73 0 0 1 55.039-6.538c35.362-3.722 70.437-6.53 104.084-8.1zm219 8.196a2033.711 2033.711 0 0 1 54.123 6.44c5.866.781 11.092 1.506 15.613 2.156a889.651 889.651 0 0 1 5.203.764c1.456.222 2.205 1.243 2.038 2.335a2 2 0 0 1-2.28 1.674c-.65-.099-1.003-.151-1.411-.212a885.707 885.707 0 0 0-4.12-.602c-4.507-.648-9.72-1.37-15.57-2.15A2028.787 2028.787 0 0 0 401 253.63v-4.022z" fill="#EEE" fill-rule="nonzero"/><path d="M182 230h-1c-5.523 0-10-4.479-10-10.002v-6a5.998 5.998 0 0 1 5.997-5.998h124.006a5.998 5.998 0 0 1 5.997 5.997v6c0 5.525-4.486 10.003-10 10.003h-1v19.01a9.988 9.988 0 0 1-9.992 9.99h-94.016c-5.518 0-9.992-4.472-9.992-9.99V230zm4 0v19.01a5.99 5.99 0 0 0 5.992 5.99h94.016a5.988 5.988 0 0 0 5.992-5.99V230H186zm79 7h16a2 2 0 0 1 0 4h-16a2 2 0 1 1 0-4zm0 8h16a2 2 0 0 1 0 4h-16a2 2 0 1 1 0-4zm-90-31.003v6a6.002 6.002 0 0 0 6 6.003h116c3.308 0 6-2.69 6-6.002v-6a1.998 1.998 0 0 0-1.997-1.998H176.997a1.998 1.998 0 0 0-1.997 1.997z" fill="#EEE" fill-rule="nonzero"/><path d="M197 223a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm28 0a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm28 0a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm28 0a4 4 0 1 1 0-8 4 4 0 0 1 0 8z" fill="#C3B8E3"/><path d="M296 67h1c5.523 0 10 4.479 10 10.002v6A5.998 5.998 0 0 1 301.003 89H176.997A5.998 5.998 0 0 1 171 83.003v-6C171 71.477 175.486 67 181 67h1V55c0-11.046 8.954-20 20-20h17.014a8.498 8.498 0 0 1 8.493-8h22.986c4.53 0 8.233 3.547 8.492 8H276c11.046 0 20 8.954 20 20v12zm-4 0V55c0-8.837-7.163-16-16-16h-74c-8.837 0-16 7.163-16 16v12h106zm-37.028-32a4.512 4.512 0 0 0-4.48-4h-22.985a4.498 4.498 0 0 0-4.48 4h31.945zM175 77.002v6c0 1.103.895 1.998 1.997 1.998h124.006A1.998 1.998 0 0 0 303 83.003v-6A6.002 6.002 0 0 0 297 71H181c-3.308 0-6 2.69-6 6.002z" fill="#EEE" fill-rule="nonzero"/><g transform="translate(227 1)"><rect fill="#FEE1D3" x="6" y="18" width="12" height="4" rx="2"/><rect fill="#FDC4A8" x="3" y="9" width="18" height="4" rx="2"/><rect fill="#FDC4A8" width="24" height="4" rx="2"/></g><path d="M197 82a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm28 0a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm28 0a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm28 0a4 4 0 1 1 0-8 4 4 0 0 1 0 8z" fill="#C3B8E3"/><g fill="#FC6D26"><path opacity=".15" d="M179 89h8v119h-8z"/><path opacity=".1" d="M195 89h8v119h-8z"/><path opacity=".05" d="M211 89h8v119h-8zm16 0h8v119h-8zm16 0h8v119h-8zm16 0h8v119h-8z"/><path opacity=".1" d="M275 89h8v119h-8z"/><path opacity=".15" d="M291 89h8v119h-8z"/></g><path d="M213.508 149.148h3.844v11.93h-3.844v7.547h-12.633v-7.547H187v-10.58l14.623-22.865h11.885v21.515zm10.883-.984c0-6.582 1.073-11.655 3.35-15.238 2.486-3.91 6.34-5.926 11.204-5.926 4.876 0 8.739 2.01 11.226 5.911 2.28 3.577 3.352 8.655 3.352 15.253 0 6.583-1.073 11.653-3.352 15.23-2.487 3.901-6.35 5.91-11.226 5.91-4.863 0-8.718-2.015-11.203-5.925-2.278-3.583-3.351-8.649-3.351-15.215zm62.914.984h3.843v11.93h-3.843v7.547h-12.633v-7.547h-13.875v-10.58l14.623-22.865h11.885v21.515z" fill="#FFF" fill-rule="nonzero"/><path d="M199.194 137H203v-1h-3.167l.64-1H206v-1h-4.888l2.154-3.367h7.242V139H206v1h4.508v12.148h3.844v5.93h-3.844v7.547h-6.633v-7.547H190V157h4v-1h-4v-1h6v-1h-6v-2.625L199.194 137zm4.681 1.32l-8.836 13.828h8.836V138.32zM227.467 151a50.424 50.424 0 0 1-.076-2.836c0-3.125.255-5.846.766-8.164H232v-1h-3.6c.188-.709.404-1.375.646-2H233v-1h-3.527c.245-.523.512-1.01.8-1.465 1.922-3.023 4.813-4.535 8.672-4.535 3.156 0 5.664 1 7.524 3H240v1h7.286c.122.17.24.344.355.523 1.922 3.016 2.882 7.563 2.882 13.641 0 .986-.025 1.931-.076 2.836h-6.946c.041-.88.061-1.826.061-2.836 0-1.625-.054-3.078-.164-4.36L238.882 151h-3.937l7.563-12.07-.047-.14c-.734-1.954-1.906-2.93-3.516-2.93-1.593 0-2.757.976-3.492 2.93-.734 1.952-1.101 5.077-1.101 9.374 0 1.014.018 1.959.054 2.836h-6.939zm.068 1h10.72l-3.036 4.836c.078.25.156.476.234.68.735 1.953 1.899 2.93 3.492 2.93 1.61 0 2.782-.977 3.516-2.93.494-1.313.821-3.152.983-5.516h6.935c-.027.34-.057.673-.092 1H245v1h5.166c-.046.34-.097.674-.152 1H244v1h5.827c-.48 2.32-1.21 4.248-2.186 5.781-1.922 3.016-4.82 4.524-8.696 4.524-3.294 0-5.883-1.102-7.765-3.305H237v-1h-6.576a11.633 11.633 0 0 1-.601-1H234v-1h-4.667c-.941-2.128-1.54-4.795-1.798-8zm56.77-6v6.148h3.843V154H281v1h7.148v3.078h-3.843V159H281v1h3.305v2H278v1h6.305v2.625h-6.633v-7.547h-13.875v-6.703l3.437-5.375h5.53l-3.928 6.148h8.836V146h6.633zm0-1h-6.633v-6.68l-4.268 6.68h-5.53l5.116-8H279v-1h-5.37l1.279-2h9.396v8H279v1h5.305v2zm0-12h-8.756l1.514-2.367h7.242V133z" fill="#333"/><path d="M428 194v-3.993a4.002 4.002 0 0 0-3.993-4.007h-66.014a3.999 3.999 0 0 0-3.993 4.007V200h8a2 2 0 1 1 0 4h-8v5h13a2 2 0 1 1 0 4h-13v8.993a4.002 4.002 0 0 0 3.993 4.007h66.014a3.999 3.999 0 0 0 3.993-4h-13a2 2 0 1 1 0-4h13v-10h-6a2 2 0 1 1 0-4h6v-6h-6a2 2 0 1 1 0-4h6zm-47 36h-23.007c-4.414 0-7.993-3.588-7.993-8.007v-31.986c0-4.422 3.576-8.007 7.993-8.007h66.014c4.414 0 7.993 3.588 7.993 8.007v31.986c0 4.422-3.576 8.007-7.993 8.007H401v25.01a5.989 5.989 0 0 1-6 5.99h-8c-3.313 0-6-2.689-6-5.99V230zm4 0v25.01a2 2 0 0 0 2 1.99h8c1.111 0 2-.888 2-1.99V230h-12zm6 24a3 3 0 1 1 0-6 3 3 0 0 1 0 6z" fill="#EEE" fill-rule="nonzero"/><g transform="translate(375 192)"><path d="M4.724 6.473l2.331 1.888c.43.348.499.973.148 1.406l-.63.779a.997.997 0 0 1-1.406.147L2.836 8.805l-.64.79a.999.999 0 0 1-1.408.15.994.994 0 0 1-.146-1.41l3.143-3.88a.999.999 0 0 1 1.408-.15c.43.347.502.969.146 1.408l-.615.76zm23.44 2.332l-2.331 1.888a.996.996 0 0 1-1.406-.147l-.63-.78a.997.997 0 0 1 .148-1.405l2.331-1.888-.615-.76a.999.999 0 0 1 .146-1.409.994.994 0 0 1 1.408.15l3.143 3.881a.999.999 0 0 1-.146 1.41.994.994 0 0 1-1.408-.15l-.64-.79zM17 2v3c0 .552-.443 1-.999 1h-1.002A.997.997 0 0 1 14 5V2h-.997A.999.999 0 0 1 12 1c0-.552.438-1 1.003-1h4.994A.999.999 0 0 1 19 1c0 .552-.438 1-1.003 1H17z" fill="#C3B8E3"/><path d="M15.593 29c-14.5 0-12.5-5.596-12.5-12.5S8.69 4 15.593 4c6.904 0 12.5 5.596 12.5 12.5s2 12.5-12.5 12.5zm0-4c2.814 0 4.908-.226 6.354-.636 1.003-.284 1.525-.592 1.774-.89.407-.485.527-1.44.421-4.655a64.986 64.986 0 0 1-.049-2.319 8.5 8.5 0 1 0-17 0c0 .683-.013 1.24-.048 2.32-.106 3.215.014 4.169.42 4.655.25.297.772.605 1.775.89 1.446.409 3.54.635 6.353.635zm-.093-1.5a7 7 0 1 1 0-14 7 7 0 0 1 0 14zm0-3a4 4 0 1 0 0-8 4 4 0 0 0 0 8z" fill="#E1DBF1" fill-rule="nonzero"/><circle fill="#6B4FBB" cx="14.5" cy="15.5" r="2.5"/></g><path d="M46.994 106zM44 103h-1.004A2.996 2.996 0 0 1 40 99.998v-1.996A3.005 3.005 0 0 1 42.996 95h22.008A2.996 2.996 0 0 1 68 98.002v1.996A3.005 3.005 0 0 1 65.004 103H64v2.997A3 3 0 0 1 61.006 109H46.994A2.997 2.997 0 0 1 44 105.997V103zm3 0v2.997l14.006.003c-.003 0-.005-1-.006-3H47zm18.004-3c-.006 0-.007-.666-.004-1.998L42.996 98c.006 0 .007.666.004 1.998l22.004.002zm-18.01-39zM44 64h-1.004A2.996 2.996 0 0 0 40 67.002v1.996A3.005 3.005 0 0 0 42.996 72h22.008A2.996 2.996 0 0 0 68 68.998v-1.996A3.005 3.005 0 0 0 65.004 64H64v-2.997A3 3 0 0 0 61.006 58H46.994A2.997 2.997 0 0 0 44 61.003V64zm3 0v-2.997L61.006 61c-.003 0-.005 1-.006 3H47zm18.004 3c-.006 0-.007.666-.004 1.998L42.996 69c.006 0 .007-.666.004-1.998L65.004 67z" fill="#EEE" fill-rule="nonzero"/><path d="M51 55a1 1 0 0 1 .99-1h4.02c.546 0 .99.444.99 1a1 1 0 0 1-.99 1h-4.02a.993.993 0 0 1-.99-1zm-1-4c0-.552.453-1 .997-1h6.006c.55 0 .997.444.997 1 0 .552-.453 1-.997 1h-6.006A.996.996 0 0 1 50 51z" fill="#EFEDF8"/><path d="M43 72h2v23h-2V72zm8 0h2v23h-2V72zm8 0h2v23h-2V72z" fill="#E1DBF1"/><path d="M47 72h2v23h-2V72zm8 0h2v23h-2V72zm8 0h2v23h-2V72z" fill="#EFEDF8"/><path d="M83.039 123.718A15.433 15.433 0 0 1 73.5 127c-2.243 0-4.375-.476-6.3-1.334A15.464 15.464 0 0 1 55.5 131c-8.56 0-15.5-6.94-15.5-15.5 0-1.34.17-2.64.49-3.879C27.301 116.964 18 129.896 18 145c0 19.882 16.118 36 36 36 1.9 0 3.765-.147 5.586-.43A18.027 18.027 0 0 1 59 176c0-6.11 3.072-11.685 8.023-14.984A22.34 22.34 0 0 1 67 160c0-12.15 9.85-22 22-22 .107 0 .214 0 .32.002a35.824 35.824 0 0 0-6.281-14.284zM93.568 139.1c.188.282.307.615.331.973a42.586 42.586 0 0 1 .089 3.938c.008.33.012.66.012.99 0 22.091-17.909 40-40 40s-40-17.909-40-40 17.909-40 40-40c20.087 0 36.715 14.806 39.568 34.099zM89 142c-9.941 0-18 8.059-18 18 0 .63.032 1.255.096 1.874a2 2 0 0 1-1.001 1.944A13.992 13.992 0 0 0 63 176c0 1.113.13 2.207.383 3.267C79.039 174.365 90 159.774 90 143c0-.325-.004-.65-.012-.973A18.323 18.323 0 0 0 89 142zm-46.5 5a6.5 6.5 0 1 1-.25 12.995 8 8 0 1 1-2.82-12.225 6.471 6.471 0 0 1 3.07-.77zm-1.179 4.294a4 4 0 0 1-3.609.089 4 4 0 1 0 1.414 6.113 4 4 0 0 1 3.275-1.498l.099.002a2.5 2.5 0 1 0-1.179-4.706zm4.055-41.255A11.436 11.436 0 0 0 44 115.5c0 6.351 5.149 11.5 11.5 11.5a11.46 11.46 0 0 0 8.682-3.958 4 4 0 0 1 4.646-1.03c1.456.649 3.036.988 4.672.988a11.46 11.46 0 0 0 6.998-2.372A35.903 35.903 0 0 0 54 109c-2.939 0-5.828.351-8.624 1.039z" fill="#EEE" fill-rule="nonzero"/></g></svg>
)
code(Var)
return

::data::
Var =
(
data () {
  return {
      items: [],
      title: 'HelloWorld'
  }
},
)
code(Var)
return

::zhengze::
::zz::
Var =
(
/* 手机机身码(IMEI) */
/^\d{15,17}$/

/* 中国手机号(严谨), 根据工信部2019年最新公布的手机号段 */
/^(?:(?:\+|00)86)?1(?:(?:3[\d])|(?:4[5-7|9])|(?:5[0-3|5-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\d])|(?:9[1|8|9]))\d{8}$/

/* 中国手机号(宽松), 只要是13,14,15,16,17,18,19开头即可 */
/^(?:(?:\+|00)86)?1[3-9]\d{9}$/

/* 中国手机号(最宽松), 只要是1开头即可, 如果你的手机号是用来接收短信, 优先建议选择这一条 */
/^(?:(?:\+|00)86)?1\d{10}$/

/* 国内座机电话,如: 0341-86091234 */
/\d{3}-\d{8}|\d{4}-\d{7}/

/* 电话(座机) */
/^0\d{2,3}-\d{7,8}$/

/* 必须带端口号的网址(或ip) */
/^(((ht|f)tps?):\/\/)?[\w\-]+(\.[\w\-]+)+:\d{0,5}\/?/

/* 网址(支持端口和"?+参数"和"#+参数) */
/^(((ht|f)tps?):\/\/)?[\w\-]+(\.[\w\-]+)+([\w\-.,@?^=`%&:\/~+#]*[\w\-@?^=`%&\/~+#])?$/

/* 子网掩码 */
/^(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])(?:\.(?:\d{1,2}|1\d\d|2[0-4]\d|25[0-5])){3}$/

/* linux"文件夹"路径 */
/^\/(\w+\/?)+$/

/* linux"文件"路径 */
/^\/(\w+\/)+\w+\.\w+$/

/* window下"文件夹"路径 */
/^[a-zA-Z]:\\(?:\w+\\?)*$/

/* window下"文件"路径 */
/^[a-zA-Z]:\\(?:\w+\\)*\w+\.\w+$/

/* html注释 */
/^<!--[\s\S]*?-->$/

/* 是否html标签(宽松匹配) */
/<(.*)>.*<\/\1>|<(.*) \/>/

/* 视频链接地址（视频格式可按需增删） */
/^https?:\/\/(.+\/)+.+(\.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4))$/i

/* 图片链接地址（图片格式可按需增删） */
/^https?:\/\/(.+\/)+.+(\.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif))$/i

/* base64格式 */
/^\s*data:(?:[a-z]+\/[a-z0-9-+.]+(?:;[a-z-]+=[a-z0-9-]+)?)?(?:;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?`%\s]*?)\s*$/i

/* 16进制颜色 */
/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/
---
/* ip-v4 */
/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/

/* ip-v6 */
/^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i

/* 数字/货币金额（支持负数、千分位分隔符） */
/(?:^[-]?[1-9]\d{0,2}(?:$|(?:,\d{3})*(?:$|(\.\d{1,2}$))))|(?:(?:^[0](\.\d{1,2})?)|(?:^[-][0]\.\d{1,2}))$/

/* 数字/货币金额 (只支持正数、不支持校验千分位分隔符) */
/(?:^[1-9]([0-9]+)?(?:\.[0-9]{1,2})?$)|(?:^(?:0){1}$)|(?:^[0-9]\.[0-9](?:[0-9])?$)/

/* 银行卡号（10到30位, 覆盖对公/私账户, 参考微信支付） */
/^[1-9]\d{9,29}$/

/* 新能源车牌号 */
/[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领 A-Z]{1}[A-HJ-NP-Z]{1}(([0-9]{5}[DF])|([DF][A-HJ-NP-Z0-9][0-9]{4}))$/

/* 非新能源车牌号 */
/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领 A-Z]{1}[A-HJ-NP-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/

/* 车牌号(新能源+非新能源) */
/^(?:[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领 A-Z]{1}[A-HJ-NP-Z]{1}(?:(?:[0-9]{5}[DF])|(?:[DF](?:[A-HJ-NP-Z0-9])[0-9]{4})))|(?:[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领 A-Z]{1}[A-Z]{1}[A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9 挂学警港澳]{1})$/

/* 24小时制时间（HH:mm:ss） */
/^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$/

/* 12小时制时间（hh:mm:ss） */
/^(?:1[0-2]|0?[1-9]):[0-5]\d:[0-5]\d$/

/* 日期 */
/^\d{4}(-)(1[0-2]|0?\d)\1([0-2]\d|\d|30|31)$/

/* 一代身份证号(15位数字) */
/^\d{8}(0\d|10|11|12)([0-2]\d|30|31)\d{3}$/

/* 二代身份证号(18位数字),最后一位是校验位,可能为数字或字符X */
/^\d{6}(18|19|20)\d{2}(0\d|10|11|12)([0-2]\d|30|31)\d{3}[\dXx]$/

/* 身份证号, 支持1/2代(15位/18位数字) */
/(^\d{8}(0\d|10|11|12)([0-2]\d|30|31)\d{3}$)|(^\d{6}(18|19|20)\d{2}(0\d|10|11|12)([0-2]\d|30|31)\d{3}(\d|X|x)$)/

/* 护照（包含香港、澳门） */
/(^[EeKkGgDdSsPpHh]\d{8}$)|(^(([Ee][a-fA-F])|([DdSsPp][Ee])|([Kk][Jj])|([Mm][Aa])|(1[45]))\d{7}$)/

/* 统一社会信用代码 */
/^[0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/

/* 中国邮政编码 */
/^(0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\d{4}$/
---
/* 只包含中文和数字 */
/^((?:[\u3400-\u4DB5\u4E00-\u9FEA\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA1F\uFA21\uFA23\uFA24\uFA27-\uFA29]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0])|(\d))+$/

/* 不能包含字母 */
/^[^A-Za-z]*$/

/* 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线组合 */
/^[a-zA-Z][a-zA-Z0-9_]{4,15}$/

/* 纯中文/汉字 */
/^(?:[\u3400-\u4DB5\u4E00-\u9FEA\uFA0E\uFA0F\uFA11\uFA13\uFA14\uFA1F\uFA21\uFA23\uFA24\uFA27-\uFA29]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0])+$/

/* 中文姓名 */
/^(?:[\u4e00-\u9fa5·]{2,16})$/

/* 英文姓名 */
/(^[a-zA-Z]{1}[a-zA-Z\s]{0,20}[a-zA-Z]{1}$)/

/* 是否小数 */
/^\d+\.\d+$/

/* 纯数字 */
/^\d{1,}$/

/* 是否由数字和字母组成 */
/^[A-Za-z0-9]+$/

/* 纯英文字母 */
/^[a-zA-Z]+$/

/* 纯小写英文字母组成 */
/^[a-z]+$/

/* 纯大写英文字母 */
/^[A-Z]+$/

/* 密码强度校验，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符 */
/^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$`%^&*? ]).*$/

/* 用户名校验，4到16位（字母，数字，下划线，减号） */
/^[a-zA-Z0-9_-]{4,16}$/

/* 微信号，6至20位，以字母开头，字母，数字，减号，下划线 */
/^[a-zA-Z][-_a-zA-Z0-9]{5,19}$/

/* 是否qq号格式正确 */
/^[1-9][0-9]{4,10}$/

/* 邮箱地址(email) */
/^[a-zA-Z0-9.!#$`%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/

)
txtit(Var)
return

::pianyingyong::
::_bind::
::partial::
Var =
(
/**
 * partial 偏应用（_bind）
 * ctx： 上下文
 * argv: 占位符参数，如果不想展位则写为 undefined
 *
 * demo 示例
 * 
   // 期待有两个参数注入
   var a = function (a, b) { console.log(a, b, this) }

   // 我先注入第二个参数
   var aa = a.partial({ 'fuck': 123 }, undefined, 'god')

   // 被第三方执行，注入了第一个参数
   aa('shit') // => shit god
 */
Function.prototype.partial = function (ctx, ...argv) {
    // 保存当前函数的指针
    const fn = this

    // fixbug：震惊！argv也是一个引用类型，所以先复制一份出来。
    const _argv = argv.slice(0)

    // 返回一个新函数
    return function (...args) {
        // 遍历占位符参数
        for (let [index, value] of _argv.entries()) {
            // 如果占位符为 undefined，说明需要补位的
            if (value === undefined) {
               argv[index] =  args[index]
            }
        }
        
        // 调用函数
        return fn.apply(ctx, argv)
    }
}
---
/**
 * 自定义 partial 偏应用（_bind）
 * demo 示例
 * 
   // 期待有两个参数注入
   var a = function (a, b) { console.log(a, b, this) }
   // 我先注入第二个参数
   var aa = a.partial(undefined, 'god')
   // 被第三方执行，注入了第一个参数
   aa('shit') // => shit god
 */
export const partial = (fn, ...argv) => {
  // fixbug：震惊！argv也是一个引用类型，所以先复制一份出来。
  const _argv = argv.slice(0)

  // 返回已占位的函数（为了更方便的结合bind使用，本函数使用 function而不适用箭头函数）
  return function (...args) {
       // 遍历占位符参数
       for (let [index, value] of _argv.entries()) {
           // 如果占位符为 undefined，说明需要补位的
           if (value === undefined) {
              argv[index] =  args[index]
           }
       }
       // 调用函数
       return fn.apply(this, argv)
   }
}
)
txtit(Var)
return

::objs::
::objk::
Var =
(
Object.keys()
)
code(Var)
return


::df::
Var =
(
var ul = document.getElementById("ul");

var fragment = document.createDocumentFragment();

for (var i = 0; i < 20; i++) {
    var li = document.createElement("li");
    li.innerHTML = "index: " + i;
    fragment.appendChild(li);
}

ul.appendChild(fragment);
)
code(Var)
return

::logs::
Var =
(
// 折叠日志
const logs = (info = '', ...args) => {
    console.groupCollapsed(info)
    args.forEach(_ => console.log(_))
    console.groupEnd()
}
)
code(Var)
return



::fetchdg::
Var =
(
;(async function(){
  const json = await fetch('https://geo.datav.aliyun.com/areas/bound/441900.json').then(response => response.json())   
  console.log(20200116224515, json)

  const json = await fetch('https://raw.githubusercontent.com/dragon8github/Pandora/master/assets/DongGuanGrid.geo.json').then(response => response.json())
  console.log(20200116224515, json)
}())
)
code(Var)
return

:?:vue.event::
:?:vue.bus::
:?:vue.$bus::
::bus::
::$bus::
::event::
::event.bus::
::eventbus::
Var =
(
// 如何删除元素绑定的事件？
<script src='https://cdn.jsdelivr.net/gh/colxi/getEventListeners/src/getEventListeners.min.js'></script>
 el.getEventListeners()

---
const isPromise = val => val && typeof val.then === 'function'

Promise.allSettled = iterables => new Promise(resolve => {
    let result = []

    const callback = function(i, v) {
        // 模仿 Promise.all 对号入座原则
        result[i] = v

        // 是否全部执行完毕？
        if (result.length === iterables.length)
            // 收工咯~
            resolve(result)
    }

    iterables.forEach((p, i) => {
        // 注入索引
        const _callback = callback.bind(null, i)
        
        // 如果是 promise，才执行操作
        if (isPromise(p)) {
            // 注入灵魂
            p.then(_callback).catch(_callback)
        // 如果是其他，直接调用即可
        } else {
            _callback(p)
        }
    })
})

/**
 * say something ...
 *
 let e = new Event()

 e.on("hello", name => new Promise((resolve, reject) => setTimeout(_ => resolve('1' + name), 1000)))
 e.on("hello", name => new Promise((resolve, reject) => setTimeout(_ => resolve('2' + name), 2000)))

 ;(async function() {
     await e.emit('hello', { name: 'Lee' })
     console.log('work finish')
 }())
 ----------------------------------------------------------------
 import Event from './utils/Event'
 Vue.prototype.$bus = new Event()
 this.$bus.on('onRefresh', this.getData)
 this.$bus.emit('onRefresh')
 */
export default class Event {
    constructor(props) {
        this.map = []
    }

    on(name, fn, id = Date.now()) {
        this.map.push({ name, fn, id })
        return id
    }

    emit(name, ...args) {
        // 获取任务
        const target = this.map.filter(_ => _.name === name)

        // 是否存在任务
        if (target) {
            // 对每个任务进行执行
            const pendding = target.map(_ => _.fn(...args))
            // 如果任务返回的是promise，也可以方便外部 await
            return Promise.allSettled(pendding)
        }
    }

    remove (id) {
        const index = this.map.findIndex(_ => _.id === id)
        this.map.splice(index, 1)
    }

    clear() {
        this.map = []
    }

    removeByName (name) {
        this.map = this.map.filter(_ => _.name != name)
    }
}
#################################
/**
 * import VueBus from './vue-bus'
 * Vue.use(VueBus)
 * 
 * this.$bus.emit('add', num)
 * this.$bus.on('add', num => console.log(num))
 */
const install = Vue => {
    const Bus = new Vue({
        methods: {
            emit(event, ...args) {
                this.$emit(event, ...args)
            },
            on(event, cllback) {
                this.$on(event, cllback)
            },
            off(event, callback) {
                this.$off(event, callback)
            }
        }
    });

    Vue.prototype.$bus = Bus
}

export default install;
#################################
const headerTag = document.getElementById('number');

headerTag.addEventListener('numberChanged', function(e) {
   headerTag.textContent = e.detail.number;
   headerTag.style.color = e.detail.textColor;
});

function changeNumber(n, c) {
   const event = new CustomEvent('numberChanged', {
      detail: {
         number: n,
         textColor: c
      }
   });
   headerTag.dispatchEvent(event);
}
)
txtit(Var, "#################################")
return

::on::
Var =
(
/**
 * - capture 几乎不用管，默认为 false，而且大部分场景也不会管它。
     capture 是冒泡的意思。默认冒泡是从里到外，符合自觉，如果设置为true，就是从外到里。 所以极少场景需要设置为 true。

 * - passive 才是优化重点，默认为 true，如果设置为 false 则能提高流畅度，代价是无法使用event.preventDefault()
     passive 意思是顺从的意思，即顺从浏览器安排，不反抗，不中断。让浏览器顺滑的执行。 通常移动端 touch 类事件需要设置为 false。


     on(el, 'touchstart', this.onTouchStart)
     on(el, 'touchmove', this.onTouchMove)
     on(el, 'touchend', this.onTouchEnd)
     on(el, 'touchcancel', this.onTouchEnd)
 */
const on = (target, event, handler, passive = false) => target.addEventListener(event, handler, { capture: false, passive })
)
code(Var)
return

::danlimoshi::
::danli::
::sing::
::singele::
::single::
Var =
(
class Singleton {
    static instance
    constructor() {
         if (Singleton.instance) {
             return Singleton.instance
         }
         Singleton.instance = this
    }
}
)
code(Var)
return

::like::
Var =
(
// 搜索符合全部条件
Array.prototype.like = function (...args) { 
    return this.filter(_ => args.every(fn => fn(_))) 
}

// 搜索符合部分条件
Array.prototype.likeSome = function (...args) { 
    return this.filter(_ => args.Some(fn => fn(_))) 
}

// 模糊查找字符串，无视大小写
Array.prototype.likeStr = function (...args) { 
    return this.filter(_ => args.every(str => _.toUpperCase().includes(str.toUpperCase()))) 
}

// 模糊查找字符串，含大小写
Array.prototype.likeStrCaseWrite = function (...args) { 
    return this.filter(_ => args.every(str => _.includes(str))) 
}


const T = () => true
['a', 'b', 'c'].like(T, T, T)

const ary = [
    'Lorem ipsum dolor sit amet, consectetur adipisicing elit', 
    'sed do eiusmod tempor incididunt ut labore et dolore magna aliqua',
    'Excepteur sint occaecat cupidatat non proident'
]

ary.like(_ => _.includes('or'), _ => _.includes('et'))
)
code(Var)
return

::visualMap::
::visual::
::colorRange::
Var =
(
/**
 * 获取数组最后一位
 */
Array.prototype.last = function() {
    return this[this.length - 1];
};

/**
 * 获取数组第一位
 */
Array.prototype.first = function() {
    return this[0];
};

const division = (ary, num, container = {}) => {
    for (let page = 0; page < Math.ceil(ary.length / num); page++) {
      container[page] = ary.slice(page * num, (page + 1) * num)
    }
    return container
}

const split = (ary, number = ary.length) => {
    // 如果数组只有一个或者没有，那么直接返回
    if (ary.length <= 1) {
        return ary
    }

    // 先进行 从小到大 排序
    const sort_ary = ary.sort((a, b) => { return a - b })

    // 将一个数组分成4段
    return division(sort_ary, number, [])
}

// 33个镇街的 demo 数据
const ary = [91.3, 59.2, 86.2, 75.9, 91.4, 83.2, 78.9, 91.0, 59.4, 94.7, 62.0, 91.8, 106.1, 49.8, 96.1, 82.2, 82.7, 25.9, 91.9, 103.1, 72.5, 82.9, 86.7, 93.1, 80.5, 63.9, 82.1, 90.3, 72.4, 80.2, 87.6, 101.3, 78] 

// 将分割为四组
const split_ary = split(ary, ary.length / 4)

// 取到每组的最小和最大（由于排序过，所以就是第一位和最后一位）
const limit = split_ary.map(_ => [_.first(), _.last()])

// 这个就是 visualMap 组件所需要的展示数据
const limit_str = limit.map(_ => _.join(' ~ '))

// 颜色映射表
const colors = ['rgba(64, 41, 113, 0.25)', 'rgba(199, 52, 97, 0.5)', 'rgba(199, 52, 97, 0.7)', 'rgba(199, 52, 97, 1)']

// 颜色映射表函数 - 接受一个数据，返回映射的颜色
const limitColor = number => {
    // 找到索引
    const index = limit.findIndex(([a, b]) => number > a && number < b)

    // 如果索引正常
    if (index > -1) {
        return colors[index]
    }

    // 默认返回第一个吧
    return colors[0]
}

console.log('逻辑区间', limit)
console.log('UI区间', limit_str)
console.log('获取当前数据的颜色', limitColor(88))
---
const colorRange = (colorList, min, max) => {
    // 初始化透明度 rgba
    // 虽然强制将 『透明度的单位』 和 『rgb颜色的255单位』 对齐很离谱
    // 但其实是可以的，因为原理都是通过两个数值『相减』 得出 『距离』，然后再根据距离进行演变。
    colorList = colorList.map(([r, g, b, a = 1]) => [r, g, b, a * 255])

    // 提前准备好还原 Opacity 的工具
    const restoreOpacity = ([r, g, b, a]) => [r, g, b, (a / 255).toFixed(2)]

    // 获取距离
    const distance = max - min

    // 获取 『每个颜色之间的距离』
    // 为什么要长度 -1 ？ 想想 『为什么说八岐大蛇是9个头？』 ,因为 『岐』 的意思是头与头之间的 『区间』
    // Orochi，即八岐大蛇（Yamata no Orochi）是日本神话中的著名怪物
    const Orochi = distance / (colorList.length - 1)

    // 初始化所有的 『数值区间』 和 『颜色区间』
    const { vSection, cSection } = colorList.reduce((p, c, i, a, next = a[i + 1]) => {
        // 没有下一个了，说明是最后一个了
        if (!next) return p

        // 颜色区间
        p.cSection.push([ c, next ])

        // 数值区间
        p.vSection.push([ min + Orochi * i, min + Orochi * (i + 1) ])

        return p
    }, { vSection: [], cSection: [] })


    // 获取颜色的单位距离
    const getUnitColor = ([r1, g1, b1, a1], [r2, g2, b2, a2], distance) => [
        Math.abs(r1 - r2) / distance,
        Math.abs(g1 - g2) / distance,
        Math.abs(b1 - b2) / distance,
        Math.abs(a1 - a2) / distance,
    ]

    return v => {
        // ...
        if (v <= min) return restoreOpacity(colorList[0])

        // ...
        if (v >= max) return restoreOpacity(colorList[colorList.length - 1])

        // 获取 v 命中哪个 『数值区间』
        const index = vSection.findIndex(([a, b]) => (v === a || v === b) || (v > a && v < b))

        // 获取当前数值区间
        const [leftV, rightV] = vSection[index]

        // 获取当前颜色区间
        const [leftC, rightC] = cSection[index]

        // 获取该区间距离
        const _distance = rightV - leftV

        // 返回单位颜色
        const unit_rgba = getUnitColor(leftC, rightC, _distance)

        // 获得当前值与左界的距离（有点 margin/padding 的味道，命名参考 css grid 的 grid-gap）
        const gap = v - leftV

        // 步进的颜色 = 单位颜色 * 左界距离
        const stepColor = unit_rgba.map(c => parseInt(c * gap))

        // 最终颜色 = 左界颜色 + 步进颜色
        const color = leftC.map((c, i) => c + stepColor[i])

        // 还原 Opacity
        return restoreOpacity(color)
    }
}

// 颜色列表
const colorList = [[0, 4, 156, 0.25], [23, 0, 241, 0.3], [0, 90, 255, 0.65], [0, 114, 255, 1]]

// 数据
const data = [{ name:'万江', count: 400 }, { name:'东坑', count: 300 }, { name:'东城', count: 890 }, { name:'中堂', count: 270 }, { name:'企石', count: 170 }, { name:'凤岗', count: 700 }, { name:'南城', count: 650 }, { name:'厚街', count: 950 }, { name:'塘厦', count: 810 }, { name:'大岭山', count: 425 }, { name:'大朗', count: 1200 }, { name:'寮步', count: 560 }, { name:'常平', count: 640 }, { name:'望牛墩', count: 200 }, { name:'松山湖', count: 220 }, { name:'桥头', count: 350 }, { name:'横沥', count: 380 }, { name:'沙田', count: 700 }, { name:'洪梅', count: 70 }, { name:'清溪', count: 450 }, { name:'石排', count: 400 }, { name:'石碣', count: 400 }, { name:'石龙', count: 170 }, { name:'茶山', count: 365 }, { name:'莞城', count: 330 }, { name:'虎门', count: 1300 }, { name:'谢岗', count: 170 }, { name:'道滘', count: 220 }, { name:'长安', count: 1345 }, { name:'高埗', count: 300 }, { name:'麻涌', count: 230 }, { name:'黄江', count: 330 }]

// ...
const _data =  data.map(_ => _.count)

// 最大值 / 最小值
const min = Math.min(..._data), max = Math.max(..._data)

// ...
const make = colorRange(colorList, min, max)

// ...
const finalData = data.map(item => Object.assign({}, item, { color: make(item.count) }))

// ...
console.log(finalData)
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://cdn.staticfile.org/vue/2.6.9/vue.js"></script>
</head>

<body>
    <div id="app">
        <ul><li v-for='(item, index) in colorList' :style='color(item)' :key='index'>{{ item }}</li></ul>

        <ul><li v-for='(item, index) in items' :style='color(item.color)' :key='index'>{{ item.color }} - {{ item.name }} - {{ item.count }}</li></ul>
    </div>
</body>

<script src="./colorRange.js"></script>
<script>
var vue = new Vue({
    el: '#app',
    data: {
        colorList: colorList,
        items: finalData.sort((a, b) => +b.count - +a.count),
    },
    methods: {
        color (item) {
            return `background: rgba(${item.join(',')})`
        }
    },
    beforeMount: function () {

    }
})
</script>
</html>
)
txtit(Var)
return

::debug::
Var =
(
const debug = (...args) => (console.log(...args), args[args.length - 1])

const debugfn = (x, fn = y => y) => fn(x)
)
code(Var)
return

::loop2::
Var =
(
/**
 * 增强版定时器 ...
 *
 * const fn =  loop(() => console.log(123), 3000)
 * setTimeout(fn.reStart, 5000)
 */
const loop = (fn = () => {}, time = 30 * 1000, loop = true) => {
    // 定时器
    let timer = setInterval(fn, time)
    // reStart
    return {
        stop () {
            // 杀死上一个定时器
            clearInterval(timer)
        },
        start () {
            // 重新开始
            timer = setInterval(fn, time)
        },
        reStart () {
            // 杀死上一个定时器
            clearInterval(timer)
            // 重新开始
            timer = setInterval(fn, time)
        },
    }
}
)
code(Var)
return

::timeout::
::retry::
::axiostry::
::axios.try::
Var =
(
//////////////////////////////////////////////
/// 必须是 axios 1.9.2 以上的版本才支持自定义 config，否则会有 bug
/// <script src="https://libs.cdnjs.net/axios/0.19.2/axios.min.js"></script>
//////////////////////////////////////////////
const match = (target, str_ary) => str_ary.some(str => target.includes(str))

axios.defaults.timeout = 3000

// https://github.com/axios/axios/issues/164#issuecomment-327837467
const reTry = (retryCount = 1, delay = 0) => async err => {
    const { message, config } = err

    // match error 
    if (!match(message, ["Network Error", "timeout"])) return Promise.reject(err)
    
    // Set the variable for keeping track of the retry count
    config.__retryCount = config.__retryCount || 0
    
    // Check if we've maxed out the total number of retries
    if (config.__retryCount >= retryCount) return Promise.reject(err)

    // Increase the retry count
    config.__retryCount += 1
    
    // Delay
    await new Promise(resolve => setTimeout(_ => resolve(), delay || 1))

    // Log
    console.warn('retry axios', config)

    // Return the promise in which recalls axios to retry the request
    return axios(config)
}

// demo ...
axios.interceptors.response.use(res => {
    // ...
    return res
}, reTry(4, 1000))
)
code(Var)
return

::replace::
Var =
(
// 回调函数只有匹配表达式才会触发，所以可以放心使用 args[1]
ext.replace(/<(.+)>/, (...args) => {
    // 获取 <title> 作为标题
    this.levelTitle = args[1]
    // 返回的内容等于替换的内容，我当然是替换为空了
    return ''
})
)
code(Var)
return

::lazyExec::
Var =
(
// 影武者懒执行模式
const lazyExec = obj => {
    // 参数缓存器
    const cache = {}

    // 代理池
    const proxy = {}

    // 是否使用代理模式？
    let isProxy = true

    // 初始化 『缓存器』 和 『代理池』
    for (const [key, val] of Object.entries(obj)) {
        // 初始化 『缓存』
        cache[key] = []

        // 初始化 『代理』
        /* fixbug：用 『状态isProxy』 来区分使用，而不是替换方法的引用，否则解构时会出现问题 */
        proxy[key] = (...args) => isProxy ? cache[key].push(args) : obj[key](...args)
    }

    return {
        // 影武者
        proxy,
        // 执行并且消灭代理
        exec() {
            // 关闭缓存模式
            isProxy = false

            // 看看有哪些缓存任务需要处理
            for (const [key, val] of Object.entries(cache)) {
                // 执行真身方法
                val.length && val.map(v => obj[key](v))
                // 清空缓存
                cache[key] = []
            }
        }
    }
}


const { exec, proxy } = lazyExec({
    fuck (...args) {
        console.log('fuck', ...args)
    },
    shit(...args) {
        console.log('shit', ...args)
    }
})

/* fixbug：用 『状态isProxy』 来区分使用，而不是替换方法的引用，否则解构时会出现问题 */
const { fuck, shit } = proxy
fuck('Mp')
shit('God')

console.log('--- 等待执行 ---')

setTimeout(() => {
    exec()

    console.log('\r\n--- 执行后，未来的方法会立刻执行 ---\r\n')

    fuck('甲')
    fuck('乙')
    fuck('丙')
    fuck('丁')
}, 1500)
)
code(Var)
return

::eq::
::iseq::
Var =
(
const isObject = input => input != null && Object.prototype.toString.call(input) === '[object Object]' 

function looseEqual (a, b) {
  if (a === b) return true
  const isObjectA = isObject(a)
  const isObjectB = isObject(b)
  if (isObjectA && isObjectB) {
    try {
      const isArrayA = Array.isArray(a)
      const isArrayB = Array.isArray(b)
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every((e, i) => {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        const keysA = Object.keys(a)
        const keysB = Object.keys(b)
        return keysA.length === keysB.length && keysA.every(key => {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}
)
code(Var)
return

::.tof::
::.tofix::
::.tonum::
::tof::
::tofix::
::tonum::
::toNumber::
::tofixed::
::fixed::
Var =
(
const toNumber = (val, decimal = 0) => {
  const n = parseFloat(val)
  if (isNaN(n)) return val
  return decimal ? parseFloat(n.toFixed(decimal)) : n
}
)
code(Var)
return

::ispip::
Var =
(
/**
 * Verify if point of coordinates (longitude, latitude) is polygon of coordinates
 * https://github.com/substack/point-in-polygon/blob/master/index.js
 * @param {number} latitude Latitude
 * @param {number} longitude Longitude
 * @param {array<[number,number]>} polygon Polygon contains arrays of points. One array have the following format: [latitude,longitude]

 [JS]如何验证坐标点是否在多边形内
 （温馨提示：计算消耗的时间有点久，最好是放在 web worker 里边计算）
 How to verify if point of coordinates is inside polygon [Javascript] - DEV - Google Chrome
 point-in-polygon/index.js at master · substack/point-in-polygon - Google Chrome
 
 */
function isPointInPolygon (latitude, longitude, polygon) {
  if (typeof latitude !== 'number' || typeof longitude !== 'number') {
    throw new TypeError('Invalid latitude or longitude. Numbers are expected')
  } else if (!polygon || !Array.isArray(polygon)) {
    throw new TypeError('Invalid polygon. Array with locations expected')
  } else if (polygon.length === 0) {
    throw new TypeError('Invalid polygon. Non-empty Array expected')
  }

  const x = latitude; const y = longitude

  let inside = false
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0]; const yi = polygon[i][1]
    const xj = polygon[j][0]; const yj = polygon[j][1]

    const intersect = ((yi > y) !== (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
    if (intersect) inside = !inside
  }

  return inside
}
)
code(Var)
return

::noop::
Var =
(
export const noop = () => {}
)
code(Var)
return

::wc::
::web component::
::web.component::
::web components::
::web.components:
Var =
(
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
</head>

<body>
    <div id="app">
        <hello-world>
            Lee
        </hello-world>
    </div>
</body>

<script type='module'>
    
const loadComponent = (function() {

    const parse = html => {
        // DOM 解析器
        const parser = new DOMParser()
        // 将字符串解析为 DOM 元素（cool）
        const doc = parser.parseFromString(html, 'text/html' )
        // 获取头部信息（所有的内容都被解析到 head 中）
        const head = doc.head
        // 获取 style
        const style = head.querySelector( 'style' )
        // 获取 template
        const template = head.querySelector( 'template' )
        // 获取 script
        const script = head.querySelector( 'script' )
        // 返回三要素
        return { template, style, script }
    }

    // ...
    const getSetting = ({ template, style, script }) => {
        // ...
        const jsFile = new Blob([script.textContent], { type: 'application/javascript' })
        // ...
        const jsURL = URL.createObjectURL( jsFile )

        // ...
        const getListeners = settings => {
            const listeners = {}

            // 遍历所有的选项
            Object.entries(settings).forEach(([setting, value]) => {
                // 事件约定必须 on 开头...
                if (setting.startsWith('on')) {
                    listeners[setting[2].toLowerCase() + setting.substr(3)] = value
                }
            })

            return listeners
        }

        // ...
        return import(jsURL).then(module => {
            // ...
            console.log(module)

            // 获取所有监听事件
            const listeners = getListeners(module.default)

            return { 
                name: module.default.name, 
                template, 
                style,
                listeners,
            }
        })
    }

    const registerComponent = ({ template, style, name, listeners }) => {
        // 通常组件
        class UnityCompnents extends HTMLElement {
            // abstract Interface
            connectedCallback() {
                this._upcast()
                this._attachListeners()
            }

            // ...
            _upcast() {
                // ...
                const shadow = this.attachShadow({ mode: 'open' })
                // ...
                shadow.appendChild(style.cloneNode(true))
                // ...
                shadow.appendChild(document.importNode(template.content, true))
            }

            // ... 
            _attachListeners() {
                Object.entries(listeners).forEach(([eventName, callback]) => {
                    this.addEventListener(eventName, callback, false)
                })
            }
        }

        // customElements API 自定义组件
        return customElements.define(name, UnityCompnents)
    }

    const _loadComponent = async url => await fetch(url)
        // 获取组件代码
        .then(response => response.text())
        // 进一步解析字符串
        .then( parse )
        // 解析 es6 modules
        .then( getSetting )
        // 注册组件
        .then( registerComponent )

    return _loadComponent
}())

loadComponent('HelloWorld.wc').then(component => {
  console.log(component)
})
</script>
</html>
---
<template>
    <div class="hello">
        <p>Hello, world! My name is </p>
        <slot></slot>
    </div>
</template>

<script>
    export default {
        name: 'hello-world',
        onClick() {
            alert(`莫挨老子!`)
        },
    }
</script>

<style>
    div {
        background: red;
        border-radius: 30px;
        padding: 20px;
        font-size: 20px;
        text-align: center;
        width: 300px;
        margin: 0 auto;
    }
</style>
)
txtit(Var)
return

::lastpath::
Var =
(
const lastpath = path => path.substr(path.lastIndexOf('/') + 1)
)
code(Var)
return

::$.json::
::$json::
Var =
(
const dongguan = await $.getJSON('./data-dongguan.json')
)
code(Var)
return

::minimap::
Var =
(
// your code...
/**
 * 参考资料
 * https://codepen.io/shshaw/pen/wGPpqL
 * https://www.jianshu.com/p/8016cde22aaf
 * http://www.jq22.com/yanshi815
 * https://www.baidu.com/s?ie=utf-8&wd=在网页中实现
 *
 * 使用方式：
 * minimap.render()
 */
;(function(doc, body, win) {
    /* 加载样式 */
    const injectCss = function(css) {
        const style = document.createElement('style')
        style.type = 'text/css'
        style.id = 'slider'
        style.styleSheet ? (style.styleSheet.cssText = css) : (style.appendChild(document.createTextNode(css)))
        document.getElementsByTagName('head')[0].appendChild(style)
    }
    injectCss(``
        .slider { position: fixed; top: 10px; left: 10px; min-width: 20px; max-width: 150px; box-shadow: 0 2px 13px rgba(0, 0, 0, 0.3); cursor: grab; opacity: 0.5; transition: opacity 800ms ease-in-out 200ms; z-index: 999; } 
        .slider:hover { opacity: 1; transition-delay: 0ms; } 
        .slider__size { position: relative; z-index: 3; } 
        .slider__controller { width: 100`%; padding-top: 100`%; position: absolute; top: 0; left: 0; transform-origin: 0 0; margin: -3px; border-radius: 10`%;  border: 2px solid silver; } 
        .slider__controller:hover { box-shadow: 0 0 0.4em darkgrey; } 
        .slider__content { position: absolute; top: 0; left: 0; width: 100`%; height: 100`%; z-index: -1; transform-origin: 0 0; }
    ``)

    /* 创建组件 */
    var slider = doc.createElement('div'),
        sliderSize = doc.createElement('div'),
        controller = doc.createElement('div'),
        // iframe
        sliderContent = doc.createElement('iframe'),
        // 从这个代码可以看出原理是把内容原封不动复制，并且缩小。
        scale = 0.1,
        // 从这个代码可以看出最终的缩放比，是动态的。 猜测应该是 小地图的真实大小 / 页面的大小
        realScale = scale


    slider.className = 'slider'
    sliderSize.className = 'slider__size'
    controller.className = 'slider__controller'
    sliderContent.className += ' slider__content'
    sliderContent.style.transformOrigin = '0 0'

    slider.appendChild(sliderSize)
    slider.appendChild(controller)
    slider.appendChild(sliderContent)
    body.appendChild(slider)

    // export：渲染 iframe 内容
    const render = content => {
        // 删除所有的 Script 标签
        const html = content.replace(/<script([\s\S]*?)>([\s\S]*?)<\/script>/gim, '')

        // 🔔 请注意，必须是 iframe 已经在 body 中才可以使用
        const iframeDoc = sliderContent.contentWindow.document
      
        // 经典的 iframe 修改三部曲，更新 iframe 的内容为当前页面内容
        iframeDoc.open(); iframeDoc.write(html);iframeDoc.close()

        // lee news: 改成更优雅的方法，找到 iframe 里的 slider 删除即可。
        try {
            // 删除 iframe 中的 slider，因为 slider 本质是给 top 用的，所以 iframe 不需要存在
            iframeDoc.querySelector('.slider').parentNode.removeChild(slider)
        } catch (err) {
            // ...
            console.warn('.slider notFound')
        }
    }

    // 获取当前的页面 Html
    const content = doc.documentElement.outerHTML

    // init render
    render(content)
    

    ////////////////////////////////////////

    // 获取比例尺寸
    function getDimensions() {
        var bodyWidth = body.clientWidth, 
            bodyRatio = body.clientHeight / bodyWidth, 
            winRatio = win.innerHeight / win.innerWidth

        // default width is 10`%
        slider.style.width = (scale * 100) + '`%'

        // 我不理解这两个 padding-top 是什么意思？
        sliderSize.style.paddingTop = (bodyRatio * 100) + '`%'
        controller.style.paddingTop = (winRatio * 100) + '`%'

        // Calculate the actual scale in case a max-width/min-width is set.
        realScale = slider.clientWidth / bodyWidth

        sliderContent.style.transform = 'scale(' + realScale + ')'
        sliderContent.style.width = (100 / realScale) + '`%'
        sliderContent.style.height = (100 / realScale) + '`%'
    }

    getDimensions()
    win.addEventListener('resize', getDimensions)
    win.addEventListener('load', getDimensions)

    ////////////////////////////////////////
    // Track Scroll

    function trackScroll() {
        controller.style.transform = 'translate(' + win.pageXOffset * realScale + 'px, ' + win.pageYOffset * realScale + 'px)'
    }

    win.addEventListener('scroll', trackScroll)

    ////////////////////////////////////////
    // Click & Drag Events

    var mouseY = 0, mouseX = 0, mouseDown = false

    function pointerDown(e) {
        e.preventDefault()
        mouseDown = true
        mouseX = e.touches ? e.touches[0].clientX : e.clientX
        mouseY = e.touches ? e.touches[0].clientY : e.clientY

        var offsetX = ((mouseX - slider.offsetLeft) - (controller.clientWidth / 2)) / realScale
        var offsetY = ((mouseY - slider.offsetTop) - (controller.clientHeight / 2)) / realScale

        win.scrollTo(offsetX, offsetY)
    }
    slider.addEventListener('mousedown', pointerDown)
    slider.addEventListener('touchdown', pointerDown)

    function pointerMove(e) {
        if (mouseDown) {
            e.preventDefault()

            var x = e.touches ? e.touches[0].clientX : e.clientX,
                y = e.touches ? e.touches[0].clientY : e.clientY

            win.scrollBy((x - mouseX) / realScale, ((y - mouseY) / realScale))
            mouseX = x
            mouseY = y
        }
    }
    win.addEventListener('mousemove', pointerMove)
    win.addEventListener('touchmove', pointerMove)

    function pointerReset(e) { mouseDown = false }
    win.addEventListener('mouseup', pointerReset)
    win.addEventListener('touchend', pointerReset)

    function pointerLeave(e) {
        if (e.target === body) { mouseDown = false }
    }
    body.addEventListener('mouseleave', pointerLeave)
    body.addEventListener('touchleave', pointerLeave)

    return {
        render
    }

}(document, document.body, window))
)
txtit(Var)
return

::iframe::
Var =
(
const iframe = document.querySelector('iframe')

// 获取 iframe 沙盒中的 document 
const iframeDoc = iframe.contentWindow.document

// content
const HTML = `<div class="frame-root">123</div>`

// 经典的 iframe 修改三部曲，更新 iframe 的内容为当前页面内容
iframeDoc.open(); iframeDoc.write(html); iframeDoc.close();
)
code(Var)
return


::en::
::us::
::toen::
Var =
(
toLocaleString('en-US')
)
code(Var)
return

:?:.toen::
Var =
(
.toLocaleString('en-US')
)
code(Var)
return

::myfetch::
::myxhr::
::mockfetch::
::lanjie::
::mockxhr::
::mock::
Var =
(
// 折叠日志
const logs = (info = '', ...args) => {
    console.groupCollapsed(info)
    args.forEach(_ => console.log(_))
    console.groupEnd()
}

// 是否正则表达式
const isRegExp = exp => exp instanceof RegExp

const proxyResponse = (response, txt) => {
    if (txt === undefined) 
        return response

    // Stream
    const stream = new ReadableStream({
        start(controller) {
            const bufView = new Uint8Array(new ArrayBuffer(txt.length))
            for (var i = 0; i < txt.length; i++) {
                bufView[i] = txt.charCodeAt(i)
            }

            controller.enqueue(bufView)
            controller.close()
        }
    })

    // Response
    const newResponse = new Response(stream, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText,
    })

    // Proxy
    const proxy = new Proxy(newResponse, {
        get: function(target, name) {
            switch (name) {
                case 'ok':
                case 'redirected':
                case 'type':
                case 'url':
                case 'useFinalURL':
                case 'body':
                case 'bodyUsed':
                    return response[name]
            }
            return target[name]
        }
    })

    for (let key in proxy) {
        if (typeof proxy[key] === 'function') {
            proxy[key] = proxy[key].bind(newResponse)
        }
    }

    return proxy
}

// 获取源 fetch
const originalFetch = window.fetch.bind(window)

// （示例demo）定义自己的 fetch
const myFetch = async (...args) => {
    return originalFetch(...args).then((response) => {
        // ... your logic
        console.log('🔴fetch intercept🔴')

        // mock...
        const mock = { foo: 'bar' }

        // new response
        const pr = proxyResponse(response, JSON.stringify(mock))

        return pr
    })
}

// mock fetch
const mockFetch = customs => async (...args) => originalFetch(...args).then((response) => {
    logs('🔴fetch intercept🔴', customs, response)

    // 暂时只需要用 url 即可，不考虑其他
    const { url } = response

    // 从自定义 mock 中查找匹配项
    const target = customs.find(_ => isRegExp(_.match) ? _.match.test(url) : url.includes(_.match))

    // 如果命中了，那就替换内容
    if (target) {
        // new response
        return proxyResponse(response, JSON.stringify(target.mock))
    }

    return response
})

// window.fetch = myFetch

// window.fetch = mockFetch([
//     { match: 'https://api.github.com/users/gaearon/gists', mock: { foo: 'bar' } }
// ])


//////////////////////////////////////////////
// say something...
//////////////////////////////////////////////
const originalXHR = window.XMLHttpRequest

// 返回的必须是普通函数 function 不能是箭头函数
const myXHR = customs => function() {
    const xhr = new originalXHR()

    const modifyResponse = url => {
        // 从自定义 mock 中查找匹配项
        const target = customs.find(_ => isRegExp(_.match) ? _.match.test(url) : url.includes(_.match))

        // 如果命中了，那就替换内容
        if (target) {
            this.responseText = JSON.stringify(target.mock)
            this.response = JSON.stringify(target.mock)
        }
    }

    for (let attr in xhr) {
        if (attr === 'onreadystatechange') {
            xhr.onreadystatechange = (...args) => {
                if (this.readyState == 4) {
                    // ... your logic
                    console.log('🔴xhr change intercept🔴', this.responseURL)
                    // mock
                    modifyResponse(this.responseURL)
                }

                this.onreadystatechange && this.onreadystatechange.apply(this, args)
            }
            continue
        } else if (attr === 'onload') {
            xhr.onload = (...args) => {
                // ... your logic
                console.log('🔴xhr onload intercept🔴', this.responseURL)

                // mock
                modifyResponse(this.responseURL)

                this.onload && this.onload.apply(this, args)
            }
            continue
        }

        if (typeof xhr[attr] === 'function') {
            this[attr] = xhr[attr].bind(xhr)
        } else {
            // responseText和response不是writeable的，但拦截时需要修改它，所以修改就存储在this[`_${attr}`]上
            if (attr === 'responseText' || attr === 'response') {
                Object.defineProperty(this, attr, {
                    get: () => (this[`_${attr}`] == undefined ? xhr[attr] : this[`_${attr}`]),
                    set: (val) => (this[`_${attr}`] = val),
                    enumerable: true,
                })
            } else {
                Object.defineProperty(this, attr, {
                    get: () => xhr[attr],
                    set: (val) => (xhr[attr] = val),
                    enumerable: true,
                })
            }
        }
    }
}

// window.XMLHttpRequest = myXHR([
//     { match: 'https://api.github.com/users/gaearon/gists', mock: { foo: 'bar' } }
// ])

const mockData = (customs = []) => {
    window.XMLHttpRequest = myXHR(customs)
    window.fetch = mockFetch(customs)
}
)
txtit(Var)
return

::shell::
::shelljs::
::shell.js::
::js.shell::
Var =
(
const shell = require('shelljs')

// 是否具有 package.json
const isPgk = shell.find(join(deskPath, 'package.json')).code === 0

// 如果存在，进行 install + dev
if (isPgk) {
    // 进入目录，然后执行 npm install 测试
    shell.exec(`cd ${deskPath} && cnpm i && npm run dev`)
}
---
/**
 * 判断是否安装了某个包
 * @param {string} pkg 包名
 */
const hasPkg = pkg => {
  const pkgPath = path.join(process.cwd(), `package.json`);
  const pkgJson = fs.existsSync(pkgPath) ? fse.readJsonSync(pkgPath) : {};
  const { dependencies = {}, devDependencies = {} } = pkgJson;
  return dependencies[pkg] || devDependencies[pkg];
}

/**
 * 通过 npm 安装包
 * @param {string} pkg 包名
 */
const installPkg = pkg => {
  console.log(`开始安装 ${pkg}`);
  const npm = shell.which('npm');
  if (!npm) {
    console.log('请先安装 npm');
    return;
  }
  const { code } = shell.exec(`${npm.stdout} install ${pkg} -S`);
  if (code) {
    console.log(`安装 ${pkg} 失败，请手动安装`);
  }
};

// biu~
if (!hasPkg(TARGET_PKG_NAME)) {
  installPkg(TARGET_PKG_NAME);
}
)
txtit(Var)
return

::foro::
::forobj::
::objfor::
::mapobj::
Var =
(
const newObj = Object.entries(target).reduce((obj, [key, val]) => {
    console.log(obj, key, val)
    return obj
}, {})
)
code(Var)
return

::cleanProps::
::cleanobj::
::cleanProp::
::cleanObject::
::filterobj::
::objmap::
::obj.map::
::obj.filter::
::
Var =
(
// 净化对象：清空值为 undefined 的属性
const purifyObject = o => Object.entries(o).reduce((obj, [key, value]) => value === undefined ? obj : { ...obj, [key]: value }, {})
)
code(Var)
return

::combi::
Var =
(
const combinate = obj => {
    let combos = []
    for (var key in obj) {
        const values = obj[key]
        const all = [];
        for (let i = 0; i < values.length; i++) {
        for (let j = 0; j < (combos.length || 1); j++) {
            const newCombo = { ...combos[j], [key]: values[i] }
            all.push(newCombo)
        }
        }
        combos = all
    }
    return combos
}

const options = {
  color: ['red', 'blue', 'green'],
  admin: [true, false],
  mode:  ['light', 'dark'],
}

const combinations = combinate(options)
console.log(combinations)
/*
[
  {'admin': true, 'color': 'red', 'mode': 'light'},
  {'admin': true, 'color': 'blue', 'mode': 'light'},
  {'admin': true, 'color': 'green', 'mode': 'light'},
  {'admin': false, 'color': 'red', 'mode': 'light'},
  {'admin': false, 'color': 'blue', 'mode': 'light'},
  {'admin': false, 'color': 'green', 'mode': 'light'},
  {'admin': true, 'color': 'red', 'mode': 'dark'},
  {'admin': true, 'color': 'blue', 'mode': 'dark'},
  {'admin': true, 'color': 'green', 'mode': 'dark'},
  {'admin': false, 'color': 'red', 'mode': 'dark'},
  {'admin': false, 'color': 'blue', 'mode': 'dark'},
  {'admin': false, 'color': 'green', 'mode': 'dark'}
]
*/
)
code(Var)
return

::shehuizhuyi::
::shehui::
::jiazhiguan::
::shzy::
Var =
(
(function() {
    var coreSocialistValues = ["富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"]
      , index = Math.floor(Math.random() * coreSocialistValues.length);
    document.body.addEventListener('click', function(e) {
        if (e.target.tagName == 'A') {
            return;
        }
        var x = e.pageX
          , y = e.pageY
          , span = document.createElement('span');
        span.textContent = coreSocialistValues[index];
        index = (index + 1) `% coreSocialistValues.length;
        span.style.cssText = ['z-index: 9999999; position: absolute; font-weight: bold; color: #ff6651; top: ', y - 20, 'px; left: ', x, 'px;'].join('');
        document.body.appendChild(span);
        animate(span);
    });
    function animate(el) {
        var i = 0
          , top = parseInt(el.style.top)
          , id = setInterval(frame, 16.7);
        function frame() {
            if (i > 180) {
                clearInterval(id);
                el.parentNode.removeChild(el);
            } else {
                i += 2;
                el.style.top = top - i + 'px';
                el.style.opacity = (180 - i) / 180;
            }
        }
    }
}());
)
code(Var)
return

::store.help::
::help::
::cs::
::creates::
::store.help::
::help.store::
::storec::
::storecreate::
::create.store::
::createstore::
Var =
(
// @/store/help.js
import { POST, GET } from '@/utils/request.js'

export { inject } from './inject.js'

// fixbug: 如果直接修改 state 不行的话，能否顺便生成 mutations 。 用 mutations 的 commit 来解决赋值的问题。
// 而且这样更加规范。那么问题来了，我好像没有办法「自动」拿到 commit
// 那不如这样，约定使用 return，只要你 return ， 我就可以自动赋值，当然也确实会return。两全其美。
export const createStore = (store = {}) => {
    // 默认配置
    // fixbug: 忘记加入了 { namespaced: true }，必须加入这个才能形成「模块 modules」
    const defaultStore = { namespaced: true, state: {}, actions: {} }

    // 初始化 store
    const __store__ = Object.assign({}, defaultStore, store)

    // 初始化 store.state
    __store__.state = Object.entries(__store__.actions).reduce((obj, [key, action]) => {
        // 是否已经注册同名的 state 了？
        if (key in obj) {
            // 如果已经注册了，那直接跳过
            return obj
        }

        // 如果还没有注册的话，那就初始化一个
        obj[key] = null

        // 迭代
        return obj
    }, __store__.state)
    
    // 初始化 store.mutations
    __store__.mutations =  Object.entries(__store__.actions).reduce((obj, [key, action]) => {
        // 同名 mutatios
        obj[key] = function (state, payload) {
            // 同名 state
            state[key] = payload
        }
        return obj
    }, {})

    // 初始化 store.actions
    __store__.actions = Object.entries(__store__.actions).reduce((obj, [key, action]) => {
        // 重载
        obj[key] = async function (context, payload) {
            // inject the POST/GET
            Object.assign(context, { POST, GET })
            // 获取返回值
            const result = await action(context, payload)
            // 调用 commit
            context.commit(key.toUpperCase(), result)
            // 照常返回数据
            return result
        }

        // 迭代
        return obj
    }, {})

    // 返回最终 store
    return __store__
}
---
// @/store/inject.js
import { maybe, doTry, debug } from '@/utils/utils.js'

// 所有页面组件
const AllComponents = require.context('@/views', true, /\.vue$/)

// 获取路径
const getPath = p => p.substr(0, p.lastIndexOf('/')).replace(/src\//, '')

// 获取最后一个路径
const getLastPath = p => p.substr(p.lastIndexOf('/') + 1)

// 是否具备 store.js 
const getStore = (function() {
    // memoized
    let cache = {}
    
    return p => {
        // 是否存在缓存？
        if (cache[p]) return cache[p]

        // 用 try 来尝试引入 store.js，如果报错了则表示不存在
        let [err, result] = doTry(_ => require(`@/${p}/store.js`))
    
        // 如果报错返回 False，没报错则返回 store，并且加入缓存
        return err ? false : cache[p] = result
    }
}())

export const inject = (VueComponent = AllComponents) => {
    VueComponent.keys().forEach(path => {
        // 直接获取文件内容的引用
        const output = VueComponent(path).default

        // 获取组件路径
        const p = getPath(output.__file)

        // 是否包含 store.js 
        const store = getStore(p)

        // 如果具备 store.js 才进行处理
        if (store) {
            // init methods 
            if (!output.methods) output.methods = {}

            // init computed 
            if (!output.computed) output.computed = {}
            
            // 找到模块名（如果具备 store.js，那么最后一个路径就是 Module 了）
            const __module = getLastPath(p)
    
            // inject __module methods
            output.methods['__module'] = () => __module

            // state
            const state = maybe(_ => store.default.state, [])

            // inject store
            Object.keys(state).forEach(key => {
                // 这里由于要使用 this 上下文，所以千万别用箭头函数
                output.computed[key] = function () {
                    // such as: this.$store.state.Apart.dataAggreData
                    return this.$store.state[__module][key]
                }
            })
        }
    })
}
---
// @/views/TestPage/store.js
import { createStore } from '@/store/help'

export default createStore({
    actions: {
        _fuckgod ({ commit, state, dispatch, rootState, getters, rootGetters, POST, GET }, payload) {
          return POST('actuator/direct/readModuleRedisData|ffffffffffffffffffffffffffffffffffff', { id: 10 })
        },
    }
})
)
txtit(Var)
return

::dotry::
::try2::
::tryc::
::trycatch::
Var =
(
const doTry = (_try = () => {}, _catch = () => {}) => {
    let _err = null
    let _result = null

    try {
        _result = _try()
    } catch (err) {
        _err = err
        _catch(err)
    }
    
    return [_err, _result]
}

const doTryAsync = async (_try = () => {}, _catch = () => {}) => {
    let _err = null
    let _result = null

    try {
        _result = await _try()
    } catch (err) {
        _err = err
        _catch(err)
    }
    
    return [_err, _result]
}
---
// 1. baisc usage
;(function(){
    const [err, result] = doTry(() => 'fuck')

    if (err) {
        return
    }

    console.log(result)
}())

// 2. usage catch
const [err, result] = doTry(() => fuckyou(), error => console.warn('捕捉到错误'))

console.log(result)

// 3. useage async/await
;(async function(){
    const test = () => new Promise((resolve, reject) => setTimeout(_ => resolve('success'), 3000))

    const [err, result] = await doTryAsync(test)

    if (err) {
        return
    }

    console.log(result)
}())

// 4. useage async/await reject
;(async function(){
    const test = () => new Promise((resolve, reject) => setTimeout(_ => reject('fail'), 4000))

    const [err, result] = await doTryAsync(test)

    if (err) {
        console.log('catch reject')
        return
    }

    console.log(result)
}())


// 5. useage async/await error
;(async function(){
    const test = () => new Promise((resolve, reject) => { throw new Error('error') })

    const [err, result] = await doTryAsync(test)

    if (err) {
        console.log('catch error')
        return
    }

    console.log(result)
}())

// 6. no work !!!! promise => setTimeout => error
;(async function(){
    var test = () => new Promise((resolve, reject) => setTimeout(_ => { throw new Error('error') }, 4000))

    // no work
    const [err, result] = await doTryAsync(test)
}())
---
// 老样子，不要在 async 中使用 setTimeout
const tryCatch = (fn = () => {}, errHandler) => async (...args) => {
    try {
      return await fn(...args)
    } catch (err) {
      errHandler(err)
    }
}

tryCatch(
    // 老样子，不要在 async 中使用 setTimeout
    async id => {
        // console.log(20200802185712, id)
        throw new Error('110')
    },
    err => console.log(err.message),
`)('1')
)
txtit(Var)
return

::copyfunciton::
::copymethod::
::copymethods::
::copyfn::
Var =
(
const test = () => console.log('foo')
const origin = Object.assign({}, { fn: test })

var { fn } = origin 

// 通过修改来判断是否拷贝成功
fn = () => console.log('bar')
fn() // => bar
test() // => foo
---
const copyFn = fn => Object.assign({}, fn).fn

const test = () => console.log('foo')
const test2= copy(test)

test2 = () => console.log('bar')
test2() // => bar
test() // => foo
)
txtit(Var)
return

::github::
::code::
Var =
(
/**
 * 移动dom元素到指定目标位置
 *
 * @source {DOM} 你要移动的DOM
 * @target {DOM} 你要移动的位置
 */
const mvDOM = function (source, target) {
    // 深度拷贝（含子元素）
    let _source = source.cloneNode(true)
    // 删除本身
    source.remove()
    // 默认插入到容器最前面，如果想在后面可以这样处理：target.append(source)
    target.insertBefore(_source, target.firstChild)
}

document.querySelectorAll('pre, .gist').forEach((el, key) => {
    // 新建代码容器
    const code = document.createElement('code')

    // 插入父元素
    el.insertAdjacentElement('beforebegin', code)

    // 移动到容器内
    mvDOM(el, code)
})
)
code(Var)
return

::matchBy::
Var =
(
const matchBy = (items, rules) => items.reduce((p, c, i, a) => {
    // 是否找到
    const isFind = rules.find(rule => c.includes(rule))
    // 找到则迭代
    return isFind ? [...p, c] : p
}, [])

const items = ['leftSide/_depaInformation', 'leftSide/_taskCompletionData', 'leftSide/_chooseTitleData', 'leftSide/_mainCardPoints', 'rightSide/_generalSituationData', 'rightSide/_basicLib', 'rightSide/_themeLib', 'rightSide/_themeLibList', 'rightSide/_mainFileNumber', 'rightSide/_departmentData', 'rightSide/_cityData', 'dataAssets/tableDataA', 'dataAssets/tableDataB', 'dataAssets/tableDataC', 'dataAssets/tableDataD',]
const rules = ['leftSide', 'dataAssets']
const _items = matchBy(items, rules)
console.log(20200629202141, _items)
)
code(Var)
return

::trim::
:?:.trim::
Var =
(
.replace(/(^[\s\n\t]+|[\s\n\t]+$)/g, '')
)
code(Var)
return

::div::
::usediv::
Var =
(
const useDiv = () => {
    let div = document.createElement('div')
    div.style.display = 'none'
    document.body.append(div)
    return [div, () => div.remove()]
}

// 创建一个容器
const [div, remove] = useDiv()
---
const useDiv = (setStyle = () => {}, target = document.body) => {
    // 创建 div
    let div = document.createElement('div')
    // 修改样式
    setStyle(div)
    // 插入body
    target.append(div)
    // 返回 hook
    return [div, () => div.remove()]
}

// div hoook（老实说频繁操作dom我也不喜欢，但影响几乎没有）
const [div, remove] = useDiv(div => {
    div.className = 'map-tip'
    div.textContent = title
}, target)
)
txtit(Var)
return

::rightclick::
::clickright::
::clickr::
::rclick::
Var =
(
// 这就是核心的拦截事件
document.oncontextmenu = (e) => {
    console.log('打开右键菜单')

    // 拦截浏览器默认右键行为
    e.preventDefault()
}
)
code(Var)
return

::getip::
Var =
(
教程地址：https://blog.csdn.net/zqian1994/article/details/79222812
新浪的IP地址查询接口：http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js
（默认为纯文本格式，根据format的参数定义，还可以返回JS、Json格式）。

新浪多地域测试方法：
http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&ip=219.242.98.111

搜狐IP地址查询接口（默认GBK）：http://pv.sohu.com/cityjson

搜狐IP地址查询接口（可设置编码）：http://pv.sohu.com/cityjson?ie=utf-8

<script src="http://pv.sohu.com/cityjson?ie=utf-8"></script>
<script type="text/javascript">  
    console.log(returnCitySN["cip"]+','+returnCitySN["cname"])  
</script>
)
code(Var)
return