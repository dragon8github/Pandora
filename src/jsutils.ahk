!u::
    Menu, utilsIs, Add, is, utilsHandler
    Menu, utilsIs, Add, isString, utilsHandler
    Menu, utilsIs, Add, isNumber, utilsHandler
    Menu, utilsIs, Add, isBoolean, utilsHandler
    Menu, utilsIs, Add, isArray, utilsHandler
    Menu, utilsIs, Add, isObject, utilsHandler
    Menu, utilsIs, Add, isPureObject, utilsHandler
    Menu, utilsIs, Add, isFunction, utilsHandler
    Menu, utilsIs, Add, isDate, utilsHandler
    Menu, utilsIs, Add, isPromise, utilsHandler
    Menu, utilsIs, Add, isNaN, utilsHandler
    Menu, utilsIs, Add, isNodeList, utilsHandler

    Menu, utilsIs, Add, , utilsHandler
    Menu, utilsIs, Add, , utilsHandler

    Menu, utilsIs, Add, isZH-Cn, utilsHandler
    Menu, utilsIs, Add, isIp, utilsHandler
    Menu, utilsIs, Add, isPhone, utilsHandler
    Menu, utilsIs, Add, isPwd, utilsHandler
    Menu, utilsIs, Add, isUser, utilsHandler
    Menu, utilsIs, Add, isId, utilsHandler
    Menu, utilsIs, Add, isEmail, utilsHandler
    Menu, utilsIs, Add, is-wx, utilsHandler
    Menu, utilsIs, Add, is-ie, utilsHandler
    Menu, utilsIs, Add, isBottom 是否滚动到底部, utilsHandler

    Menu, utilsDOM, Add, addClass, utilsHandler
    Menu, utilsDOM, Add, hasClass, utilsHandler
    Menu, utilsDOM, Add, removeclass , utilsHandler
    Menu, utilsDOM, Add, getclassname, utilsHandler
    Menu, utilsDOM, Add, getstyle, utilsHandler
    Menu, utilsDOM, Add, setStyle, utilsHandler
    Menu, utilsDOM, Add, setattr, utilsHandler
    Menu, utilsDOM, Add, removeattr, utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, getElementPosition 获取元素的定位, utilsHandler
    Menu, utilsDOM, Add, gettop 获取距离顶部的相对距离, utilsHandler
    Menu, utilsDOM, Add, scrollToTop 滚动到头部, utilsHandler
    Menu, utilsDOM, Add, scrollIntoView 滚动到元素可视区域, utilsHandler
    Menu, utilsDOM, Add, isBottom 是否滚动到底部, utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, injectCss 往页面插入style, utilsHandler
    Menu, utilsDOM, Add, getScriptPath, utilsHandler
    Menu, utilsDOM, Add, onscript/loadscript 加载脚本并等待加载完成, utilsHandler
    Menu, utilsDOM, Add, addcss/link 样式加载器, utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, 是否隐藏：$('#div').is(':hidden'), utilsHandler
    Menu, utilsDOM, Add, 是否显示：$('#div').is(':visible'), utilsHandler
    Menu, utilsDOM, Add, clickOutSide：!el.contains(event.target), utilsHandler
    
    
    Menu, utilsObject, Add, for#Object.keys, utilsHandler
    Menu, utilsObject, Add, for#o in obj, utilsHandler
    Menu, utilsObject, Add, for#Object.entries(), utilsHandler
    Menu, utilsObject, Add, for#Object.values(), utilsHandler
    Menu, utilsObject, Add, for#Object.keys(), utilsHandler

    Menu, utilsObject, Add,, utilsHandler
    Menu, utilsObject, Add,, utilsHandler

    Menu, utilsObject, Add, (〜￣△￣)〜认知～(￣▽￣～)：({a = 123`, b = 321`, c = 456} = {}) 对象解构 与 参数默认值, utilsHandler
    Menu, utilsObject, Add, delete person.age 删除对象的属性, utilsHandler
    Menu, utilsObject, Add, Object.assign({}`, ), utilsHandler
    Menu, utilsObject, Add, Object.is 比 === 更严格的比较, utilsHandler
    Menu, utilsObject, Add, 'tail' in cat / cat.hasOwnProperty('tail') 判断对象是否包含某属性, utilsHandler
    
    Menu, utilsObject, Add,, utilsHandler
    Menu, utilsObject, Add,, utilsHandler

    Menu, utilsObject, Add, Object.defineProperty 属性的权限设置 writable（可写） / configurable（可配置）/enumerable（可枚举）, utilsHandler
    Menu, utilsObject, Add, Object.defineProperties 属性的批量权限设置, utilsHandler
    Menu, utilsObject, Add, Object.getOwnPropertyDescriptor({a: 123}`, 'a') 获取属性的配置, utilsHandler
    Menu, utilsObject, Add, getter / setter , utilsHandler


    Menu, utilsSolution, Add, cookie 库, utilsHandler
    Menu, utilsSolution, Add, Model 类, utilsHandler
    Menu, utilsSolution, Add, rem 解决方案 / 淘宝解决方案, utilsHandler
    Menu, utilsSolution, Add, AMD/CommonJS/factory/module, utilsHandler
    Menu, utilsSolution, Add, cache request axios 缓存请求, utilsHandler
    Menu, utilsSolution, Add, $.autoscroll 自动滚动, utilsHandler
    Menu, utilsSolution, Add, $.scrollforevery 无缝滚动, utilsHandler
    
    Menu, utilsSolution, Add, dragscroll 拖拽滚动, utilsHandler
    Menu, utilsSolution, Add, lazyload 图片懒加载, utilsHandler
    Menu, utilsSolution, Add, preloadimg 图片预加载, utilsHandler
    Menu, utilsSolution, Add, countDown 倒计时, utilsHandler
    Menu, utilsSolution, Add, copyToClipboard 剪切板, utilsHandler
    

    Menu, utilsExtend, Add, extend 浅拷贝, utilsHandler
    Menu, utilsExtend, Add, deepExtend 深拷贝, utilsHandler
    Menu, utilsExtend, Add, multi 多重拷贝, utilsHandler
    Menu, utilsExtend, Add, 寄生式继承, utilsHandler
    Menu, utilsExtend, Add, 构造器借用, utilsHandler
    
    
    Menu, utilsThis, Add, 1、作为对象的方法调用, utilsHandler
    Menu, utilsThis, Add, 2、作为普通函数调用时, utilsHandler
    Menu, utilsThis, Add, 3、作为构造器调用, utilsHandler
    Menu, utilsThis, Add, 4、Function.prototype.call 或 Function.prototype.apply 调用, utilsHandler
    Menu, utilsThis, Add, 5、es6箭头函数调用时, utilsHandler
    Menu, utilsThis, Add, 6、es6 class 中的, utilsHandler
    
    Menu, utilsDesignPattern, Add, this , :utilsThis
    Menu, utilsDesignPattern, Add, 封装, utilsHandler
    Menu, utilsDesignPattern, Add, 模块模式：现代模块实现的基石, utilsHandler
    Menu, utilsDesignPattern, Add, 多态, utilsHandler
    Menu, utilsDesignPattern, Add, 继承, :utilsExtend
    Menu, utilsDesignPattern, Add, 闭包与Cache, :utilsExtend
    Menu, utilsDesignPattern, Add, call 和 apply, utilsHandler
    Menu, utilsDesignPattern, Add, AOP - 面向切面编程, utilsHandler
    Menu, utilsDesignPattern, Add, 抽象类接口：咖啡与茶, utilsHandler
    
    Menu, utilsDesignPattern, Add, Function.prototype.before, utilsHandler
    Menu, utilsDesignPattern, Add, Function.prototype.after, utilsHandler

    Menu, utilsDesignPattern, Add, , utilsHandler
    Menu, utilsDesignPattern, Add, , utilsHandler
    
    
    Menu, utilsDesignPattern, Add, 单例版ajax, utilsHandler
    Menu, utilsDesignPattern, Add, 惰性单例, utilsHandler
    Menu, utilsDesignPattern, Add, 透明单例, utilsHandler
    Menu, utilsDesignPattern, Add, 代理单例, utilsHandler
    Menu, utilsDesignPattern, Add, 通用的惰性单例, utilsHandler
    Menu, utilsDesignPattern, Add, （回调版）单例模式，通常用于ajax类, utilsHandler
    
    
    
    Menu, utilsDesignPattern, Add, , utilsHandler
    Menu, utilsDesignPattern, Add, , utilsHandler
    
    Menu, utilsDesignPattern, Add, JavaScript版 策略模式, utilsHandler
    Menu, utilsDesignPattern, Add, __EVENT__消息订阅, utilsHandler
    Menu, utilsDesignPattern, Add, es6 超简洁版Event事件模块, utilsHandler
    Menu, utilsDesignPattern, Add, 仿rxjs的观察者模式, utilsHandler
    
    Menu, utilsDesignPattern, Add, , utilsHandler
    Menu, utilsDesignPattern, Add, , utilsHandler
    
    Menu, utilsDesignPattern, Add, 优惠券条件分支：链式after解决方案, utilsHandler
    
    
    Menu, utilspractice, Add, 函数参数对象深度解构 var a = ({ state: { nums`, numGroup`, map } }) => {}, utilsHandler
    Menu, utilspractice, Add, 解构与split结合：const [language`, country] = locale.split('-'), utilsHandler
    Menu, utilspractice, Add, parseFloat可以直接移除字符串：parseFloat(layero.css('left')) // '162px' => 162, utilsHandler
    Menu, utilspractice, Add, curry2 二元参数的手动柯里化, utilsHandler
    Menu, utilspractice, Add, 对象字面量如何使用async/await标记, utilsHandler
    Menu, utilspractice, Add, ...args参数和fn(...args) 入参的技巧和认知, utilsHandler
    Menu, utilspractice, Add, 多个异步操作时，请毫不犹豫用Pormise.all, utilsHandler
    Menu, utilspractice, Add, Promise.race只返回最快的一个, utilsHandler
    Menu, utilspractice, Add, koajs 核心函数compose的超简单源码实现, utilsHandler
    
    Menu, utilsmy, Add, deepfind 深度递归搜索, utilsHandler
    Menu, utilsmy, Add, 加强版map遍历:bettermap, utilsHandler
    Menu, utilsmy, Add, maybe 神奇的预设函数, utilsHandler
    Menu, utilsmy, Add, 单例版ajax, utilsHandler
    Menu, utilsmy, Add, 去重复版本的axios, utilsHandler
    Menu, utilsmy, Add, 获取前6个月/前15天数据, EventHandler
    
    Menu, utilsjuran, Add, 社会主义点击事件, utilsHandler
    Menu, utilsjuran, Add, anime.js 点击烟花绽放效果, utilsHandler
    Menu, utilsjuran, Add, holder占位图, utilsHandler
    Menu, utilsjuran, Add, window.onunload 刷新/关闭页面之前发送请求, utilsHandler
    
    
    Menu, utilsmaybe, Add, 处理iOS 微信客户端6.7.4 键盘收起页面未下移bug, utilsHandler
    Menu, utilsmaybe, Add, Android 输入法键盘 和 input 问题:scrollIntoViewIfNeeded, utilsHandler
    Menu, utilsmaybe, Add, 获取手机归属地信息：中国移动/中国联通/中国电信, utilsHandler
    Menu, utilsmaybe, Add, js获取root（window）对象, utilsHandler
    
    
    Menu, utilsMenu , Add, is 判断, :utilsIs
    Menu, utilsMenu , Add, DOM 操作, :utilsDOM
    Menu, utilsMenu , Add, Object 操作, :utilsObject
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu , Add, (#-_-)┯━┯  解决方案, :utilsSolution
    Menu, utilsMenu , Add, (╯°口°)╯(┴—┴  设计模式, :utilsDesignPattern
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, (〜￣△￣)〜认知～(￣▽￣～), :utilspractice
    Menu, utilsMenu, Add, (=・ω・=) 我的 (｀・ω・´), :utilsmy
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, !!Σ(゜Д゜) 居然还有这种操作？ Σ(ﾟдﾟ;), :utilsjuran
    Menu, utilsMenu, Add, ╮(￣▽￣)╭ 没准将来会有用呢？ ╮(￣▽￣)╭, :utilsmaybe
 
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    

    Menu, utilsMenu, Add, uuid 超简易版, utilsHandler
    Menu, utilsMenu, Add, urlparams 获取路由参数, utilsHandler
    
    Menu, utilsMenu, Add, device 获取设备信息, utilsHandler
    Menu, utilsMenu, Add, 获取localStorage剩余容量和最大容量, utilsHandler

    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, compose 函数组合, utilsHandler
    Menu, utilsMenu, Add, debounce 函数去抖, utilsHandler
    Menu, utilsMenu, Add, throttle 函数节流, utilsHandler
    Menu, utilsMenu, Add, memoized 函数缓存, utilsHandler
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, JSON.parse(JSON.stringify(...)) 超简易拷贝, utilsHandler
    Menu, utilsMenu, Add, window.requestAnimFrame, utilsHandler
    Menu, utilsMenu, Add, poll 递归, utilsHandler
    Menu, utilsMenu, Add, pad 自动补全, utilsHandler
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, 模拟真实点击click，专门对付clickoutside, utilsHandler
    Menu, utilsMenu, Add, filterhtml: 移除html标签，只提取文本text(), utilsHandler
    Menu, utilsMenu, Add, encodeURI URI过滤, utilsHandler
    Menu, utilsMenu, Add, escapeHTML 防止XSS, utilsHandler
    Menu, utilsMenu, Add, ClickOutside 点击外部冒泡, utilsHandler
    Menu, utilsMenu, Add, 高度从0到auto的伸缩特效魔法, utilsHandler
        

    Menu, utilsMenu, Show
	Menu, utilsMenu, DeleteAll
    Menu, utilsIs, DeleteAll
    Menu, utilsDOM, DeleteAll
    Menu, utilsObject, DeleteAll
    Menu, utilsDesignPattern, DeleteAll
    
return


utilsHandler:
; MsgBox You selected  from the menu .
v := A_ThisMenuItem
Var :=


if (v == "") {
Var = 
(
)
}

if (v == "去重复版本的axios") {
SendLevel 1
Send, singaxios{tab}
return
}

if (v == "单例版ajax") {
SendLevel 1
Send, singajax{tab}
return
}

if (v == "函数参数对象深度解构 var a = ({ state: { nums, numGroup, map } }) => {}") {
Var = 
(
var a = ({ state: { nums, numGroup, map } }) => {
	console.log(20190209102908, nums, numGroup, map)
}

a({state: {nums: 1, numGroup: 2, map: 3 } })
)
}

if (v == "模拟真实点击click，专门对付clickoutside") {
Var = 
(
var evmousedown = document.createEvent('HTMLEvents'); 
// evmousedown.clientX = 88
// evmousedown.clientY = 18
evmousedown.initEvent('mousedown', false, true); 
var evmouseup = document.createEvent('HTMLEvents'); 
// evmouseup.clientX = 88
// evmouseup.clientY = 18
evmouseup.initEvent('mouseup', false, true); 
document.dispatchEvent(evmousedown)
document.dispatchEvent(evmouseup)
)
}

if (v == "koajs 核心函数compose的超简单源码实现") {
Var = 
(
// https://github.com/koajs/compose/blob/master/index.js
function compose (middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
  }
  return function (context, next) {
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}

const a = async (ctx, next) => {
  console.log(1)
  const hello = await Promise.resolve('hello')
  console.log(hello)

  await next()
  console.log('a end')
}

const b = async (ctx, next) => {
  console.log(2)
  const hello = await Promise.resolve('hello')
  console.log(hello)

  await next()
  console.log('b end')
}

compose([a, b])({});
// 1
// hello
// 2
// hello
// b end
// a end
)
}

if (v == "仿rxjs的观察者模式") {
Var = 
(
function create(fn) {

	let isComplete = false

	return ({ next, complete, error }) => {
		function _next(...args) {
			if (isComplete) 
				return
			next(...args)
		}

		function _complete(...args) {
			complete(...args)
			isComplete = true
		}

		function _error(...args) {
			error(...args)
		}

		// 依赖注入
		fn({ next: _next, complete: _complete, error: _error })

		// 返回开关
		return () => (isComplete = true)
	}
}

let observerable = create(observer => {
	setTimeout(() => {
		observer.next(1)
	}, 1000)
	observer.next(2)
	observer.complete(3)
})

const subject = {
	next: value => {
		console.log(value)
	},
	complete: console.log,
	error: console.log
}

let unsubscribe = observerable(subject);

// 输出 2
// 输出 3
// 并没有输出1，因为 complete 之后 next 就不会生效了。
)
}

if (v == "Promise.race只返回最快的一个") {
Var = 
(
const getName = new Promise((resolve, reject) => {
   setTimeout(function () {
        resolve('success') // reject('fail')
   }, 50);
})

const getNumber = Promise.resolve(1)

Promise.race([getName, getNumber])
	.then(console.log) // 输出 1 只输出最快返回的一个
	.catch(console.log)
)
}

if (v == "anime.js 点击烟花绽放效果") {
Var = 
(
<script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<canvas class="fireworks" style="position: fixed; left: 0px; top: 0px; z-index: 1; pointer-events: none;" width="2880" height="832"></canvas>

// fireworks.js

"use strict";
function updateCoords(e) {
    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left,
    pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top
}
function setParticuleDirection(e) {
    var t = anime.random(0, 360) * Math.PI / 180
      , a = anime.random(50, 180)
      , n = [-1, 1][anime.random(0, 1)] * a;
    return {
        x: e.x + n * Math.cos(t),
        y: e.y + n * Math.sin(t)
    }
}
function createParticule(e, t) {
    var a = {};
    return a.x = e,
    a.y = t,
    a.color = colors[anime.random(0, colors.length - 1)],
    a.radius = anime.random(16, 32),
    a.endPos = setParticuleDirection(a),
    a.draw = function() {
        ctx.beginPath(),
        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),
        ctx.fillStyle = a.color,
        ctx.fill()
    }
    ,
    a
}
function createCircle(e, t) {
    var a = {};
    return a.x = e,
    a.y = t,
    a.color = "#F00",
    a.radius = .1,
    a.alpha = .5,
    a.lineWidth = 6,
    a.draw = function() {
        ctx.globalAlpha = a.alpha,
        ctx.beginPath(),
        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),
        ctx.lineWidth = a.lineWidth,
        ctx.strokeStyle = a.color,
        ctx.stroke(),
        ctx.globalAlpha = 1
    }
    ,
    a
}
function renderParticule(e) {
    for (var t = 0; t < e.animatables.length; t++)
        e.animatables[t].target.draw()
}
function animateParticules(e, t) {
    for (var a = createCircle(e, t), n = [], i = 0; i < numberOfParticules; i++)
        n.push(createParticule(e, t));
    anime.timeline().add({
        targets: n,
        x: function(e) {
            return e.endPos.x
        },
        y: function(e) {
            return e.endPos.y
        },
        radius: .1,
        duration: anime.random(1200, 1800),
        easing: "easeOutExpo",
        update: renderParticule
    }).add({
        targets: a,
        radius: anime.random(80, 160),
        lineWidth: 0,
        alpha: {
            value: 0,
            easing: "linear",
            duration: anime.random(600, 800)
        },
        duration: anime.random(1200, 1800),
        easing: "easeOutExpo",
        update: renderParticule,
        offset: 0
    })
}
function debounce(e, t) {
    var a;
    return function() {
        var n = this
          , i = arguments;
        clearTimeout(a),
        a = setTimeout(function() {
            e.apply(n, i)
        }, t)
    }
}
var canvasEl = document.querySelector(".fireworks");
if (canvasEl) {
    var ctx = canvasEl.getContext("2d")
      , numberOfParticules = 30
      , pointerX = 0
      , pointerY = 0
      , tap = "mousedown"
      , colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"]
      , setCanvasSize = debounce(function() {
        canvasEl.width = 2 * window.innerWidth,
        canvasEl.height = 2 * window.innerHeight,
        canvasEl.style.width = window.innerWidth + "px",
        canvasEl.style.height = window.innerHeight + "px",
        canvasEl.getContext("2d").scale(2, 2)
    }, 500)
      , render = anime({
        duration: 1 / 0,
        update: function() {
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)
        }
    });
    document.addEventListener(tap, function(e) {
        "sidebar" !== e.target.id && "toggle-sidebar" !== e.target.id && "A" !== e.target.nodeName && "IMG" !== e.target.nodeName && (render.play(),
        updateCoords(e),
        animateParticules(pointerX, pointerY))
    }, !1),
    setCanvasSize(),
    window.addEventListener("resize", setCanvasSize, !1)
}
)
}

if (v == "es6 超简洁版Event事件模块") {
Var = 
(
class Event {
	constructor(props) {
	    this.map = {}
	}

	add (name, fn) {
		if (this.map[name])
			this.map[name].push(fn)
		else
			this.map[name] = [fn]
		return this
	}

	emit (name, ...args) {
		// 遍历数组中的所有函数并且执行，注入args
		this.map[name].forEach(_ => _(...args))
		// 返回prototype可以形成链式
		return this
	}
}

let e = new Event()
// 我们约定第一个参数是err信息，如果没有错误则注入null
e.add("hello", (err, name) => {
	if (err) return console.error(err)
	console.log(name)
})
.emit('hello', '发送错误')
.emit('hello', null, 'success')
)
}


if (v == "...args参数和fn(...args) 入参的技巧和认知") {
Var = 
(
emit (name, ...args) {
    // 遍历数组中的所有函数并且执行，注入args
    this.map[name].forEach(_ => _(...args))
    // 能形成链式
    return this
}
)
}

if (v == "多个异步操作时，请毫不犹豫用Pormise.all") {
Var = 
(
const getName = new Promise((resolve, reject) => {
   setTimeout(function () {
        resolve('success') // reject('fail')
   }, 50);
})
Promise.all([getName, getName])
	.then(console.log)
	.catch(console.log)
)
}

if (v == "对象字面量如何使用async/await标记") {
Var = 
(
// 其实很简单，最最前面加入即可。
async init ({ commit, state, dispatch, rootState })  {
    // 获取部门id列表（包含重映射部门id）
    await dispatch('getAllDepartmentItems')
    // 获取事项id列表（包含重映射事项id）
    await dispatch('getAllMatterItems')
},

// 如果是传统的也可以这样
init: async function  ({ commit, state, dispatch, rootState }) {
    // 获取部门id列表（包含重映射部门id）
    await dispatch('getAllDepartmentItems')
    // 获取事项id列表（包含重映射事项id）
    await dispatch('getAllMatterItems')
}
)
}


if (v == "获取localStorage剩余容量和最大容量") {
Var = 
(
// 获取localStorage最大容量
(function() {
   if(!window.localStorage) {
   console.log('当前浏览器不支持localStorage!')
   }    var test = '0123456789';
   var add = function(num) {
     num += num;
     if(num.length == 10240) {
       test = num;
       return;
     }
     add(num);
   }
   add(test);
   var sum = test;
   var show = setInterval(function(){
      sum += test;
      try {
       window.localStorage.removeItem('test');
       window.localStorage.setItem('test', sum);
       console.log(sum.length / 1024 + 'KB');
      } catch(e) {
       console.log(sum.length / 1024 + 'KB超出最大限制');
       clearInterval(show);
      }
   }, 0.1)
 })()
 
 
// 获取localStorage的剩余容量
(function(){
    if(!window.localStorage) {
        console.log('浏览器不支持localStorage');
    }
    var size = 0;
    for(item in window.localStorage) {
        if(window.localStorage.hasOwnProperty(item)) {
            size += window.localStorage.getItem(item).length;
        }
    }
    console.log('当前localStorage剩余容量为' + (size / 1024).toFixed(2) + 'KB');
})()
)
}

if (v == "memoized 函数缓存") {
SendLevel 1
Send, funcache{tab}
return
}

if (v == "是否隐藏：$('#div').is(':hidden')") {
Var = 
(
$('#div').is(':hidden')
)
}

if (v == "是否显示：$('#div').is(':visible')") {
Var = 
(
$('#div').is(':visible')
)
}

if (v == "clickOutSide：!el.contains(event.target)") {
Var = 
(
!el.contains(event.target)
)
}

if (v == "（回调版）单例模式，通常用于ajax类") {
Var = 
(
// （回调版）单例模式，通常用于ajax类
var getCallBackSingle = function(fn) {
    // 缓存
    var cache;
    // 接受一个回调函数
    return function (cb) {
        // 如果有缓存存在，那么直接使用缓存作为回调值，否则使用默认函数
        cache ? cb.apply(this, cache) : fn(function () {
            console.log('no cache')
            // 保存到缓存并且执行回调
            cb.apply(this, cache = arguments)
        })
    }
};

// demo：获取所有内容
var getData = function (successcb) {
    $.ajax({
        url: "/search.json",
        dataType: 'json',
        success: successcb,
        error: function(e, m){
           console.log('数据接口请求异常', e, m);
        }
    })
}

// 使用示例
var _getData = getCallBackSingle(getData)
_getData(_ => {console.log(20190126191340, _)}) // no cache，[...]
_getData(_ => {console.log(20190126191340, _)}) // [...]
)
}


if (v == "parseFloat可以直接移除字符串：parseFloat(layero.css('left')) // '162px' => 162") {
Var = 
(
dict.offset = [
    e.clientX - parseFloat(layero.css('left')),
    e.clientY - parseFloat(layero.css('top'))
;
)
}


if (v == "filterhtml: 移除html标签，只提取文本text()") {
SendLevel 1
Send, filterhtml{tab}
return
}

if (v == "window.onunload 刷新/关闭页面之前发送请求") {
SendLevel 1
Send, window.onunload{tab}
return
}

if (v == "js获取root（window）对象") {
Var = 
(
var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};
)
}


if (v == "高度从0到auto的伸缩特效魔法") {
Var =
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    .el {
        transition: max-height 0.5s;
        overflow: hidden;
        max-height: 0;
    }

    .trigger:hover>.el {
        max-height: var(--max-height);
    }
    </style>
</head>

<body>
    <div class="trigger">
        Hover me to see a height transition.
        <div class="el">content</div>
    </div>
</body>
<script>
var el = document.querySelector('.el')
var height = el.scrollHeight
el.style.setProperty('--max-height', height + 'px')
</script>

</html>
)
}

if (v == "获取前6个月/前15天数据") {
Var = 
(
/**
 * 生成日报模式下的 xAxisDate 数据，
 * 业务需求:  如果是日报（day）则是取前半个月的数据，即15条数据
 * @param {String} str 当前用户选择的日报时间
 * @param {Number} len 往前获取多少天？
 * @return {Array} 如：["20181211","20181210","20181209","20181208","20181207", "20181206","20181205","20181204","20181203","20181202", "20181201","20181130","20181129","20181128","20181127"] 
 */
getDayxAxisDate(str, len) {
    // 转化为date对象
    const _date = new Date(str.substring(0, 4), str.substring(4, 6) - 1, str.substring(6, 8))

    // 往前取半个月15天
    return [...Array(len)].map((v, index, array) => {
        // 不断地回退day
        _date.setDate(_date.getDate() - 1)
        // YYYYMMDD
        return _date.getFullYear() + PrefixInteger(_date.getMonth() + 1, 2) + PrefixInteger(_date.getDate(), 2)
        // 翻转一下顺序，让数组符合desc顺序的直觉
    }).reverse()
},

/**
 * 生成月报模式下的 xAxisDate 数据，
 * 业务需求:  如果是月报（month）则是取前半年的数据，即6条数据
 * @param {String} str 当前用户选择的月报时间
 * @param {Number} len 往前获取几个月？
 * @return {Array} 如： ["20181207","20181208","201809","201810","201811","201812"]
 */
getMonthxAxisDate(str, len) {
    // 转化为date对象
    const _date = new Date(str.substring(0, 4), str.substring(4, 6) - 1)
    // 往前取半年6个月
    return [...Array(len)].map((v, index, array) => {
        // 不断地回退month
        _date.setMonth(_date.getMonth() - 1)
        // MM
        return PrefixInteger(_date.getMonth() + 1) + '月'
        // 翻转一下顺序，让数组符合desc顺序的直觉
    }).reverse()
},
)
}




if (v == "获取手机归属地信息：中国移动/中国联通/中国电信") {
Var = 
(
/**
 * @func
 * @desc - 获取手机归属地信息
 * @param {string} phoneNo - 手机号码
 * @param {string} callback - 回调函数
 */
var getPhoneData = function(phoneNo, callback) {
    $.ajax({
        url: 'http://tcc.taobao.com/cc/json/mobile_tel_segment.htm',
        type: 'get',
        data: {
            tel: phoneNo
        },
        success: function(result) {
            if (result) {
                var _data = result.split('=')[1]
                _data = _data.replace(/\s+/g, "").replace(/<\/?.+?>/g, "").replace(/[\r\n]/g, "").replace(/\'/g, '"').replace(/\:/g, '":').replace(/\,/g, ',"').replace('{', '{"')
                var phoneData = JSON.parse(_data);
                console.log(phoneData)
                if (phoneData.catName === '中国移动') {
                    applyData.PhoneType = 1;
                } else if (phoneData.catName === '中国联通') {
                    applyData.PhoneType = 2
                } else if (phoneData.catName === '中国电信') {
                    applyData.PhoneType = 3
                } else {
                    applyData.PhoneType = 0
                }
                applyData.PhoneAddress = phoneData.province
            }
        },
        error: function(result) {
            console.info('无法获取手机归属地信息');
        },
        complete: function() {
            typeof callback === 'function' && submitApply();
        }
    })
}

)
}

if (v == "闭包与Cache") {
Var = 
(
/**
 * @func
 * @desc - 灵活使用闭包的概念。
           以下简单的实验说明他们是不同的实例。所以他们各自闭包内的_cache是不相干也不相同的
           其实是简单的类与实例的概念。但还是说明一下比较好
           毕竟大部分的插件也是这样制作的
 */
var Cache = (function () {
    var _cache = {};

    return {
      getCache: function (key) {
        return _cache[key]
      },
      setCache: function (key, value) {
        _cache[key] = value;
      },
      showAllCache: function () {
        console.log(_cache);
      }
    }
});


var a = new Cache();
a.setCache('foo', 'bar');
a.showAllCache();

var b = new Cache();
b.setCache('foo', 'bar2');
b.showAllCache();

/* 从输出的结果得知两者的闭包互不相干 */
)
}

if (v == "Android 输入法键盘 和 input 问题:scrollIntoViewIfNeeded") {
Var = 
(
/**
 * Android 输入法键盘 和 input 问题
 */
if(getSys() === 'Android') {
    window.addEventListener("resize", function() {
        if(document.activeElement.tagName=="INPUT" || document.activeElement.tagName=="TEXTAREA") {
           window.setTimeout(function() {
                document.activeElement.scrollIntoViewIfNeeded();
           }, 0);
       }
    })
}
)
}


if (v == "优惠券条件分支：链式after解决方案") {
Var = 
(
Function.prototype.after = function(fn) {
    var self = this;
    return function() {
        var ret = self.apply(this, arguments);  
        if (ret === 'next') {
            return fn.apply(this.arguments);
        }
    }
}

var order500yuan = function(orderType, pay, stock) {
    if (orderType === 1 && pay === true) {
        console.log('500 元定金预购，得到 100 优惠券');
    } else {
        return 'next'; // 我不知道下一个节点是谁，反正把请求往后面传递
    }
};

var order200yuan = function(orderType, pay, stock) {
    if (orderType === 2 && pay === true) {
        console.log('200 元定金预购，得到 50 优惠券');
    } else {
        return 'next'; // 我不知道下一个节点是谁，反正把请求往后面传递
    }
};

var orderNormal = function(orderType, pay, stock) {
    if (stock > 0) {
        console.log('普通购买，无优惠券');
    } else {
        console.log('手机库存不足');
    }
};

var order = order500yuan.after( order200yuan ).after( orderNormal );
order( 1, true, 500 )
order( 2, true, 500 );
order( 1, false, 500 );
)
}

if (v == "Function.prototype.before") {
SendLevel 1
Send, fn.before{tab}
return
}

if (v == "Function.prototype.after") {
SendLevel 1
Send, fn.after{tab}
return
}

if (v == "抽象类接口：咖啡与茶") {
Var = 
(
// 继承抽象类的目的，通常是可以为了可以省略很多重复的操作，或者帮你完成了很多基础工作，譬如本例的煮水（boilWater）
// 但接口还强制你重写/实现/覆盖指定方法譬如brew, pourIncup, addCondiments来搜集配置和个性化需求。
// 这种模式也成为模板模式。可以脑补【模板页面】的场景
var Beverage = function() {};
Beverage.prototype.boilWater = function() {
	console.log( '把水煮沸' );
};
Beverage.prototype.brew = function() {
	throw new Error( '子类必须重写 brew 方法' );
};
Beverage.prototype.pourIncup = function() {
	throw new Error( '子类必须重写 pourIncup 方法' );
};
Beverage.prototype.addCondiments = function() {
	throw new Error( '子类必须重写 addCondiments 方法' );
};
Beverage.prototype.init = function() {
    this.boilWater();
    this.bubbleBeverage();
    this.pourCup();
    this.addCondiments();
};

var Coffee = function() {};
// 原型继承抽象类
Coffee.prototype = new Beverage();

Coffee.prototype.bubbleBeverage = function() {
    console.log("开水冲泡咖啡.");
};
Coffee.prototype.pourCup = function() {
    console.log("咖啡倒入杯中.");
};
Coffee.prototype.addCondiments = function() {
    console.log("添加糖和牛奶.");
};

var coffee = new Coffee();
coffee.init();
)
}

if (v == "解构与split结合：const [language, country] = locale.split('-')") {
Var = 
(
const [language, country] = locale.split('-')
)
}

if (v == "模块模式：现代模块实现的基石") {
Var = 
(
var Module = (function($){
    var _$body = $("body");     // we can use jQuery now!
    var foo = function(){
        console.log(_$body);    // 特权方法
    }

    // Revelation Pattern
    return {
        foo: foo
    }
})(jQuery)

Module.foo();
)
}

if (v == "社会主义点击事件") {
Var = 
(
(function() {
    var coreSocialistValues = ["富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"]
      , index = Math.floor(Math.random() * coreSocialistValues.length);
    document.body.addEventListener('click', function(e) {
        if (e.target.tagName == 'A') {
            return;
        }
        var x = e.pageX
          , y = e.pageY
          , span = document.createElement('span');
        span.textContent = coreSocialistValues[index];
        index = (index + 1) `% coreSocialistValues.length;
        span.style.cssText = ['z-index: 9999999; position: absolute; font-weight: bold; color: #ff6651; top: ', y - 20, 'px; left: ', x, 'px;'].join('');
        document.body.appendChild(span);
        animate(span);
    });
    function animate(el) {
        var i = 0
          , top = parseInt(el.style.top)
          , id = setInterval(frame, 16.7);
        function frame() {
            if (i > 180) {
                clearInterval(id);
                el.parentNode.removeChild(el);
            } else {
                i += 2;
                el.style.top = top - i + 'px';
                el.style.opacity = (180 - i) / 180;
            }
        }
    }
}());
)
}

if (v == "urlparams 获取路由参数") {
SendLevel 1
Send, urlparams{tab}
return
}

if (v == "构造器借用") {
Var = 
(
function Shape(id) {
  this.id = id;
}
Shape.prototype.name = 'shape'
Shape.prototype.toString = function () {
  return this.name
}

function Triangle() {
  Shape.apply(this, arguments)
}
Triangle.prototype.name = 'Triangle'

var t = new Triangle(101);
t.name; // "Triangle"
)
}

if (v == "寄生式继承") {
Var = 
(
// 在创建对象的函数中直接吸收其他对象的功能，然后对其进行扩展并返回。“就好像所有的工作都是自己做的一样无耻！”
// 寄生式继承并没有涉及什么新的模式和语法，只是一种概念认知。
var twoD = {
  name: '2D shape',
  dimensions: 2
}

function triangle(s, h) {
  var that = Object(twoD);
  that.name = 'TRIANGLE';
  that.side = s;
  that.height = h;
  that.getArea = function () {
    return this.side * this.height / 2;
  };
  return that;
}

var t = triangle(5, 10);
t.dimensions; // 2
)
}

if (v == "multi 多重拷贝") {
Var = 
(
function multi() {
  var n = {}, stuff, j = 0, len = arguments.length;
  for (var i = 0; i < len; i++) {
      stuff = arguments[j];
      for (var i in stuff) {
        if (stuff hasOwnProperty(i)) {
          n[i] = stuff[i];
        }
      }
  }
  return n
}
)
}

if (v == "通用的惰性单例") {
Var = 
(
var getSingle = function(fn) {
     var result;
     return function() {
         return result || (result = fn.apply(this, arguments));
     }
};
)
}


if (v == "惰性单例") {
Var = 
(
var Singleton = function(name) {
     this.name = name;
};
Singleton.getInstance = (function() {
     var instance = null;
     return function(name) {
         if (!instance) {
             instance = new Singleton(name);
         }
         return instance;
     }
})();
var a = Singleton.getInstance( 'sven1' );
var b = Singleton.getInstance( 'sven2' );
alert ( a === b ); // true
)
}

if (v == "透明单例") {
Var = 
(
var CreateDiv = (function() {
     var instance;
     var _CreateDiv = function(html) {
         if (instance) {
             return instance;
         }
         this.html = html;
         this.init();
         return instance = this;
     };
     _CreateDiv.prototype.init = function() {
         var div = document.createElement('div');
         div.innerHTML = this.html;
         document.body.appendChild(div);
     };
     return _CreateDiv;
})();

var a = new CreateDiv('sven1');
var b = new CreateDiv('sven2');
alert(a === b); // => true
)
}

if (v == "代理单例") {
Var = 
(
// 普通的创建 div 的类：
var CreateDiv = function(html) {
     this.html = html;
     this.init();
};
CreateDiv.prototype.init = function() {
     var div = document.createElement('div');
     div.innerHTML = this.html;
     document.body.appendChild(div);
};
// 引入代理类
var ProxySingletonCreateDiv = (function() {
    var instance;
    return function(html) {
        if (!instance) {
            instance = new CreateDiv(html);
        }
        return instance;
    }
})();
var a = new ProxySingletonCreateDiv('sven1');
var b = new ProxySingletonCreateDiv('sven2');
alert(a === b);
)
}

if (v == "封装") {
Var = 
(
// JavaScript并没有提供private、public、protected 关键字来提供不同的访问权限，我们只能依赖变量的 作用域来实现封装特性
var Module = (function(){
    var _private = "safe now";
    var foo = function(){
        console.log(_private)
    }

    return {
        foo: foo
    }
})()

Module.foo();    // "safe now"
Module._private; // undefined
)
}


if (v == "多态") {
Var = 
(
var makeSound = function(animal) {
    if (animal instanceof Duck) {
        console.log('嘎嘎嘎');
    } else if (animal instanceof Chicken) {
        console.log('咯咯咯');
    }
};
var Duck = function() {};
var Chicken = function() {};
makeSound(new Duck());    // 嘎嘎嘎
makeSound(new Chicken()); // 咯咯咯

//////////////////////////////////////////////
// 
//////////////////////////////////////////////
var renderMap = function( map ){
  if ( map.show instanceof Function ){
     map.show();
  }
};
renderMap( googleMap ); // 输出：开始渲染谷歌地图
renderMap( baiduMap );  // 输出：开始渲染百度地图

// 即使以后增加了搜搜地图， renderMap 函数仍、然不需要做任何改变，如下所示：
var sosoMap = {
  show: function(){
     console.log( '开始渲染搜搜地图' );
  }
};
renderMap( sosoMap ); // 输出：开始渲染搜搜地图
)
}


if (v == "基于原型模式的继承") {
Var = 
(
var A = function(){};
var B = function(){};
A.prototype = { name: 'sven' };

// 核心
B.prototype = new A();
var b = new B();
console.log( b.name ); // 输出：sven
)
}


if (v == "call 和 apply") {
Var = 
(
)
}


if (v == "AOP - 面向切面编程") {
Var = 
(
// （A）定义原始函数
var func = function() {
    console.log(2);
};

Function.prototype.before = function(beforefn) {
    // 保存原始函数（A）的引用
    var __self = this;

    // （B）
    return function() { 
        // 执行 before 函数
        beforefn.apply(this, arguments); 

        // 执行原始函数（A）
        return __self.apply(this, arguments);
    }
};

Function.prototype.after = function(afterfn) {
    // 保存函数（B）的引用
    var __self = this;

    // （C）
    return function() {
        // 执行函数（B）并获取执行结果，而实际上函数（B）的返回的是原始函数（A）的执行结果
        var ret = __self.apply(this, arguments);

        // 执行 after 函数
        afterfn.apply(this, arguments);

        // 返回原函数（A）的执行结果
        return ret;
    }
};

func = func.before(function() {
    console.log(1);
}).after(function() {
    console.log(3);
});

// 执行函数（C）
func();
)
}



if (v == "1、作为对象的方法调用") {
Var = 
(
var obj = {
     a: 1,
     getA: function(){
        alert ( this === obj ); // 输出：true
        alert ( this.a );       // 输出: 1
     }
};
obj.getA();
)
}

if (v == "2、作为普通函数调用时") {
Var = 
(
//////////////////////////////////////////////
// 当函数作为普通函数方式被调用时，此时的 this 总是指向全局对象。
// 如果是在浏览器里，全局对象就是 window。
//////////////////////////////////////////////
window.name = 'windowName';
var getName = function () {
     return this.name;
};
console.log( getName() ); // windowName

// 以下写法和（1）很相似，所以容易混淆，但实际上这种调用函数的方式和（2）也是一样的道理，它指向的是函数执行时的环境，所以需要额外注意一下：
window.name = 'windowName';
var myObject = {
     name: 'sven',
     getName: function(){
        return this.name;
     }
};
var getName = myObject.getName;
console.log( getName() ); // windowName
)
}

if (v == "3、作为构造器调用") {
Var = 
(
//////////////////////////////////////////////
// JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。
// 所有 JavaScript 函数都可以当作构造器使用。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象。
//////////////////////////////////////////////
var MyClass = function(){
     this.name = 'sven';
};
var obj = new MyClass();
alert ( obj.name ); // 输出：sven
)
}


if (v == "4、Function.prototype.call 或 Function.prototype.apply 调用") {
Var = 
(
window.name = 'foo';
var obj1 = {name: 'sven'};
var obj2 = {name: 'anne'};

var getName = function () {
    alert ( this.name );
};
getName();            // 输出: foo
getName.call( obj1 ); // 输出: sven
getName.call( obj2 ); // 输出: anne
)
}


if (v == "6、es6 class 中的") {
Var = 
(

)
}

if (v == "5、es6箭头函数调用时") {
Var = 
(
// 箭头函数自己没有this，只能往上找对象。


// 不适用场合
var fuck = {
	bb: 'bb',
	methods: () =>  {
		console.log(this.bb) // undefined
	}
}
)
}

if (v == "JavaScript版 策略模式") {
SendLevel 1
Send, celue{tab}
return
}


if (v == "加强版map遍历:bettermap") {
SendLevel 1
Send, fuckmap{tab}
return
}

if (v == "injectCss 往页面插入style") {
SendLevel 1
Send, addstyle{tab}
return
}


if (v == "getScriptPath") {
Var = 
(
// http://stackoverflow.com/questions/2161159/get-script-path
function getScriptPath() {
    var scripts = _doc.currentScript || (function () { var s = _doc.getElementsByTagName('script'); return (s.length) ? s[s.length - 1] : false; })();
    var path = scripts ? scripts.src.split('?')[0] : '';
    return (path.split('/').length > 0) ? path.split('/').slice(0, -1).join('/') + '/' : '';
}
)
}


if (v == "处理iOS 微信客户端6.7.4 键盘收起页面未下移bug") {
Var = 
(
/**
 * 处理iOS 微信客户端6.7.4 键盘收起页面未下移bug
 */
;(/iphone|ipod|ipad/i.test(navigator.appVersion)) && document.addEventListener('blur', (e) => {
    // 这里加了个类型判断，因为a等元素也会触发blur事件
    ['input', 'textarea'].includes(e.target.localName) && document.body.scrollIntoView(false)
}, true)
)
}

if (v == "holder占位图") {
Var = 
(
<script src="https://cdn.bootcss.com/holder/2.9.6/holder.min.js"></script>
<img class="card-img-top" data-src="holder.js/100px225?theme=thumb&bg=55595c&fg=eceeef&text=Thumbnail" alt="Card image cap">
)
}

if (v == "dragscroll 拖拽滚动") {
Var = 
(
export const dragScroll = el => {
    var _window = window
        ,_document = document
        ,mousemove = 'mousemove'
        ,mouseup = 'mouseup'
        ,mousedown = 'mousedown'
        ,EventListener = 'EventListener'
        ,addEventListener = 'add'+EventListener
        ,removeEventListener = 'remove'+EventListener
        ,newScrollX, newScrollY;

    // HERE
    var startx,starty, endx, endy;


    return (function(el, lastClientX, lastClientY, pushed, scroller, cont) {
        (cont = el.container || el)[addEventListener](
            mousedown,
            cont.md = function(e) {
                if (!el.hasAttribute('nochilddrag') ||
                    _document.elementFromPoint(
                        e.pageX, e.pageY
                    `) == cont
                `) {
                    pushed = 1;
                    startx = lastClientX = e.clientX;
                    starty = lastClientY = e.clientY;

                    e.preventDefault();
                }
            }, 0
        `);

        el[addEventListener](
            mouseup, cont.mu = function(e) { 
                pushed = 0;  
                // HERE
                endx = e.clientX;
                endy = e.clientY;
                // setTimeout(function(){ el.classList.remove("dragging"); }, 100);
            }, 0
        `);

        el[addEventListener](
            mousemove,
            cont.mm = function(e) {
                if (pushed) {
                    // HERE
                    // el.classList.add("dragging");
                    (scroller = el.scroller || el).scrollLeft -= newScrollX = (-lastClientX + (lastClientX = e.clientX));
                    scroller.scrollTop -= newScrollY = (-lastClientY + (lastClientY = e.clientY));
                    if (el == _document.body) {
                        (scroller = _document.documentElement).scrollLeft -= newScrollX;
                        scroller.scrollTop -= newScrollY;
                    }
                }

            }, 0
        `)

        return function (CLICKHANDLER) {
            if (Math.abs(starty - endy) <= 1) {
                CLICKHANDLER && CLICKHANDLER(el)
            }
        }
    })(el);
}
)
}

if (v == "$.scrollforevery 无缝滚动") {
Var = 
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/dragscroll/0.0.8/dragscroll.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nicescroll/3.7.6/jquery.nicescroll.min.js"></script>
    <script>
    </script>
    <style>
    html,
    body {
        margin: 0;
        padding: 0;
    }

    *,
    ::after,
    ::before {
        box-sizing: border-box;
    }

    #app {
        height: 200px;
        background: thin;
        width: 200px;
        overflow: scroll;
        cursor: move;
    }

    p {
        height: 40px;
        margin: 0;
        padding: 0;
    }
    </style>
</head>
<body>
    <div id="app" class='dragscroll'>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
    </div>
</body>
<script>
const $app = $('#app')
const innerHeight = 40
const len = 5
const distance = innerHeight * len
let timer = null
const start = () => {
 timer = setInterval(function() {
     const scrollDistance = $app.scrollTop();
     if (scrollDistance >= distance) {
         $app.scrollTop(0)
     } else {
         $app.scrollTop(scrollDistance + 1)
     }
 }, 10);
}

start()

$('#app').niceScroll({ cursorcolor: 'rgba(0,0,0,0.2)', autohidemode: 'hidden' })

$('#app').mouseover(e => {
    clearInterval(timer);
}).mouseleave(e => {
    start()
})
</script>

</html>
)
}

if (v == "$.autoscroll 自动滚动") {
Var = 
(
$.fn.extend({
    'autoScroll': function (options) {
	    // 配置参数
	    var opt = $.extend({}, {speed: 1500, size: 4, height: 40, time: 10000}, options)
	    // jQuery对象
	    var $el = this;
	    // 时间器
	    var timer = null;
	    // 核心函数
	    var _autoScroll = function () {
	        // 自动滚动
	        timer =  setInterval(function () {
	            // 滚动的速度
	            const speed = opt.speed
	            // 每次滚动多少条
	            const size = opt.size;
	            // 每条的高度是多少
	            const height = opt.height;
	            // 每次滚动的距离
	            const distance = size * height;
	            // 当前滚动的高度
	            const currentScrollTop = $el.scrollTop()
	            // 底部位置
	            const bottom = $el.prop('scrollHeight') - $el.height()
	            // 如果已经滚到底了
	            if (Math.floor(currentScrollTop) === Math.floor(bottom)) {
	                // 滚回头部
                    // $el.animate({ scrollTop: 0 }, 0).animate({ scrollTop: distance + 'px' }, speed);
                    // 滚回头部
                    $el.animate({ scrollTop: 0 }, speed);
	            } else {
	                // 余数
	                const remainder = currentScrollTop `% height
	                // 下一次滚动的位置 = 当前位置 + 每次滚动的位置 - 余数
	                const nextScrollTop = currentScrollTop + distance - remainder
	                // 开始滚动
	                $el.animate({ scrollTop: nextScrollTop + 'px' }, speed);
	            }
	        // 滚动间隔
	        }, opt.time + opt.speed);
	        // 鼠标移入的时候，删除自动滚动, 鼠标移出的时候，自动滚动
	        $el.one('mouseover', function () { clearInterval(timer)}).one('mouseleave', _autoScroll)
	        // 将timer放入jQuery对象的缓存中，方便后续操作
	        $el.data('timer', timer)
	    }
	    // 开始滚动
	    _autoScroll()
	    // 返回时间器，方便后续操作
	    return timer
	},
	'stopScroll': function () {
	     // jQuery对象
	    var $el = this;
	    // 时间器
	    var timer = $el.data('timer')
	    // 消除它就是停止它（其实这里还需要结束动画，但就不做那么麻烦了）
	    clearInterval(timer);
	}
});

$('.trajectoryTable').autoScroll()
)
}

if (v == "window.requestAnimFrame") {
SendLevel 1
Send, requestanimate{tab}
return
}

if (v == "encodeURI URI过滤") {
Var = 
(
encodeURI
)
}

if (v == "deepfind 深度递归搜索") {
Var = 
(
var fuck = [
    {
        "label": "占用道路问题",
        "value": 31,
        "children": [
            {
                "label": "经营占道",
                "value": 35,
                "children": [
                    {
                        "label": "店外经营占道",
                        "value": 40,
                        "children": null
                    },
                    {
                        "label": "流动摊贩占道",
                        "value": 41,
                        "children": null
                    }
                ]
            },
            {
                "label": "垃圾占道",
                "value": 36,
                "children": [
                    {
                        "label": "生活垃圾",
                        "value": 42,
                        "children": null
                    },
                    {
                        "label": "建筑垃圾",
                        "value": 43,
                        "children": null
                    },
                    {
                        "label": "工业垃圾",
                        "value": 44,
                        "children": null
                    }
                ]
            },
            {
                "label": "车辆占道",
                "value": 37,
                "children": [
                    {
                        "label": "机动车占道",
                        "value": 45,
                        "children": null
                    },
                    {
                        "label": "非机动车占道",
                        "value": 46,
                        "children": null
                    }
                ]
            },
            {
                "label": "霸占车位",
                "value": 38,
                "children": []
            },
            {
                "label": "其他占道",
                "value": 39,
                "children": []
            }
        ]
    },
    {
        "label": "“两违”问题",
        "value": 32,
        "children": [
            {
                "label": "违法建筑",
                "value": 58,
                "children": [
                    {
                        "label": "房屋违建",
                        "value": 61,
                        "children": null
                    },
                    {
                        "label": "小区违建",
                        "value": 62,
                        "children": null
                    },
                    {
                        "label": "违建棚架",
                        "value": 63,
                        "children": null
                    }
                ]
            },
            {
                "label": "违法用地",
                "value": 59,
                "children": []
            },
            {
                "label": "其他违建",
                "value": 60,
                "children": []
            }
        ]
    },
    {
        "label": "市容设施管理问题",
        "value": 33,
        "children": [
            {
                "label": "道路损坏",
                "value": 47,
                "children": []
            },
            {
                "label": "垃圾桶损坏",
                "value": 48,
                "children": []
            },
            {
                "label": "下水道堵塞",
                "value": 49,
                "children": []
            },
            {
                "label": "井盖损坏",
                "value": 50,
                "children": []
            },
            {
                "label": "路灯损坏",
                "value": 51,
                "children": []
            },
            {
                "label": "树木修剪",
                "value": 52,
                "children": []
            },
            {
                "label": "水电气",
                "value": 53,
                "children": []
            },
            {
                "label": "户外广告牌",
                "value": 54,
                "children": []
            },
            {
                "label": "隔音屏损坏",
                "value": 55,
                "children": []
            },
            {
                "label": "洒水车问题",
                "value": 56,
                "children": []
            },
            {
                "label": "其他",
                "value": 57,
                "children": []
            }
        ]
    },
    {
        "label": "其他问题",
        "value": 34,
        "children": []
    }
]
const deepFind = ({ arr = [], key = '', val = '', children = 'children'} = {}) => {
    // 即将返回的数组
    var main = []
    // 如果没有键也没有值，那么还是直接返回吧
    if (!val || !key) return main
    // 用try方案方便直接中止所有递归的程序
    try {
        // 开始轮询
        (function poll(arr, level) {
            // 如果传入非数组
            if (!Array.isArray(arr)) return
            // 遍历数组
            for (var i = 0; i < arr.length; i++) {
                // 获取当前项
                var item = arr[i]
                // 先占位预设值
                main[level] = item[key]
                // 如果已经找到了
                if (item[key] === val) {
                    // 直接抛出错误中断所有由父及子的所有轮询
                    throw Error
                // 如果存在children，那么深入递归
                } else if (item[children] && item[children].length) {
                    poll(item[children], level + 1)
                // 如果是最后一个了且没有找到值，那么删除之
                } else if (i === arr.length - 1) {
                   // 删除占位预设值
                   main.length = main.length - 1
                }
            }
        })(arr, 0)
    // 错误捕捉仅为程序正常执行
    } catch (err) {}

    // 返回最终数组
    return main
}
var myarr = deepFind({ arr: fuck, key: 'value', val: 63, children: 'children' })
console.log(20181115092957, myarr)
)
}


if (v == "compose 函数组合") {
Var = 
(
function compose () {
	let args = arguments
	let start = args.length - 1

	return function () {
		let i = start
		let result = args[start].apply(this, arguments)
		while (i--)
			result = args[i].call(this, result)
		return result
	}
}

const explode = _ => _.split(/\s+/)
const count = _ => _.length
const countWords = compose(count, explode);
countWords(``a
			b
			c
			d``); // => 4
)
}


if (v == "(〜￣△￣)〜认知～(￣▽￣～)：({a = 123, b = 321, c = 456} = {}) 对象解构 与 参数默认值") {
Var =
(
var abc = ({a = 123, b = 321, c = 456} = {}) => console.log(20181109155055, a)
abc()
)
}

if (v == "Object.assign({}, )") {
Var =
(
Object.assign({}, )
)
}
if (v == "Object.is 比 === 更严格的比较") {
Var =
(
0 === -0 // true
NaN === NaN // false（这也是NaN的特性）

Object.is(0, -0) // false
Object.is(NaN, NaN) // true
)
}

if (v == "'tail' in cat / cat.hasOwnProperty('tail') 判断对象是否包含某属性") {
Var =
(
'tail' in cat
cat.hasOwnProperty('tail')
)
}
if (v == "Object.getOwnPropertyDescriptor({a: 123}, 'a') 获取属性的配置") {
Var =
(
// {value: 123, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({a: 123}, "a")
)
}
if (v == "Object.defineProperty 属性的权限设置 writable（可写） / configurable（可配置）/enumerable（可枚举）") {
Var =
(
var myObject = {};

Object.defineProperty(myObject, "a", {
  value: 2,
  writable: true,  // 可写
  configurable: true, // 可配置
  enumerable: true  // 可枚举
});

myObject.a // 2
)
}
if (v == "Object.defineProperties 属性的批量权限设置") {
Var =
(

)
}

if (v == "getter / setter") {
Var =
(

)
}

if (v == "delete person.age 删除对象的属性") {
Var =
(
delete person.age
)
}

if (v == "__EVENT__消息订阅") {
Var = 
(
window.__EVENT__ = {
     // 缓存列表
     clientList: [],
     listen: function(key, fn) {
         if (!this.clientList[key]) {
             this.clientList[key] = [];
         }
         // 订阅的消息添加进缓存列表
         this.clientList[key].push(fn);
     },
     trigger: function() {
         var key = Array.prototype.shift.call(arguments),
             fns = this.clientList[key];
         // 如果没有绑定对应的消息
         if (!fns || fns.length === 0) {
             return false;
         }
         for (var i = 0, fn; fn = fns[i++];) {
             // arguments 是 trigger 时带上的参数
             fn.apply(this, arguments);
         }
     },
     remove: function(key, fn) {
         var fns = this.clientList[key];
         if (!fns) { // 如果 key 对应的消息没有被人订阅，则直接返回
             return false;
         }
         if (!fn) { // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅
             fns && (fns.length = 0);
         } else {
             for (var l = fns.length - 1; l >= 0; l--) { // 反向遍历订阅的回调函数列表
                 var _fn = fns[l];
                 if (_fn === fn) {
                     fns.splice(l, 1); // 删除订阅者的回调函数
                 }
             }
         }
    }
};
)
}

if (v == "cache request axios 缓存请求") {
Var = 
(
// 检查状态码
const checkStatus = (response) => {
	// 判断请求状态
    if (response.status >= 200 && response.status < 300) {
        // 返回Promise 
        return response.data
    } else {
      // 服务器响应异常
      throw new Error(response.statusText)
    }
}

// 缓存到sessionStorage
const cachedSave = (hashcode, content) => {
  // 设置缓存
  sessionStorage.setItem(hashcode, JSON.stringify(content))
  // 设置缓存时间
  sessionStorage.setItem(`${hashcode}:timestamp`, Date.now())
  // 返回Promise
  return content
}

// 公共请求
export const request = (url, options) => {
    // 指纹
    const fingerprint = url + (options ? JSON.stringify(options) : '')
    // 加密指纹
    const hashcode = hash.sha256().update(fingerprint).digest('hex')
    // 预设值指纹
    const _cachedSave = cachedSave.bind(null, hashcode)
    // 过期设置
    const expirys = options && options.expirys || 60
    // 本请求是否禁止缓存？
    if (expirys !== false) {
        // 获取缓存
        const cached = sessionStorage.getItem(hashcode)
        // 获取该缓存的时间
        const whenCached = sessionStorage.getItem(`${hashcode}:timestamp`)
        // 如果缓存都存在
        if (cached !== null && whenCached !== null) {
          // 判断缓存是否过期
          const age = (Date.now() - whenCached) / 1000
          // 如果不过期的话直接返回该内容
          if (age < expirys) {
              // 新建一个response
              const response = new Response(new Blob([cached]))
              // 返回promise式的缓存
              return new Promise((resolve, reject) => resolve(response.json()))
          }
          // 删除缓存内容
          sessionStorage.removeItem(hashcode)
          // 删除缓存时间
          sessionStorage.removeItem(`${hashcode}:timestamp`)
        }
    }
    return axios(url, options).then(checkStatus).then(_cachedSave)
}
)
}

if (v == "AMD/CommonJS/factory/module") {
Var = 
(
(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['exports', 'echarts'], factory);
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports, require('echarts'));
    } else {
        // Browser globals
        factory({}, root.echarts);
    }
}(this, function(exports, echarts) {
    if (!echarts) {
        log('ECharts is not Loaded');
        return;
    }
}));

;(function (root, factory) {
  if (typeof exports === "object") {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define([], factory);
  } else {
    root.FUCKYOU = factory();
  }
}(this,function () {
　　// ...  这里编写你的代码
　　return {
      
   };
});
)
}

if (v == "JSON.parse(JSON.stringify(...)) 超简易拷贝") {
Var = 
(
JSON.parse(JSON.stringify(...))
)
}

if (v == "setattr") {
Var = 
(
el.setAttribute('tabindex', 3);
)
}

if (v == "removeattr") {
Var = 
(
document.querySelector('.fuck').removeAttribute('disabled');
)
}


if (v == "onscript/loadscript 加载脚本并等待加载完成") {
Var = 
(
/**
 * 加载script并且执行回调
 * @param {String} url 资源地址
 * @param {Function} cb 回调方法
 * https://www.cnblogs.com/_franky/archive/2010/06/20/1761370.html
 */
var onscriptload = function (url, cb) {
  var node = document.createElement("script")
  var head = document.getElementsByTagName('head')[0]
  var timeID
  var supportLoad = "onload" in node
  var onEvent = supportLoad ? "onload" : "onreadystatechange"
  node[onEvent] = function onLoad() {
      if (!supportLoad && !timeID && /complete|loaded/.test(node.readyState)) {
          timeID = setTimeout(onLoad)
          return
      }
      if (supportLoad || timeID) {
          clearTimeout(timeID)
          cb && cb()
      }
  }
  head.insertBefore(node, head.firstChild)
  node.src = url
}

onscriptload('https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js', function () {
   console.log(jQuery.fn.jquery);
   console.log($('*').size())
})

)
}

if (v == "isNodeList") {
Var = 
(
Object.prototype.toString.call(v) === '[object NodeList]'
)
}

if (v == "is") {
Var = 
(
// 仿ramda: https://github.com/ramda/ramda/blob/master/source/is.js
const is = (type, val) => {
	return val != null && val.constructor === type || val instanceof type;
}

is(String, '123')     // => true
is(Number, 123)       // => true
is(Date, new Date())  // => true
is(Object, {})        // => true
is(Array, [])         // => true
)
}

if (v == "curry2 二元参数的手动柯里化") {
Var = 
(
// 二元参数的手动柯里化
function curry2(fn) {
	return function(firstArg){
		return function (secondArg) {
			return fn(firstArg, secondArg)
		}
	}
}
)
}

if (v == "es6.class") {
SendLevel 1
Send, js.class{tab}
return
}

if (v == "for-- 循环中splice需要使用") {
Var = 
(
var Things = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
var arr = []
for (var i = Things.length - 1; i >= 0; i--) {
	if (Things[i] `% 2 === 0) {
		arr.push(...Things.splice(i, 1))
		console.log(Things, arr)
	}
}
)
}



if (v == "Model 类") {
Var = 
(
import { getUUID } from '@/utils/utils.js'

export default class Model {
	constructor ({ size = 20 } = {}) {
		// 核心数据
		this.data = null
		// token
		this.token = ''
		// 是否加载中
		this.loading = false
		// 是否数据为空
		this.empty = false
		// 是否正在加载更多
		this.loadingmore = false
		// 是否没有更多了
		this.nomore = false
		// 总数
		this.total = 0
		// 页码
		this.page = 0
		// 数量
		this.size = this._size = size
		// 是否报错了
		this.error = ''
	}

	// 重置
  resetWhere () {
	  this.token = ''
	  this.loading = false
	  this.empty = false
	  this.loadingmore = false
	  this.nomore = false
	  this.total = 0
	  this.page = 0
	  this.size = this._size
	  this.error = ''
  }

  // 显示loading并且返回token
  showLoading () {
    this.loading = true
  }

  // 显示loadingmore并且返回token
  showLoadingmore () {
    this.loadingmore = true
  }

  // 隐藏loading
  hideLoading () {
    this.loading = false
  }

  // 隐藏Loadingmore
  hideLoadingmore () {
    this.loadingmore = false
  }

  // 页码++
  pagePlus () {
	  this.page++
  }

  // 是否是第一次加载
  isFirstPage () {
    return this.page === 0
  }

  // 刷新token并且返回token
  refreshToken () {
    return this.token = getUUID()
  }

  // 设置data以及一系列逻辑
  setData ({ data = [], total = 0, token = ''} = {}, cb = null) {
    // 如果token不一致，说明请求被覆盖了。应该中止逻辑演变
    if (token && this.token != token) return

    this.total = total
    this.loading = false
    this.loadingmore = false

    const isEmptyData = data.length === 0

    // empty 表示没有数据
    if (this.isFirstPage() && isEmptyData)
      this.empty = true

    // nomore 表示没有更多数据
    if (data.length < this.size || (!this.isFirstPage() && isEmptyData))
      this.nomore = true

    // 如果有数据，应该重置标识
    if (!isEmptyData) {
      this.empty = false
      // 就算有数据，如果不够长度，也是数据nomore
      if (data.length === this.size)
        this.nomore = false
    }

    if (this.isFirstPage())
      this.data = data
    else
      this.data = Array.prototype.concat.call(this.data || [], data)

    // 执行回调
    cb && cb(this)
  }
}
)
}

if (v == "scrollIntoView 滚动到元素可视区域") {
Var = 
(
document.querySelector(".loadingmore").scrollIntoView();
)
}

if (v == "throttle 函数节流") {
Var = 
(

// 函数节流（throttle）
var throttle = function(func, wait, options) {
  var timeout, context, args, result;
  // 标记时间戳
  var previous = 0;
  // options可选属性 leading: true/false 表示第一次事件马上触发回调/等待wait时间后触发
  // options可选属性 trailing: true/false 表示最后一次回调触发/最后一次回调不触发
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : +(new Date());
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    // 记录当前时间戳
    var now = +(new Date());
    // 如果是第一次触发且选项设置不立即执行回调
    if (!previous && options.leading === false)
    // 将记录的上次执行的时间戳置为当前
    previous = now;
    // 距离下次触发回调还需等待的时间
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;

    // 等待时间 <= 0或者不科学地 > wait（异常情况）
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
          // 清除定时器
        clearTimeout(timeout);
        // 解除引用
        timeout = null;
      }
      // 将记录的上次执行的时间戳置为当前
      previous = now;

      // 触发回调
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    }
    // 在定时器不存在且选项设置最后一次触发需要执行回调的情况下
    // 设置定时器，间隔remaining时间后执行later
    else if (!timeout && options.trailing !== false)    {
      timeout = setTimeout(later, remaining);
    }
   return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
};

// demo
var fn = (data) => console.log(20180926160742, data);
// leading 为 true时，第一次执行立即触发，这比setTimeout好多了
// trailing 为 fasle时，不会触发最后一次。这样比较符合直觉。
const fn2 = throttle(fn, 3000, { leading: true, trailing: false });
fn2(123) // 请手动不停的执行这个函数
)
}

if (v == "debounce 函数去抖") {
Var = 
(

// 函数去抖（debounce）：让函数只有在过完一段时间后再执行，并且该段时间内不被调用才会被执行
var debounce = function(func, wait, immediate) {
    var timeout, result;

     // 定时器设置的回调，清除定时器，执行回调函数func
    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var restArgs = function(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function() {
        var length = Math.max(arguments.length - startIndex, 0);
        var rest = Array(length);
        for (var index = 0; index < length; index++) {
          rest[index] = arguments[index + startIndex];
        }
        switch (startIndex) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, arguments[0], rest);
          case 2: return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for (index = 0; index < startIndex; index++) {
          args[index] = arguments[index];
        }
        args[startIndex] = rest;
        return func.apply(this, args);
      };
    };

    var delay = restArgs(function(func, wait, args) {
      return setTimeout(function(){
        return func.apply(null, args);
      }, wait);
    });

     // restArgs函数将传入的func的参数改造成Rest Parameters —— 一个参数数组
    var debounced = restArgs(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        // 立即触发的条件：immediate为true且timeout为空
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        // _.delay方法实际上是setTimeout()包裹了一层参数处理的逻辑
        timeout = delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
};
)
}

if (v == "is-ie") {
Var = 
(
(function(){ //ie版本
    var agent = navigator.userAgent.toLowerCase();
    return (!!window.ActiveXObject || "ActiveXObject" in window) ? (
      (agent.match(/msie\s(\d+)/) || [])[1] || '11' //由于ie11并没有msie的标识
    `) : false;
}())
)
}

if (v == "cookie 库") {
Var = 
(
/**
 * @desc  设置Cookie
 * @param {String} name
 * @param {String} value
 * @param {Number} expires
 */
function setCookie(name, value, expires) {
    var cookieString = name + "=" + escape(value);
    //判斷是否設置過期時間,0代表關閉瀏覽器時失效
    if (expires > 0) {
        var date = new Date();
        date.setTime(date.getTime() + expires * 1000);
        cookieString = cookieString + ";expires=" + date.toUTCString();
    }
    document.cookie=cookieString;
}

/**
 * @desc 根据name读取cookie
 * @param  {String} name
 * @return {String}
 */
function getCookie(name) {
    var arr = document.cookie.replace(/\s/g, "").split(';');
    for (var i = 0; i < arr.length; i++) {
        var tempArr = arr[i].split('=');
        if (tempArr[0] == name) {
            return decodeURIComponent(tempArr[1]);
        }
    }
    return '';
}

/**
 * @desc 根据name修改cookie
 * @param  {String} name
 * @param  {String} value
 * @param  {Number} expires 
 */
function editCookie(name, value, expires){
    var cookieString = name + "=" + escape(value);
    if (expires > 0) {
        var date = new Date();
        date.setTime(date.getTime() + expires * 1000);
        cookieString = cookieString + ";expires=" + date.toGMTString();
    }
    document.cookie = cookieString;
}

/**
 * @desc 根据name删除cookie
 * @param  {String} name
 */
function removeCookie(name) {
    // 设置已过期，系统会立刻删除cookie
    setCookie(name, '1', -1);
}
)
}

if (v == "countDown 倒计时") {
Var = 
(
/**
 * 開始倒計時
 * http://candy.dragonvein.io/frontend/web/site/signup
 * @param {jQuery DOM} $dom
 * <input type='button' id='second' value = '獲取驗證碼 | Get SMS Code'/>
 */
$(function () {
	// 触发按钮
	$("#second").click(function () {
	    sendCode();
	});
	// 獲取cookie值
	v = getCookie("secondsremained_login") ? getCookie("secondsremained_login") : 0;
	if (v > 0) {
		 // 開始倒計時
	    countDown($("#second")); 
	}
})

function sendCode () {
	// 设置默认时间
	setCookie('secondsremained_login', '60', 60)
	// 開始倒計時
    countDown($("#second")); 
}

function countDown ($dom) {
	var countdown = getCookie('secondsremained_login') ? getCookie('secondsremained_login') : 0;
	(function settime () {
		if (countdown == 0) {
		    $dom.removeAttr('disabled');
		    $dom.val('獲取驗證碼 | Get SMS Code');
		    return;
		} else {
		    $dom.attr('disabled', true);
		    $dom.val(countdown + '秒後重發 | Waiting ' + countdown + 's');
		    countdown--;
		    editCookie('secondsremained_login', countdown, countdown + 1);
		}
		setTimeout(function() { settime($dom) },1000) //每1000毫秒執行壹次
	}());
}
)
}

if (v == "rem 解决方案 / 淘宝解决方案") {
SendLevel 1
Send, taobao{tab}
return 
}

if (v == "lazyload 图片懒加载") {
Var = 
(
/**
 * 图片懒加载
 * https://www.liaoxuefeng.com/article/00151045553343934ba3bb4ed684623b1bf00488231d88d000
 * <img src="https://loading.io/assets/img/ajax.gif" data-src="http://www.hongte.info/assets/images/banner2.jpg">
 * <div style="margin-top: 1000px;"></div>
 */
;(function(){
    // 获取包含data-src属性的img
    var lazyImgs = document.querySelectorAll('img[data-src]')
    // 将Node-List转化成数组类型
    lazyImgs = [].slice.apply(lazyImgs);
     // 定义事件函数
    var lazyload = function () {
        // 获取页面滚动的高度
        var wtop = window.scrollY;
        // 获取可视区域高度
        var wheight = document.documentElement.clientHeight;
        // 判断是否还有未加载的img
        if (lazyImgs.length > 0) {
            // 循环处理数组的每个img元素
            for (var i = lazyImgs.length - 1; i >= 0; i--) {
                // 获取图片信息
                var el = lazyImgs[i], rect = el.getBoundingClientRect(), src = el.getAttribute('data-src')
                // 判断是否在可视范围内:
                if (rect.top - wtop < wheight) {
                   // 设置src属性:
                   el.setAttribute('src', src);
                   // 删除对象
                   Array.prototype.splice.call(lazyImgs, i, 1);
                }
            }
        }
    };

    // 懒加载优化：滚动节流策略
    var __SCROLLTIMER__ = null
    // 绑定事件
    window.onscroll = function () {
        clearTimeout(__SCROLLTIMER__);
        __SCROLLTIMER__ = setTimeout(lazyload, 150);
    }

    // 手动触发一次, 因为页面显示时，并未触发scroll事件。
    lazyload();
}());
)
}

if (v == "copyToClipboard 剪切板") {
Var = 
(
// 剪切板
export const copyToClipboard = (text, cb) => {
    if(text.indexOf('-') !== -1) {
        let arr = text.split('-');
        text = arr[0] + arr[1];
    }
    var textArea = document.createElement("textarea");
      textArea.style.position = 'fixed';
      textArea.style.top = '0';
      textArea.style.left = '0';
      textArea.style.width = '2em';
      textArea.style.height = '2em';
      textArea.style.padding = '0';
      textArea.style.border = 'none';
      textArea.style.outline = 'none';
      textArea.style.boxShadow = 'none';
      textArea.style.background = 'transparent';
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();

      try {
        var successful = document.execCommand('copy');
        cb && cb()
      } catch (err) {
        console.log('该浏览器不支持点击复制到剪贴板');
      }
      document.body.removeChild(textArea);
}
)
}

if (v == "maybe 神奇的预设函数") {
Var = 
(
const maybe = (fn, n = '') => {
   try {
      const result = fn()
      return (result && result === result && result !== 'NaN' && result !== 'Invalid date') ? result : n
   } catch (err) {
      return n
   }
}

var obj = {
 a: 123
}
maybe(_=> obj.a, 0); // 123
maybe(_=> obj.b, 0); // 0
maybe(_=> obj.a.b.s.w.holy.shit.fuck.god, 0); // 0
)
}

if (v == "ClickOutside 点击外部冒泡") {
Var = 
(
handle = e => {
  const el = this.container
  // 核心: el.contains()，这里的el就是弹窗本身，换句话就是inSide
  if (el && !el.contains(e.target)) onClickOutside(e)
}
)
}

if (v == "addcss/link 样式加载器") {
Var = 
(
var link = function(href, fn, cssname){
	var that = this
	,link = doc.createElement('link')
	,head = doc.getElementsByTagName('head')[0];

	if(typeof fn === 'string') cssname = fn;

	var app = (cssname || href).replace(/\.|\//g, '')
	,id = link.id = 'layuicss-'+app
	,timeout = 0
	,time = 10;

	link.rel = 'stylesheet';
	link.href = href + (config.debug ? '?v='+new Date().getTime() : '');
	link.media = 'all';

	if(!doc.getElementById(id)){
	  head.appendChild(link);
	}

	if(typeof fn !== 'function') return that;

	//轮询css是否加载完毕
	;(function poll() {
	  if(++timeout > time * 1000 / 100){
	    return console.error(href + ' timeout');
	  };
	  <这里写上你的条件> ? fn() : setTimeout(poll, 100);
	}());

	return that;
};

var addcss = function(firename, fn, cssname){
	return link(config.dir + 'css/' + firename, fn, cssname);
};
)
}

if (v == "getstyle") {
Var = 
(
getComputedStyle(el)[ruleName];
)
}

if (v == "is-wx") {
Var = 
(
var is_weixn = function () {
    var ua = navigator.userAgent.toLowerCase();
    if(ua.match(/MicroMessenger/i)=="micromessenger") {
        return true;
    } else {
        return false;
    }
}
)
}

if (v == "poll 递归") {
Var = 
(
// 递归
var maxTimeout = 10,
    timeout = 0,
    wait = 4, 
    callback = function() {
       // ... 这样写上条件成功时执行的内容
    };
(function poll() {
    if (++timeout > maxTimeout * 1000 / wait) {
        return window.alert('超时');
    };
    <这里写上你的判断> ? callback() : setTimeout(poll, wait);
}());
)
}

if (v == "escapeHTML 防止XSS") {
Var = 
(
var escape = function(html){
  return String(html || '').replace(/&(?!#?[a-zA-Z0-9]+;)/g, '&amp;')
  .replace(/</g, '&lt;').replace(/>/g, '&gt;')
  .replace(/'/g, '&#39;').replace(/"/g, '&quot;');
}
)
}

if (v == "preloadimg 图片预加载") {
Var = 
(
var perloadimg = function(url, callback, error) {
    var img = new Image();
    img.src = url;
    if(img.complete){
      return callback(img);
    }
    img.onload = function(){
      img.onload = null;
      typeof callback === 'function' && callback(img);
    };
    img.onerror = function(e){
      img.onerror = null;
      typeof error === 'function' && error(e);
    };
};

const preLoadImages = (imgs) => {
  var imgWrap = [];
  imgs.forEach(function (path) {
       new Image().src = path;
  });
}
preLoadImages(['./bg.png', './bg2.png'])
)
}

if (v == "device 获取设备信息") {
Var = 
(
var device = function(key){
  var agent = navigator.userAgent.toLowerCase()

  //获取版本号
  ,getVersion = function(label){
    var exp = new RegExp(label + '/([^\\s\\_\\-]+)');
    label = (agent.match(exp)||[])[1];
    return label || false;
  }
  
  //返回结果集
  ,result = {
    os: function(){ //底层操作系统
      if(/windows/.test(agent)){
        return 'windows';
      } else if(/linux/.test(agent)){
        return 'linux';
      } else if(/iphone|ipod|ipad|ios/.test(agent)){
        return 'ios';
      } else if(/mac/.test(agent)){
        return 'mac';
      } 
    }()
    ,ie: function(){ //ie版本
      return (!!window.ActiveXObject || "ActiveXObject" in window) ? (
        (agent.match(/msie\s(\d+)/) || [])[1] || '11' //由于ie11并没有msie的标识
      `) : false;
    }()
    ,weixin: getVersion('micromessenger')  //是否微信
  };
  
  //任意的key
  if(key && !result[key]){
    result[key] = getVersion(key);
  }
  
  //移动设备
  result.android = /android/.test(agent);
  result.ios = result.os === 'ios';
  
  return result;
};
)
}



if (v == "isBottom 是否滚动到底部") {
SendLevel 1
Send, isbottom{tab}
return
}


if (v == "isString") {
Var = 
(
export default function isString(input) {
	return Object.prototype.toString.call(input) === '[object String]'
}
)
}
if (v == "isBoolean") {
Var = 
(
export default function isBoolean(input) {
	return Object.prototype.toString.call(input) === '[object Boolean]'
}
)
}
if (v == "isZH-Cn") {
Var = 
(
if (!/^[\u4e00-\u9fa5]+$/.test('李钊鸿')) {
      throw new Error('请输入中文汉字')
}
)
}
if (v == "isIp") {
Var = 
(
body.match(/\d\.\d\.\d\.\d:\d/g);
)
}
if (v == "isPhone") {
Var = 
(
/^([0-9]{3,4}-)?[0-9]{7,8}$/.test(s)
/^[1][3,4,5,7,8][0-9]{9}$/.test(s)
/^1\d{10}$/.test(s)
/^((1)3(\d){9}$)|(^(1)4[5-9](\d){8}$)|(^(1)5[^4]{9}$)|(^(1)66(\d){8}$)|(^(1)7[0-8](\d){8}$)|(^(1)8(\d){9}$)|(^(1)9[8-9](\d){8}$)/.test(16961121989)
)
}
if (v == "isPwd") {
Var = 
(
/[A-Za-z].*[0-9]|[0-9].*[A-Za-z]/.test('123456a@') // 必须同时包含数字和字母,支持非法符号
)
}
if (v == "isUser") {
Var = 
(
 /^[a-zA-Z0-9-_]*$/.test('') // 由6-16位数字、 字母、 '_'、 '-'组成，不含特殊字符
)
}
if (v == "isId") {
Var = 
(
if (!/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/.test('445222199307100337')){
    throw new Error('非法身份证')
}
)
}
if (v == "isEmail") {
Var = 
(
)
}

if (v == "isZH-Cn") {
Var = 
(
if (!/^[\u4e00-\u9fa5]+$/.test('李钊鸿')) {
      throw new Error('请输入中文汉字')
}
)
}



if (v == "gettop 获取距离顶部的相对距离") {
Var = 
(
// 获取距离顶部的相对距离
function getElementTop(element){
    try {
　  　　　var actualTop = element.offsetTop;
　  　　　var current = element.offsetParent;
　  　　　while (current !== null){
　  　　　　　actualTop += current.offsetTop;
　  　　　　　current = current.offsetParent;
　  　　　}
　  　　　return actualTop;
    } catch (e) {}
}
)
}

if (v == "scrollToTop 滚动到头部") {
Var = 
(
var timer = null;
var goTop = function() {
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
            document.body.scrollTop = document.documentElement.scrollTop = oTop - 500;
            timer = requestAnimationFrame(fn);
        } else {
            cancelAnimationFrame(timer);
        }
    });
}
// es6
const scrollToTop = () => {
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c > 0) {
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  }
};
)
}


if (v == "pad 自动补全") {
Var = 
(
// 自动补全
function pad (target, n) {
    var zero = new Array(n).join('0');
    var str = zero + target;
    var result = str.substr(-n);
    return result;
}
)
}

if (v == "isArray") {
Var = 
(
export default function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}
)
}

if (v == "isDate") {
Var = 
(
export default function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}
)
}

if (v == "isFunction") {
Var = 
(
export default function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}
)
}

if (v == "isNumber") {
Var = 
(
export default function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}
)
}

if (v == "isPureObject") {
Var = 
(
export default function isEmptyObject(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}
)
}

if (v == "isObject") {
Var = 
(
export default function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

)
}

if (v == "isPromise") {
Var = 
(
export function isPromise (val) {
  return val && typeof val.then === 'function'
}
)
}

if (v == "isNaN") {
Var = 
(
function isNaN(obj) {
    return obj !== obj
}
)
}

if (v == "extend 浅拷贝") {
SendLevel 1
Send, extend{tab}
return
}

if (v == "deepExtend 深拷贝") {
SendLevel 1
Send, deepextend{tab}
return
}

if (v == "getElementPosition 获取元素的定位") {
Var = 
(
function getElementPosition (el: Element, offset: Object): Object {
  const docEl: any = document.documentElement
  const docRect = docEl.getBoundingClientRect()
  const elRect = el.getBoundingClientRect()
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}
)
}


if (v == "uuid 超简易版") {
Var = 
(
// 36位
function getUUID () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    return (c === 'x' ? (Math.random() * 16 | 0) : ('r&0x3' | '0x8')).toString(16)
  })
}

// 32位 正式版
const UUIDGeneratorBrowser = () => ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16));
UUIDGeneratorBrowser(); // '7982fcfe-5721-4632-bede-6000885be57d'

// 9位 简易版
const MdUuid = () => Math.random().toString(36).slice(4)
MdUuid() // "r1mca5d4z"
)
}

if (v == "addClass") {
Var = 
(
export const addClass = (el, cls) => {
        if (el.classList) {
            el.classList.add(cls)
        } else {
            var cur = ' ' + utils.getClassName(el) + ' '
            if (cur.indexOf(' ' + cls + ' ') < 0) {
                el.setAttribute('class', (cur + cls).trim())
            }
        }
    }
)
}

if (v == "removeclass") {
Var = 
(
export const removeClass = (el, cls) => {
        if (el.classList) {
            el.classList.remove(cls)
        } else {
            var cur = ' ' + utils.getClassName(el) + ' ',
                tar = ' ' + cls + ' '
            while (cur.indexOf(tar) >= 0) {
                cur = cur.replace(tar, ' ')
            }
            el.setAttribute('class', cur.trim())
        }
    }
)
}

if (v == "getclassname") {
Var = 
(
export const getClassName = (el) => {
        return (el.className instanceof SVGAnimatedString ? el.className.baseVal : el.className)
    }
)
}

if (v == "setStyle") {
Var = 
(
export const setStyle = (element, styleName, value) => {
    if (!element || !styleName) return;

    if (typeof styleName === 'object') {
        for (var prop in styleName) {
            if (styleName.hasOwnProperty(prop)) {
                setStyle(element, prop, styleName[prop]);
            }
        }
    } else {
        if (styleName === 'opacity' && ieVersion < 9) {
            element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
        } else {
            element.style[styleName] = value;
        }
    }
};
)
}


code(Var)
return