!u::
    Menu, utilsIs, Add, is, utilsHandler
    Menu, utilsIs, Add, isString, utilsHandler
    Menu, utilsIs, Add, isNumber, utilsHandler
    Menu, utilsIs, Add, isBoolean, utilsHandler
    Menu, utilsIs, Add, isArray, utilsHandler
    Menu, utilsIs, Add, isObject, utilsHandler
    Menu, utilsIs, Add, isPureObject, utilsHandler
    Menu, utilsIs, Add, isFunction, utilsHandler
    Menu, utilsIs, Add, isDate, utilsHandler
    Menu, utilsIs, Add, isPromise, utilsHandler
    Menu, utilsIs, Add, isNaN, utilsHandler
    Menu, utilsIs, Add, isNodeList, utilsHandler
    Menu, utilsIs, Add, isHtml：div instanceof HTMLElement, utilsHandler
    Menu, utilsIs, Add, 判断是否为数字：!isNaN(+params.id), utilsHandler

    Menu, utilsIs, Add, , utilsHandler
    Menu, utilsIs, Add, , utilsHandler

    Menu, utilsIs, Add, isZH-Cn, utilsHandler
    Menu, utilsIs, Add, isIp, utilsHandler
    Menu, utilsIs, Add, isPhone, utilsHandler
    Menu, utilsIs, Add, isPwd, utilsHandler
    Menu, utilsIs, Add, isUser, utilsHandler
    Menu, utilsIs, Add, isId, utilsHandler
    Menu, utilsIs, Add, isEmail, utilsHandler
    Menu, utilsIs, Add, is-wx, utilsHandler
    Menu, utilsIs, Add, is-ie, utilsHandler
    Menu, utilsIs, Add, isBottom 是否滚动到底部, utilsHandler
    
    
    Menu, utilsDOM, Add, dom.js, utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add

    Menu, utilsDOM, Add, addClass, utilsHandler
    Menu, utilsDOM, Add, hasClass, utilsHandler
    Menu, utilsDOM, Add, removeclass , utilsHandler
    Menu, utilsDOM, Add, getclassname, utilsHandler
    Menu, utilsDOM, Add, getstyle, utilsHandler
    Menu, utilsDOM, Add, setStyle, utilsHandler
    Menu, utilsDOM, Add, setattr, utilsHandler
    Menu, utilsDOM, Add, removeattr, utilsHandler
    Menu, utilsDOM, Add, getComputedStyle(el)['height'], utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, create 创建元素, utilsHandler
    Menu, utilsDOM, Add, create 创建img, utilsHandler
    Menu, utilsDOM, Add, 插入body前面, utilsHandler
    Menu, utilsDOM, Add, 插入body后面, utilsHandler
    Menu, utilsDOM, Add, img判断加载完成, utilsHandler
    Menu, utilsDOM, Add, 克隆dom的认知：深浅克隆 document.querySelector('.layer').cloneNode(true), utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, getElementPosition 获取元素的定位, utilsHandler
    Menu, utilsDOM, Add, gettop 获取距离顶部的相对距离, utilsHandler
    Menu, utilsDOM, Add, scrollToTop 滚动到头部, utilsHandler
    Menu, utilsDOM, Add, scrollIntoView 滚动到元素可视区域, utilsHandler
    Menu, utilsDOM, Add, scrollIntoView 滚动到元素可视区域（代码实现）, utilsHandler
    Menu, utilsDOM, Add, isBottom 是否滚动到底部, utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, injectCss 往页面插入style, utilsHandler
    Menu, utilsDOM, Add, getScriptPath, utilsHandler
    Menu, utilsDOM, Add, onscript/loadscript 加载脚本并等待加载完成, utilsHandler
    Menu, utilsDOM, Add, addcss/link 样式加载器, utilsHandler
    
    Menu, utilsDOM, Add
    Menu, utilsDOM, Add
    
    Menu, utilsDOM, Add, 是否隐藏：$('#div').is(':hidden'), utilsHandler
    Menu, utilsDOM, Add, 是否显示：$('#div').is(':visible'), utilsHandler
    Menu, utilsDOM, Add, clickOutSide：!el.contains(event.target), utilsHandler
    Menu, utilsDOM, Add, e.dataset 给元素设置数据, utilsHandler
    Menu, utilsDOM, Add, 获取当前所在的<script>：document.currentScript, utilsHandler
    Menu, utilsDOM, Add, 获取当前所在的<iframe>：window.frameElement, utilsHandler
    Menu, utilsDOM, Add, mask蒙版, utilsHandler
    Menu, utilsDOM, Add, 滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop, utilsHandler
    Menu, utilsDOM, Add, mvDOM：移动dom元素到指定目标位置, utilsHandler
    
    
    
    Menu, utilsPosition, Add, 🍁🍁🍁🍁🍁🍁🍁🍁 element 的定位要素 🍁🍁🍁🍁🍁🍁🍁🍁, utilsHandler
    Menu, utilsPosition, Add, - el.clientHeight：可视高度 , utilsHandler
    Menu, utilsPosition, Add, - el.scrollHeight：真实高度（含滚动条） , utilsHandler
    Menu, utilsPosition, Add, - el.getBoundingClientRect().top：相对窗口的距离 , utilsHandler
    Menu, utilsPosition, Add, - el.scrollTop: 视口可见的顶部，到绝对顶部的距离, utilsHandler 
    
    Menu, utilsPosition, Add, 🍁🍁🍁🍁🍁🍁🍁🍁 event 的定位要素 🍁🍁🍁🍁🍁🍁🍁🍁, utilsHandler
    Menu, utilsPosition, Add, - e.clientY：客户端浏览器视口所在的位置, utilsHandler
    Menu, utilsPosition, Add, - e.pageY：页面所在的位置, utilsHandler
    Menu, utilsPosition, Add, - e.screenY：屏幕所在的位置, utilsHandler
    
    Menu, utilsPosition, Add, 🍁🍁🍁🍁🍁🍁🍁🍁 offset 系列 🍁🍁🍁🍁🍁🍁🍁🍁, utilsHandler
    Menu, utilsPosition, Add, - offsetWidth：getComputedStyle(el).width 返回的可能是百分比，offsetWidth总是返回数值, utilsHandler
    Menu, utilsPosition, Add, - offsetTop：元素相对于定位元素（position默认是body）的偏移量（含scroll）, utilsHandler

    Menu, utilsPosition, Add, 🍁🍁🍁🍁🍁🍁🍁🍁 综合实战 🍁🍁🍁🍁🍁🍁🍁🍁, utilsHandler
    Menu, utilsPosition, Add, 滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop, utilsHandler
    
    Menu, utilsObject, Add, for#Object.keys, utilsHandler
    Menu, utilsObject, Add, for#o in obj, utilsHandler
    Menu, utilsObject, Add, for#Object.entries(), utilsHandler
    Menu, utilsObject, Add, for#Object.values(), utilsHandler
    Menu, utilsObject, Add, for#Object.keys(), utilsHandler

    Menu, utilsObject, Add,, utilsHandler
    Menu, utilsObject, Add,, utilsHandler

    Menu, utilsObject, Add, (〜￣△￣)〜认知～(￣▽￣～)：({a = 123`, b = 321`, c = 456} = {}) 对象解构 与 参数默认值, utilsHandler
    Menu, utilsObject, Add, delete person.age 删除对象的属性, utilsHandler
    Menu, utilsObject, Add, Object.assign({}`, ), utilsHandler
    Menu, utilsObject, Add, Object.is 比 === 更严格的比较, utilsHandler
    Menu, utilsObject, Add, 'tail' in cat / cat.hasOwnProperty('tail') 判断对象是否包含某属性, utilsHandler
    
    Menu, utilsObject, Add,, utilsHandler
    Menu, utilsObject, Add,, utilsHandler

    Menu, utilsObject, Add, Object.defineProperty 属性的权限设置 writable（可写） / configurable（可配置）/enumerable（可枚举）, utilsHandler
    Menu, utilsObject, Add, Object.defineProperties 属性的批量权限设置, utilsHandler
    Menu, utilsObject, Add, Object.getOwnPropertyDescriptor({a: 123}`, 'a') 获取属性的配置, utilsHandler
    Menu, utilsObject, Add, getter / setter , utilsHandler

    Menu, utilsSolution, Add, setTitle: 解决微信、QQ、闪银等内置浏览器单页应用无法刷新title的问题, utilsHandler
    Menu, utilsSolution, Add, cookie 库, utilsHandler
    Menu, utilsSolution, Add, Model 类, utilsHandler
    Menu, utilsSolution, Add, rem 解决方案 / 淘宝解决方案, utilsHandler

    Menu, utilsSolution, Add
    Menu, utilsSolution, Add

    Menu, utilsSolution, Add, AMD/CommonJS/factory/module, utilsHandler
    Menu, utilsSolution, Add, UMD、AMD, utilsHandler
    Menu, utilsSolution, Add, cache request axios 缓存请求, utilsHandler

    Menu, utilsSolution, Add
    Menu, utilsSolution, Add

    Menu, utilsSolution, Add, $.autoscroll 自动滚动, utilsHandler
    Menu, utilsSolution, Add, $.scrollforevery 无缝滚动, utilsHandler
    Menu, utilsSolution, Add, dragscroll 拖拽滚动, utilsHandler

    Menu, utilsSolution, Add
    Menu, utilsSolution, Add

    Menu, utilsSolution, Add, lazyload 图片懒加载, utilsHandler
    Menu, utilsSolution, Add, preloadimg 图片预加载, utilsHandler

    Menu, utilsSolution, Add
    Menu, utilsSolution, Add

    Menu, utilsSolution, Add, countDown 倒计时, utilsHandler
    Menu, utilsSolution, Add, copyToClipboard 剪切板, utilsHandler
    Menu, utilsSolution, Add, 全屏F11最新解决方案, utilsHandler
    Menu, utilsSolution, Add, 滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop, utilsHandler
    Menu, utilsSolution, Add, 延迟上传解决ajax压力的解决方案, utilsHandler

    Menu, utilsExtend, Add, extend 浅拷贝（继承模式中最后的圣杯）, utilsHandler
    Menu, utilsExtend, Add, deepExtend 深拷贝, utilsHandler
    Menu, utilsExtend, Add, multi 多重拷贝, utilsHandler
    Menu, utilsExtend, Add, 寄生式继承, utilsHandler
    Menu, utilsExtend, Add, 构造器借用, utilsHandler
    
    
    Menu, utilsThis, Add, 1、作为对象的方法调用, utilsHandler
    Menu, utilsThis, Add, 2、作为普通函数调用时, utilsHandler
    Menu, utilsThis, Add, 3、作为构造器调用, utilsHandler
    Menu, utilsThis, Add, 4、Function.prototype.call 或 Function.prototype.apply 调用, utilsHandler
    Menu, utilsThis, Add, 5、es6箭头函数调用时, utilsHandler
    Menu, utilsThis, Add, 6、es6 class 中的, utilsHandler
    
    Menu, utilsDesignPattern, Add, this , :utilsThis
    Menu, utilsDesignPattern, Add, 封装, utilsHandler
    Menu, utilsDesignPattern, Add, 多态, utilsHandler
    Menu, utilsDesignPattern, Add, 继承（浅拷贝/深拷贝/多重拷贝/寄生式继承/构造器借用）, :utilsExtend
    
    Menu, utilsDesignPattern, Add, call 和 apply, utilsHandler
    Menu, utilsDesignPattern, Add, Function.prototype.before, utilsHandler
    Menu, utilsDesignPattern, Add, Function.prototype.after, utilsHandler
    
    Menu, utilsDesignPattern, Add, , utilsHandler
    Menu, utilsDesignPattern, Add, , utilsHandler
    
    Menu, utilsDesignPattern, Add, 延迟上传解决ajax压力的解决方案, utilsHandler
    Menu, utilsDesignPattern, Add, 闭包与Cache, utilsHandler
    Menu, utilsDesignPattern, Add, 参数缓存器, utilsHandler
    Menu, utilsDesignPattern, Add, 模块模式：现代模块实现的基石, utilsHandler
    Menu, utilsDesignPattern, Add, 超简单的currying与理财花销实例, utilsHandler
    Menu, utilsDesignPattern, Add, 超简单的链式调用套路：即让方法调用结束后返回对象本身, utilsHandler
    Menu, utilsDesignPattern, Add, AOP - 面向切面编程, utilsHandler
    Menu, utilsDesignPattern, Add, 模板抽象类接口：咖啡与茶, utilsHandler
    
    Menu, utilsDesignPattern, Add, , utilsHandler
    Menu, utilsDesignPattern, Add, , utilsHandler
    
    
    Menu, utilsDesignPattern, Add, (=・ω・=)我的单例版ajax, utilsHandler
    Menu, utilsDesignPattern, Add, 惰性单例, utilsHandler
    Menu, utilsDesignPattern, Add, 透明单例, utilsHandler
    Menu, utilsDesignPattern, Add, 代理单例, utilsHandler
    Menu, utilsDesignPattern, Add, 通用的惰性单例, utilsHandler
    Menu, utilsDesignPattern, Add, （回调版）单例模式，通常用于ajax类, utilsHandler
    Menu, utilsDesignPattern, Add, 单例模式：生成不重复的随机数, utilsHandler
    
    
    Menu, utilsDesignPattern, Add, , utilsHandler
    Menu, utilsDesignPattern, Add, , utilsHandler
    
    Menu, utilsDesignPattern, Add, JavaScript版 策略模式, utilsHandler
    Menu, utilsDesignPattern, Add, __EVENT__消息订阅, utilsHandler
    Menu, utilsDesignPattern, Add, es6 超简洁版Event事件模块, utilsHandler
    Menu, utilsDesignPattern, Add, 仿rxjs的观察者模式, utilsHandler
    
    Menu, utilsDesignPattern, Add, , utilsHandler
    Menu, utilsDesignPattern, Add, , utilsHandler
    
    Menu, utilsDesignPattern, Add, 优惠券条件分支：链式after解决方案, utilsHandler
    
    ; @认知 @renzhi
    Menu, utilspractice, Add, 拖拽位置公式, utilsHandler
    Menu, utilspractice, Add, 仿rxjs的观察者模式, utilsHandler
    Menu, utilspractice, Add, koajs 核心函数compose的超简单源码实现, utilsHandler
    Menu, utilspractice, Add, 超简单的currying与理财花销实例, utilsHandler
    Menu, utilspractice, Add, curry2 二元参数的手动柯里化, utilsHandler
    
    Menu, utilspractice, Add,
    Menu, utilspractice, Add,
    
    Menu, utilspractice, Add, FormData（multipart/form-data）与URLSearchParams（application/x-www-form-urlencoded）的区别, utilsHandler
    Menu, utilspractice, Add, 多个异步操作时，请毫不犹豫用Pormise.all, utilsHandler
    Menu, utilspractice, Add, Promise.race只返回最快的一个, utilsHandler
    
    Menu, utilspractice, Add,
    Menu, utilspractice, Add,
    
    Menu, utilspractice, Add, 任意值的__proto__拦截器：数组为例, utilsHandler
    Menu, utilspractice, Add, promise.catch 全局处理与局部传播：在第一次catch的时候throw错误即可, utilsHandler
    Menu, utilspractice, Add, Promise.prototype.finally已经存在了, utilsHandler
    Menu, utilspractice, Add, async/await与箭头函数：async (to`, from`, next) => {}, utilsHandler
    Menu, utilspractice, Add, async/await与传统函数：async function bootstrap() {}, utilsHandler
    Menu, utilspractice, Add, 对象字面量如何使用async/await标记, utilsHandler
    Menu, utilspractice, Add, ...args参数和fn(...args) 入参的技巧和认知, utilsHandler
    Menu, utilspractice, Add, 函数参数对象深度结构与重命名： var a = ({ state: { nums:list`, numGroup`, map } }) => {}, utilsHandler
    
    Menu, utilspractice, Add,
    Menu, utilspractice, Add,
    
    Menu, utilspractice, Add, HTML缓存数据：e.dataset 与 data-fuck-you, utilsHandler
    Menu, utilspractice, Add, 对象字面量的变量键：this.setState({ [fuckyou]: 'true' }), utilsHandler
    Menu, utilspractice, Add, 解构与split结合：const [language`, country] = locale.split('-'), utilsHandler
    Menu, utilspractice, Add, 强制转化为Boolean类型：!!(a && b), utilsHandler
    Menu, utilspractice, Add, parseInt/parseFloat可以直接移除字符串：parseFloat(layero.css('left')) // '162px' => 162, utilsHandler
    Menu, utilspractice, Add, 将 if/else 转化为三元表达式示例, utilsHandler
    Menu, utilspractice, Add, const { log， warn， info， error， assert  } = console, utilsHandler
    Menu, utilspractice, Add, 获取当前所在的<script>：document.currentScript, utilsHandler
    Menu, utilspractice, Add, 获取当前所在的<iframe>：window.frameElement, utilsHandler
    ; renzhi
    
    
    ; @my
    Menu, utilsmy, Add, wait等待工具，必须配合 async/await使用, utilsHandler
    Menu, utilsmy, Add, delay延迟工具，必须配合 async/await使用, utilsHandler
    Menu, utilsmy, Add, 数组成员冲排列：以大带小 drive, utilsHandler
    Menu, utilsmy, Add, StorageEvent：监听 localStorage 数据变化的解决方案, utilsHandler
    Menu, utilsmy, Add, mvDOM：移动dom元素到指定目标位置, utilsHandler
    Menu, utilsmy, Add, 堡垒模式：请求条件不满足则排队处理, utilsHandler
    Menu, utilsmy, Add, 滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop, utilsHandler
    Menu, utilsmy, Add, 把数组像分页一样分割为N段, utilsHandler
    Menu, utilsmy, Add, input动态宽度, utilsHandler
    Menu, utilsmy, Add, exclude: 从对象中排除某个属性, utilsHandler
    Menu, utilsmy, Add, pureMap：纯洁无害的map函数, utilsHandler
    Menu, utilsmy, Add, chunk 数组分块函数, utilsHandler
    Menu, utilsmy, Add, deepset：超强！深度set（deepfind的兄弟方法）, utilsHandler
    Menu, utilsmy, Add, (=・ω・=)我的单例版ajax, utilsHandler
    Menu, utilsmy, Add, 单例模式：生成不重复的随机数, utilsHandler
    Menu, utilsmy, Add, deepfind 深度递归搜索, utilsHandler
    Menu, utilsmy, Add, 加强版map遍历:bettermap, utilsHandler
    Menu, utilsmy, Add, maybe 神奇的预设函数, utilsHandler
    Menu, utilsmy, Add, (=・ω・=)我的单例版ajax, utilsHandler
    Menu, utilsmy, Add, 去重复版本的axios, utilsHandler
    Menu, utilsmy, Add, 获取前6个月/前15天数据, utilsHandler
    Menu, utilsmy, Add, 通过URL判断是否本地开发环境, utilsHandler
    Menu, utilsmy, Add, 用 IIFE 解决 setInterval 首次不执行的尴尬, utilsHandler
    Menu, utilsmy, Add, setInterval 强大的解决方案, utilsHandler
    Menu, utilsmy, Add, setInterval Switch超简单开关, utilsHandler
    Menu, utilsmy, Add, 微信群组随机取人头, utilsHandler
    Menu, utilsmy, Add, 微信获取头像和人员名册, utilsHandler
    Menu, utilsmy, Add, Vue 进度条组件, utilsHandler
    Menu, utilsmy, Add, utils.js, utilsHandler
    Menu, utilsmy, Add, once函数装饰器, utilsHandler
    
    Menu, utilsjuran, Add, 快速取整的新思路：1553 / 10 | 0, utilsHandler
    Menu, utilsjuran, Add, 社会主义点击事件, utilsHandler
    Menu, utilsjuran, Add, anime.js 点击烟花绽放效果, utilsHandler
    Menu, utilsjuran, Add, holder占位图, utilsHandler
    Menu, utilsjuran, Add, window.onunload 刷新/关闭页面之前发送请求, utilsHandler
    
    Menu, utilsmaybe, Add, 数字格式化函数：numberFormatter(11923.4521`, 2) => 12.02k, utilsHandler
    Menu, utilsmaybe, Add, 处理iOS 微信客户端6.7.4 键盘收起页面未下移bug, utilsHandler
    Menu, utilsmaybe, Add, Android 输入法键盘 和 input 问题:scrollIntoViewIfNeeded, utilsHandler
    Menu, utilsmaybe, Add, 获取手机归属地信息：中国移动/中国联通/中国电信, utilsHandler
    Menu, utilsmaybe, Add, js获取root（window）对象, utilsHandler
    Menu, utilsmaybe, Add, stackoverflow愚人节彩蛋效果, utilsHandler
    ;@maybe
    
    
    
    Menu, utilses5, Add, partial：偏应用ES5实现（局部函数工厂）, utilsHandler
    Menu, utilses5, Add, 将参数arguments转化为一个数组Array.prototype.slice.call(arguments), utilsHandler
    Menu, utilses5, Add, (...arr)数组解构的前辈：Array.prototype.push.apply(arr`, newArr), utilsHandler
    Menu, utilses5, Add, 函数调用注入args：successFn.apply(this`, arguments), utilsHandler
    Menu, utilses5, Add, 简写Array.prototype.push.apply的方法：[].push.apply, utilsHandler
    Menu, utilses5, Add, Function.prototype.call：除了参数为数组/类数组以外的都应该使用call，如map/reduce/filter（因为他们的参数都是函数）等, utilsHandler
    
    Menu, utilses5, Add, 
    Menu, utilses5, Add,  
    
    Menu, utilses5, Add, 超简单的currying与理财花销实例, utilsHandler
    Menu, utilses5, Add, 超简单的链式调用套路：即让方法调用结束后返回对象本身, utilsHandler
    
    
    
    ; @A @main @fuck @util @utils
    Menu, utilsMenu , Add, is 判断, :utilsIs
    Menu, utilsMenu , Add, DOM 操作, :utilsDOM
    Menu, utilsMenu , Add, Position 操作, :utilsPosition
    Menu, utilsMenu , Add, Object 操作, :utilsObject
    Menu, utilsMenu , Add, 原始之初ECMA5伏魔录, :utilses5
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    
    Menu, utilssf, Add, 栈（后入先出）: 客栈->酒店->洗盘子->开房->后入->鲜出->压入（push）->弹出（pop）->双p, utilsHandler
    Menu, utilssf, Add, 堆（先入先出）: 死人堆->早死早投胎->排队, utilsHandler
    
    Menu, utilssf, Add, 
    Menu, utilssf, Add, 
    
    Menu, utilssf, Add, 欧几里得算法（分而治之）：目标使土地分配最大化，不断让宽与高求余，直到整数倍为止, utilsHandler
    
    Menu, utilsMenu , Add, (#-_-)┯━┯  解决方案, :utilsSolution
    Menu, utilsMenu , Add, (╯°口°)╯(┴—┴  设计模式与原型面向对象, :utilsDesignPattern
    Menu, utilsMenu , Add, _(:3」∠)_算法与数据结构, :utilssf
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler


    ; @jiqiao
    Menu, utilsjiqiao, Add, JOJO - 砸瓦鲁多：浏览器暂停术 —— 直接在控制台输入debugger;, utilsHandler
    Menu, utilsjiqiao, Add, console.save 在控制台保存json变量到本地, utilsHandler

    
    Menu, utilsMenu, Add, (〜￣△￣)〜认知～(￣▽￣～), :utilspractice
    Menu, utilsMenu, Add, (=・ω・=) 我的 (｀・ω・´), :utilsmy
    Menu, utilsMenu, Add, ←_←前端小技巧→_→, :utilsjiqiao
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, !!Σ(゜Д゜) 居然还有这种操作？ Σ(ﾟдﾟ;), :utilsjuran
    Menu, utilsMenu, Add, ╮(￣▽￣)╭ 先收起来再说，没准将来会有用呢？ ╮(￣▽￣)╭, :utilsmaybe
 
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    

    Menu, utilsMenu, Add, uuid 超简易版, utilsHandler
    Menu, utilsMenu, Add, urlparams 获取路由参数, utilsHandler
    Menu, utilsMenu, Add, device 获取设备信息, utilsHandler
    Menu, utilsMenu, Add, merge（既$.extend，这个概念更好，不会与面向对象的继承混淆）, utilsHandler
    Menu, utilsMenu, Add, 获取localStorage剩余容量和最大容量, utilsHandler

    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    
    
    Menu, utilsMenu, Add, debounce 函数去抖, utilsHandler
    Menu, utilsMenu, Add, throttle 函数节流, utilsHandler
    Menu, utilsMenu, Add, memoized 函数缓存, utilsHandler
    Menu, utilsMenu, Add, timeChunk 分时分批处理函数 , utilsHandler
    Menu, utilsMenu, Add, compose 函数组合, utilsHandler
    Menu, utilsMenu, Add, memoized：函数缓存器, utilsHandler

    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, JSON.parse(JSON.stringify(...)) 超简易拷贝, utilsHandler
    Menu, utilsMenu, Add, window.requestAnimFrame, utilsHandler
    Menu, utilsMenu, Add, poll 递归, utilsHandler
    Menu, utilsMenu, Add, pad 自动补全, utilsHandler
    Menu, utilsMenu, Add, 首字母大写 _.charAt(0) 的使用, utilsHandler
    
    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler

    Menu, utilsMenu, Add, filterhtml: 移除html标签，只提取文本text(), utilsHandler
    Menu, utilsMenu, Add, encodeURI URI过滤, utilsHandler
    Menu, utilsMenu, Add, escapeHTML 防止XSS, utilsHandler
    Menu, utilsMenu, Add, 模拟真实点击click，专门对付clickoutside, utilsHandler
    Menu, utilsMenu, Add, ClickOutside 点击外部冒泡, utilsHandler

    Menu, utilsMenu, Add, , utilsHandler
    Menu, utilsMenu, Add, , utilsHandler
    
    Menu, utilsMenu, Add, 高度从0到auto的伸缩特效魔法, utilsHandler
    Menu, utilsMenu, Add, parsePath: 对象路径解析器, utilsHandler
    Menu, utilsMenu, Add, diff: 对比两个json对象是否一致, utilsHandler
    Menu, utilsMenu, Add, fixPos: 根据父层界限调整宽高和位置, utilsHandler
    Menu, utilsMenu, Add, e.dataset 给元素设置数据, utilsHandler
    Menu, utilsMenu, Add, 滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop, utilsHandler
    
    
    Menu, utilsMenu, Show
	Menu, utilsMenu, DeleteAll
    Menu, utilsIs, DeleteAll
    Menu, utilsDOM, DeleteAll
    Menu, utilsObject, DeleteAll
    Menu, utilssf, DeleteAll
    Menu, utilspractice, DeleteAll
    Menu, utilses5, DeleteAll
    Menu, utilsDesignPattern, DeleteAll
    Menu, utilsSolution, DeleteAll
    
    
return


utilsHandler:
; MsgBox You selected  from the menu .
v := A_ThisMenuItem
Var :=

; @1
if (v == "") {
Var = 
(
)
}


if (v == "setTitle: 解决微信、QQ、闪银等内置浏览器单页应用无法刷新title的问题") {
_send("setTitle", true, true)
return
}



if (v == "延迟上传解决ajax压力的解决方案") {
_send("delay_upload", true, true)
return
}



if (v == "wait等待工具，必须配合 async/await使用") {
_send("wait", true, true)
return
}

if (v == "delay延迟工具，必须配合 async/await使用") {
_send("delay", true, true)
return
}


if (v == "console.save 在控制台保存json变量到本地") {
_send("console.save", true, true)
return
}


if (v == "微信获取头像和人员名册") {
Var = 
(
var users = [...document.querySelectorAll('.member.ng-scope')]
users.map(_ => {
    const name = _.querySelector('.nickname').innerText
    const icon = _.querySelector('.avatar').getAttribute('src')
    return { name, icon: ``https://wx.qq.com/${icon}`` }
})
)
}


if (v == "FormData（multipart/form-data）与URLSearchParams（application/x-www-form-urlencoded）的区别") {
Var = 
(
import ky from 'ky';
(async () => {
	// `multipart/form-data`
	const formData = new FormData();
	formData.append('food', 'fries');
	formData.append('drink', 'icetea');

	await ky.post(url, {
		body: formData
	});
})();


import ky from 'ky';
(async () => {
	// `application/x-www-form-urlencoded`
	const searchParams = new URLSearchParams();
	searchParams.set('food', 'fries');
	searchParams.set('drink', 'icetea');

	await ky.post(url, {
		body: searchParams
	});
})();
)
}

if (v == "数组成员冲排列：以大带小 drive") {
Var = 
(
// 以大带小
var drive = (ary, fn) => {
	// 数组长度
	const len = ary.length
	// 偶数长度
	const isEven = len `% 2 === 0
	// 从大到小排序
	const _ary = ary.sort(fn)
	// 循环的次数
	const time = isEven ? len / 2 : Math.floor(len / 2) + 1
	// 返回新的数组
	return [...Array(time)].reduce((previousValue, currentValue, index) => {
		// 是否循环的最后一次
		const isLastTime = index === time - 1
		// 如果是奇数的，且最后一次的情况下
		if (!isEven && isLastTime) {
			// 没人可带，带我自己就够了
			return [...previousValue, _ary[index]]
		// 默认都带一个小弟
		} else {
			// 带上小弟
			return [...previousValue, _ary[index], _ary[len - 1 - index]]
		}
	}, [])
}
)
}

if (v == "StorageEvent：监听 localStorage 数据变化的解决方案") {
Var = 
(
// Storage 类
var Storage = {
    setItem(key, newVal) {
        // 获取旧值
        const oldVal = this.getItem(key)
        // 设置新值
        localStorage.setItem(key, newVal)
        // 推送
        this.fire(key, newVal, oldVal)
    },
    removeItem(key) {
        // 获取旧值
        const oldVal = this.getItem(key)
        // 删除
        localStorage.removeItem(key)
        // 推送
        this.fire(key, null, oldVal)
    },
    getItem(k) {
      return localStorage.getItem(k)
    },
    fire(...args) {
        var se = document.createEvent('StorageEvent')
        se.initStorageEvent('storage', false, false, ...args)
        window.dispatchEvent(se)
    }
}

// 监听 storage 事件
window.addEventListener('storage', ({ key, newValue, oldValue } = {}) => {
     console.log(key, newValue, oldValue)
}, false)

// 触发条件
Storage.setItem('a', 123)
)
}

if (v == "克隆dom的认知：深浅克隆 document.querySelector('.layer').cloneNode(true)") {
Var = 
(
document.querySelector('.layer').cloneNode(true)
)
}

if (v == "mvDOM：移动dom元素到指定目标位置") {
_send("mvDOM", true, true)
return
}

if (v == "partial：偏应用ES5实现（局部函数工厂）") {
Var = 
(
function partial(fn, /* args... */) {
	var args = [].slice.call( arguments, 1 );

	return function () {
		return fn.apply( this, args.concat( [].slice.call( arguments ) ) );
	}
}

/* demo：实际上作用很类似 fn.prototype.bind */

function add(a, b) {
	return a + b;
}

var add100 = partial(add, 100);
console.log(add100(14)) // 114
)
}


if (v == "拖拽位置公式") {
Var = 
(
https://github.com/vuegg/vuegg/blob/master/client/src/components/editor/main/Stage.vue#L123

拖拽位置公式 = pageY  - <容器到顶部的距离> + 容器scrollTop - 元素高度/2

容器到顶部的距离 = 容器offsetTop - 其他障碍高度
)
}

if (v == "堡垒模式：请求条件不满足则排队处理") {
_send("baoleimodel", true, true)
return
}

if (v == "滚动条到底了：el.scrollHeight - el.clientHeight === el.scrollTop") {
Var = 
(
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    .box {
        height: 500px;
        overflow-y: scroll;
    }
    </style>
</head>

<body>
    <div id="app">
        
        <div class="box">
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
            <p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p><p>1</p>
        </div>
        
        <button onclick='cf()'>test</button>
    </div>
</body>
<script>

const el = document.querySelector('.box')

el.addEventListener('scroll', (event) => {
   if (el.scrollHeight - el.clientHeight === el.scrollTop) {
    console.log(20190517110428, 123)
   }
})

function cf() {
    console.log(20190517105848, el.scrollHeight)
    console.log(20190517105848, el.clientHeight)
    console.log(20190517105848, el.scrollTop)
}

</script>
</html>
)
}

if (v == "把数组像分页一样分割为N段") {
_send("fenye", true, true)
}

if (v == "once函数装饰器") {
_send("once", true, true)
}

if (v == "获取当前所在的<iframe>：window.frameElement") {
Var = 
(
console.log(window.frameElement);
)
}


if (v == "e.dataset 给元素设置数据") {
Var = 
(
// 方法一：通过js设置（设置完之后，html会出现data-fuck-you="true"的字样。）
$0.dataset['fuckYou'] = 'true'

// 方法二：通过HTML属性设置：
data-fuck-you="true"

// 注意点：
// 1、可以设置多个Dataset
// 2、js设置值必须是驼峰，但HTML设置必须是小写和-相连

// 获取值：
$0.dataset.fuckYou
)
}

if (v == "获取当前所在的<script>：document.currentScript") {
Var = 
(
https://github.com/lukeed/dimport/blob/master/src/module.js#L70
document.currentScript
)
}

if (v == "const { log， warn， info， error， assert  } = console") {
_send("log", true, true)
}

if (v == "HTML缓存数据：e.dataset 与 data-fuck-you") {
Var = 
(
<div id="app" data-fuck-you="true"></div>
document.getElementById('app').dataset.fuckYou    
)
}

if (v == "fixPos: 根据父层界限调整宽高和位置") {
_send("fixpos", true, true)
return
}


if (v == "- el.scrollHeight：真实高度（含滚动条）") {
Var = 
(
el.scrollHeight
)
}


if (v == "- el.scrollTop: 视口可见的顶部，到绝对顶部的距离") {
Var = 
(
/**
 * scrollTop 新认知：https://developer.mozilla.org/zh-CN/docs/Web/API/Element/scrollTop
 *
 * 1、他不是固定不变的，这个数据是根据滚动条的位置而定的（float）。
 * 2、如果没有滚动条，那么值为0.
 * 3、scrollTop 值是视口可见的顶部，到绝对顶部的距离。
 * 4、但当我们向上滚的时候，实质是视口向上相对平移运动，由于该运动导致与容器顶部的距离拉近了。所以说：视口越接近顶部，数值越小（趋于0）。
 */
el.scrollTop
)
}

if (v == "getComputedStyle(el)['height']") {
Var = 
(
getComputedStyle(el)['height']
)
}

if (v == "将 if/else 转化为三元表达式示例") {
Var = 
(
return (
  (!parent)
    ? parseInt(window.getComputedStyle(document.getElementById(element.id))[prop])
    : (typeof element[prop] !== 'string')
      ? element[prop]
      : (typeof parent[prop] !== 'string')
        ? parent[prop] * parseInt(element[prop]) / 100
        : parseInt(window.getComputedStyle(document.getElementById(parent.id))[prop]) * parseInt(element[prop]) / 100
`)
)
}

if (v == "- el.clientHeight：可视高度") {
Var = 
(
el.clientHeight
)
}

if (v == "- el.getBoundingClientRect().top：相对窗口的距离") {
Var = 
(
el.getBoundingClientRect().top
)
}
if (v == "- e.clientY：客户端浏览器视口所在的位置") {
Var = 
(
e.clientY
)
}
if (v == "- e.pageY：页面所在的位置") {
Var = 
(
e.pageY
)
}
if (v == "- e.screenY：屏幕所在的位置") {
Var = 
(
e.screenY
)
}
if (v == "- offsetWidth：getComputedStyle(el).width 返回的可能是百分比，offsetWidth总是返回数值") {
Var = 
(
offsetWidth
)
}
if (v == "- offsetTop：元素相对于定位元素（position默认是body）的偏移量（含scroll）") {
Var = 
(
offsetTop
)
}

if (v == "任意值的__proto__拦截器：数组为例") {
Var = 
(
const arrayProto = Array.prototype

// export 
const arrayMethods = Object.create(arrayProto)

;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach((key) => {
	// raw
	const original = arrayProto[key]
	Object.defineProperty(arrayMethods, key, {
		// 不可枚举
	    enumerable: false,
	    configurable: true,
	    writable: true,
	    value: function mutator (...args) {
	    	console.log('mutator')
	    	return original.apply(this, args)
	    }
	})
})

var a = []
a.__proto__ = arrayMethods
a.push(1) // mutator
)
}


if (v == "diff: 对比两个json对象是否一致") {
_send("diff", true, true)
}

if (v == "parsePath: 对象路径解析器") {
Var = 
(
function parsePath(path) {
	if (/[^\w.$]/.test(path)) {
		return
	}
	const segments = path.split('.')
	return function (obj) {
		for (let i = 0, len = segments.length; i < len; i++) {
			obj = obj[segments[i]]
		}
		return obj
	}
}

var obj = {
	"a": {
		"b": {
			"c": {
				"d": 123
			}
		}
	}
}
fn(obj) // 123
)
}
if (v == "全屏F11最新解决方案") {
_send("fullpage", true, true)
return
}

if (v == "async/await与传统函数：async function bootstrap() {}") {
Var = 
(
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
)
}


if (v == "promise.catch 全局处理与局部传播：在第一次catch的时候throw错误即可") {
Var = 
(
new Promise((resolve, reject) => {
   setTimeout(function () {
        reject('fail')
   }, 1000);
}).catch(err => {
    alert("全局错误处理");
    // 继续传播错误，让下一个catch可以捕获
    throw new Error(err)
}).catch(err => {
    alert("局部处误处理");
})
)
}


if (v == "JOJO - 砸瓦鲁多：浏览器暂停术 —— 直接在控制台输入debugger;") {
Var = 
(
debugger;
)
}

if (v == "Promise.prototype.before") {
Var = 
(
Promise.prototype.before = function (fn) {
	(fn instanceof Function || Object.prototype.toString.call(fn) === '[object Function]') && fn()
	return this
}

// 注意，你必须resolve或reject才可以执行.then()
new Promise((resolve, reject) => {
   setTimeout(function () {
        reject('fail')
   }, 1000);
}).before(() => {
	console.log(20190422151455, 'before?')
}).finally(() => {
	console.log(20190422145923, 123)
})
)
}


if (v == "Promise.prototype.finally已经存在了") {
Var = 
(
new Promise((resolve, reject) => {
   setTimeout(function () {
        reject('fail')
   }, 1000);
}).finally(() => {
	console.log(20190422145923, 123)
})
)
}

if (v == "memoized：函数缓存器") {
_send("fncache", true, true)
return
}

if (v == "input动态宽度") {
Var = 
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    #test {
        min-width: 160px;
    }
    </style>
</head>

<body>
    <input type="text" id='test'>
    <div id='test2'></div>
</body>
<script>

const autoWidth = input => {
    // valiteda the input type
    if (input instanceof HTMLInputElement === false) 
        // target must be a input element
        return console.warn('target must be a input element')

    // function
    const setWidth = e => {
        // self or target
        const { style, value } = e.target || e
        // set the width style
        style.width = value.length + 'em'
    }

    // init
    setWidth(input)

    // event
    input.addEventListener('input', setWidth)
}

// 获取input
const target = document.querySelector('#test')

// 设置自动根据文本提高宽度
autoWidth(target)

</script>

</html>
)
}

if (v == "isdom：div instanceof HTMLElement") {
Var = 
(
return div instanceof HTMLElement
)
}


if (v == "数字格式化函数：numberFormatter(11923.4521, 2) => 12.02k") {
Var = 
(
/* 数字 格式化*/
export function numberFormatter(num, digits) {
  const si = [
    { value: 1E18, symbol: 'E' },
    { value: 1E15, symbol: 'P' },
    { value: 1E12, symbol: 'T' },
    { value: 1E9, symbol: 'G' },
    { value: 1E6, symbol: 'M' },
    { value: 1E3, symbol: 'k' }
  ]
  for (let i = 0; i < si.length; i++) {
    if (num >= si[i].value) {
      return (num / si[i].value + 0.1).toFixed(digits).replace(/\.0+$|(\.[0-9]*[1-9])0+$/, '$1') + si[i].symbol
    }
  }
  return num.toString()
}
)
}

if (v == "exclude: 从对象中排除某个属性") {
Var = 
(
export const exclude = (obj, ...attribute) =>  {
  // copy
  let _ = JSON.parse(JSON.stringify(obj))
    // 删除属性
  for (let i = 0, len = attribute.length; i < len; i++) {
    const attr = attribute[i]
      delete _[attr]
  }
  // pure obj
  return _
}
)
}

if (v == "pureMap：纯洁无害的map函数") {
_send("puremap", true, true)
return
}

if (v == "快速取整的新思路：1553 / 10 | 0") {
Var = 
(
1553 / 10 | 0
)
}

if (v == "chunk 数组分块函数") {
_send("chunk", true, true)
return
}

if (v == "deepset：超强！深度set（deepfind的兄弟方法）") {
_send("deepset", true, true)
return
}

if (v == "async/await与箭头函数：async (to, from, next) => {}") {
Var = 
(
router.beforeEach(async (to, from, next) => {
  // 这里获取 permissionList
  await store.dispatch('getPermissionList')
})
)
}

if (v == "dom.js") {
_send("dom.js", true, true)
return
}

if (v == "scrollIntoView 滚动到元素可视区域（代码实现）") {
_send("scrollIntoView", true, true)
return
}

if (v == "merge（既$.extend，这个概念更好，不会与面向对象的继承混淆）") {
_send("merge", true, true)
return
}

if (v == "判断是否为数字：!isNaN(+params.id)") {
Var = 
(
!isNaN(+params.id)
)
}

if (v == "stackoverflow愚人节彩蛋效果") {
Var = 
(
	/*!
 * Fairy Dust Cursor.js
 * - 90's cursors collection
 * -- https://github.com/tholman/90s-cursor-effects
 * -- https://codepen.io/tholman/full/jWmZxZ/
 */

(function fairyDustCursor() {
  
  var possibleColors = ["#D61C59", "#E7D84B", "#1B8798"]
  var width = window.innerWidth;
  var height = window.innerHeight;
  var cursor = {x: width/2, y: width/2};
  var particles = [];
  
  function init() {
    bindEvents();
    loop();
  }
  
  // Bind events that are needed
  function bindEvents() {
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('touchmove', onTouchMove);
    document.addEventListener('touchstart', onTouchMove);
    
    window.addEventListener('resize', onWindowResize);
  }
  
  function onWindowResize(e) {
    width = window.innerWidth;
    height = window.innerHeight;
  }
  
  function onTouchMove(e) {
    if( e.touches.length > 0 ) {
      for( var i = 0; i < e.touches.length; i++ ) {
        addParticle( e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random()*possibleColors.length)]);
      }
    }
  }
  
  function onMouseMove(e) {    
    cursor.x = e.clientX;
    cursor.y = e.clientY;
    
    addParticle( cursor.x, cursor.y, possibleColors[Math.floor(Math.random()*possibleColors.length)]);
  }
  
  function addParticle(x, y, color) {
    var particle = new Particle();
    particle.init(x, y, color);
    particles.push(particle);
  }
  
  function updateParticles() {
    
    // Updated
    for( var i = 0; i < particles.length; i++ ) {
      particles[i].update();
    }
    
    // Remove dead particles
    for( var i = particles.length -1; i >= 0; i-- ) {
      if( particles[i].lifeSpan < 0 ) {
        particles[i].die();
        particles.splice(i, 1);
      }
    }
    
  }
  
  function loop() {
    requestAnimationFrame(loop);
    updateParticles();
  }
  
  /**
   * Particles
   */
  
  function Particle() {

    this.character = "*";
    this.lifeSpan = 120; //ms
    this.initialStyles ={
      "position": "absolute",
      "display": "block",
      "pointerEvents": "none",
      "z-index": "10000000",
      "fontSize": "16px",
      "will-change": "transform"
    };

    // Init, and set properties
    this.init = function(x, y, color) {

      this.velocity = {
        x:  (Math.random() < 0.5 ? -1 : 1) * (Math.random() / 2),
        y: 1
      };
      
      this.position = {x: x - 10, y: y - 20};
      this.initialStyles.color = color;

      this.element = document.createElement('span');
      this.element.innerHTML = this.character;
      applyProperties(this.element, this.initialStyles);
      this.update();
      
      document.querySelector('body').appendChild(this.element);
    };
    
    this.update = function() {
      this.position.x += this.velocity.x;
      this.position.y += this.velocity.y;
      this.lifeSpan--;
      
      this.element.style.transform = "translate3d(" + this.position.x + "px," + this.position.y + "px, 0) scale(" + (this.lifeSpan / 120) + ")";
    }
    
    this.die = function() {
      this.element.parentNode.removeChild(this.element);
    }
    
  }
  
  /**
   * Utils
   */
  
  // Applies css `properties` to an element.
  function applyProperties( target, properties ) {
    for( var key in properties ) {
      target.style[ key ] = properties[ key ];
    }
  }
  
  init();
})();
)
}

if (v == "utils.js") {
_send("utils.js", true, true)
return
}

if (v == "UMD、AMD") {
_send("UMD", true, true)
return
}

if (v == "对象字面量的变量键：this.setState({ [fuckyou]: 'true' })") {
Var = 
(
var visible = 'fuckyou'
console.log({[visible]: 'true'}) // { fuckyou: 'true' }
)
}

if (v == "微信群组随机取人头") {
Var = 
(
/**
 * 1、打开微信网页版
 * 2、打开一个群，点击下拉菜单。
 * 3、打开控制台输入该脚本：[...document.querySelectorAll('.members .nickname')].map(_ => _.innerText)
 * 
 */
// 费雪耶兹（Fisher–Yates） 也被称作高纳德（ Knuth）随机置乱算法
function shuffle(target) {
    var j, x, i = target.length;
    for (; i > 0; j = parseInt(Math.random() * i), x = target[--i], target[i] = target[j], target[j] = x) {}
    return target
}
var peoples = shuffle([...document.querySelectorAll('.members .nickname')].map(_ => _.innerText))
peoples.slice(0, 6)

//////////////////////////////////////////////
// 或者用这种更快一点
//////////////////////////////////////////////
// 目标人数
const target = 10
// 组所有成员
const people = [...document.querySelectorAll('.members .nickname')].map(_ => _.innerText)
// 组成员人数
const len = people.length
// 被选中的孩子们
let beSelectPeoples = new Set()
// 直到满足目标人数
while(beSelectPeoples.size != target) {
  // 随机数
  const rand = ~~(0 + Math.random() * (len + 1))
  // 被选中的孩子
  const beSelectPeople = people[rand]
  // 加入队列
  beSelectPeoples.add(beSelectPeople)
}
)
}

if (v == "setInterval Switch超简单开关") {
Var = 
(
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ECharts</title>
    <script src="https://lib.baomitu.com/echarts/4.1.0/echarts.min.js"></script>
</head>
<body>
    <div id="app" style="width: 600px; height:400px;"></div>
</body>

<script>
// 基于准备好的dom，初始化echarts实例
var myChart = echarts.init(document.getElementById('app'))

// mock data
var data = [
    { value: 10, name: '就业保障类' },
    { value: 15, name: '城市建设类' },
    { value: 25, name: '民政救济类' },
    { value: 20, name: '市场监管类' },
    { value: 35, name: '市容城管类' },
    { value: 30, name: '公共安全类' },
    { value: 40, name: '公安消防类' },
]

// 核心配置
var option = {
    legend: {
        x: 'center',
        y: 'bottom',
        data: data.map(_ => _.name)
    },
    series: [{
        type: 'pie',
        radius: [25, 95],
        center: ['50`%', 140],
        roseType: 'area',
        clockWise: false,
        itemStyle: {
            normal: {
                label: {
                    formatter: ['{b}', '占比{d}`%'].join('\n'),
                    textStyle: { color: '#000', fontSize: 12 }
                },
            },
            emphasis: {
                label: {
                    textStyle: { color: '#000', fontSize: 24 }
                }
            }
        },
        data: data
    }]
}

myChart.setOption(option)

function Switch () {
    // 当前索引
    let current = 0;
    // 节点数量
    let len = myChart.getOption().series[0].data.length
    // 开始轮播
    let timer = null

    // 返回一个开始按钮
    const start = function () {
        // 如果已经存在，则不重复执行
        if (timer)
            return timer

        return timer = setInterval(() => {
               // 先取消上一次高亮
               myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: current `% len })
               // 高亮当前节点
               myChart.dispatchAction({ type: 'highlight', seriesIndex: 0, dataIndex: ++current `% len })
        }, 1500)
    }

    // 返回一个关闭按钮
    const stop = function () {
        // 消除定时器
        timer = clearInterval(timer)
        // 关闭高亮
        myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: current `% len })
    }

    return { start, stop }
}

// 获取开关
let _switch = Switch()

// 开启
_switch.start()

/**
 * 虽然 Echarts 有提供 mycharts.on('mouseover') 和 mycharts.on('mouseout')。
 * 但建议还是直接用 DOM 来主导 mouseover/mouseout，否则有一些麻烦的问题。
 * 请自行斟酌选择使用。
 */

// 移动过去就暂停
document.getElementById('app').addEventListener('mouseover', () => {
    _switch.stop()
})

// 移动过去就开启
document.getElementById('app').addEventListener('mouseout', () => {
    _switch.start()
})
</script>
</html>
)
}

if (v == "setInterval 强大的解决方案") {
Var = 
(
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ECharts</title>
    <script src="https://lib.baomitu.com/echarts/4.1.0/echarts.min.js"></script>
</head>
<body>
    <div id="app" style="width: 600px; height:400px;"></div>
</body>

<script>
// 基于准备好的dom，初始化echarts实例
var myChart = echarts.init(document.getElementById('app'))

// mock data
var data = [
    { value: 10, name: '就业保障类' },
    { value: 15, name: '城市建设类' },
    { value: 25, name: '民政救济类' },
    { value: 20, name: '市场监管类' },
    { value: 35, name: '市容城管类' },
    { value: 30, name: '公共安全类' },
    { value: 40, name: '公安消防类' },
]

// 核心配置
var option = {
    legend: {
        x: 'center',
        y: 'bottom',
        data: data.map(_ => _.name)
    },
    series: [{
        type: 'pie',
        radius: [25, 95],
        center: ['50`%', 140],
        roseType: 'area',
        clockWise: false,
        itemStyle: {
            normal: {
                label: {
                    formatter: ['{b}', '占比{d}`%'].join('\n'),
                    textStyle: { color: '#000', fontSize: 12 }
                },
            },
            emphasis: {
                label: {
                    textStyle: { color: '#000', fontSize: 24 }
                }
            }
        },
        data: data
    }]
}

myChart.setOption(option)

/**
 * MerryGoRound
 *
 * @param  {Function} 需要轮询的函数
 * @param  {Number}   轮询间隔
 * @param  {Number}   索引开始位置
 */
function MerryGoRound (fn, interval = 1500, current = 0) {
    // 时间器
    let timer = null

    // 开始
    const start = function (reset = false, IIFE = false) {
        // 是否重置？
        if (reset) {
            timer = null
            current = 0
        }

        // 如果旋转木马已经启动，那么不重复开启
        if (timer) {
            return timer
        }

        // 如果不是函数那么返回错误
        if (fn instanceof Function === false) {
            return console.warn('First arguments must be a function.')
        }

        // 是否使用 IIFE 解决 setInterval 首次不执行的尴尬
        IIFE && fn(current++)

        // 设置计时器timer
        timer = setInterval(() => fn(current++), interval)

        // 还是要返回timer好一点
        return timer
    }

    // 停止
    const stop = function (reset = false, stopfn) {
        // 停止回调函数
        stopfn && stopfn(current)

        // 是否重置索引为0
        if (reset) {
            current = 0
        }

        // 清空轮播器
        timer = clearInterval(timer)
    }

    // 返回开关
    return { start, stop }
}

// 我的echarts的轮播器核心函数
var wheelPlanting = (len, current) => {
    // 先取消上一次高亮
    myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: current `% len })
    // 高亮当前节点
    myChart.dispatchAction({ type: 'highlight', seriesIndex: 0, dataIndex: ++current `% len })
}

// 获取节点的数量
const len = myChart.getOption().series[0].data.length

// 预设值（参考【偏应用】和【科里化】的简易做法）
var _wheelPlanting = wheelPlanting.bind(null, len)

// 返回一个开关
var _switch = new MerryGoRound(_wheelPlanting)

// 按下 “开”
_switch.start()

/**
 * 虽然 Echarts 有提供 mycharts.on('mouseover') 和 mycharts.on('mouseout')。
 * 但建议还是直接用 DOM 来主导 mouseover/mouseout，否则有一些麻烦的问题。
 * 请自行斟酌选择使用。
 */

// 移动过去就暂停
document.getElementById('app').addEventListener('mouseover', () => {
    // 停止，实际上这个stopfn回调，最好也是用一下预设值，但为了简单还是直接使用了位于全局的len。特殊情况再特殊处理吧。
    _switch.stop(false, current => {
        // 先取消上一次高亮
        myChart.dispatchAction({ type: 'downplay', seriesIndex: 0, dataIndex: current `% len })
    })
})

// 移动过去就开启
document.getElementById('app').addEventListener('mouseout', () => {
    _switch.start()
})
</script>
</html>
)
}


if (v == "参数缓存器") {
_send("paramscache", true, true)
return
}


if (v == "用 IIFE 解决 setInterval 首次不执行的尴尬") {

Var = 
(
(function(fn, t) {
	// 立即执行一次，这也是这个IIFE的目的：为了解决 setInterval 首次不执行的尴尬
	fn && fn()
	// 返回计时器timer
	return setInterval(fn, t)
})(f, 6000)
)
}

if (v == "通过URL判断是否本地开发环境") {
Var = 
(
const baseUrl = (function(){
	if (window.location.origin === 'file://' || ~window.location.host.indexOf("localhost") || ~window.location.host.indexOf("192.168")) {
		return 'http://12345v1.dgdatav.com:6080'
	} else {
		return '/api'
	}
}());
)
}

if (v == "将参数arguments转化为一个数组Array.prototype.slice.call(arguments)") {
Var = 
(
Array.prototype.slice.call(arguments)
)
}

if (v == "首字母大写 _.charAt(0) 的使用") {
Var = 
(
['lee', 'mp'].map(_ => _.charAt(0).toUpperCase() + _.substr(1)) //  ["Lee", "Mp"]
)
}

if (v == "超简单的链式调用套路：即让方法调用结束后返回对象本身") {
Var = 
(
var User = function () {
	this.id = null
	this.name = null
}

User.prototype.setId = function ( id ) {
	this.id = id
	return this
}

User.prototype.setName = function ( name ) {
	this.name = name
	return this
}

console.log(new User().setId(1234).setName('Lee'))
)
}

if (v == "单例模式：生成不重复的随机数") {
_send("singlerand", true, true)
return
}

if (v == "欧几里得算法（分而治之）：目标使土地分配最大化，不断让宽与高求余，直到整数倍为止") {
_send("oujilide", true, true)
return
}

if (v == "timeChunk 分时分批处理函数") {
Var = 
(
var timeChunk = function ( ary, fn, count, wait) {
	var start = function () {
		// 每次循环count次数，如果长度不够count时，就取剩余长度。这是个不错的判断思维。用Main.min
		for (var i = 0; i < Math.min( count || 1, ary.length ); i++) {
			// 不断从数组取出内容进行操作
			var obj = ary.shift()
			fn(obj)
		}
	}

	return function () {
		var timer = setInterval(function () {
			if (ary.length === 0) {
				return clearInterval(timer);
			}
			start()
		}, wait || 200);
	}
}

var ary = [...Array(1000)].map((v, index, array) => index)

var render = timeChunk( ary, function ( n ) {
	var div = document.createElement('div')
	div.innerHTML = n;
	document.body.appendChild( div );
}, 8)

render();
)
}

if (v == "超简单的currying与理财花销实例") {
Var = 
(
var currying = function (fn) {
	var args = [];
	return function () {
		// 新设计：如果不传参数则立刻返回当前计算结果
		if ( arguments.length === 0 ) {
			// 返回执行结果
			return fn.apply(this, args);
		} else {
			// 将参数加入缓存
			Array.prototype.push.apply( args, arguments );
			// 返回本函数
			return arguments.callee;
		}
	}
}

// 测试：理财函数
var cost = function(){
	return Array.prototype.reduce.call(arguments, function (previousValue, currentValue, index, array) {
		return previousValue + currentValue
	}, 0)
};

// cost(100, 200, 300, 400)

var curring_cost = currying(cost)

curring_cost( 1000 )
curring_cost( 1000 )
curring_cost( 1000 )
curring_cost( 1000 )

curring_cost(  )
)
}

if (v == "Function.prototype.call：除了参数为数组/类数组以外的都应该使用call，如map/reduce/filter（因为他们的参数都是函数）等") {
Var = 
(
var cost = (function(){
	var money = 0;
	return function () {
		return Array.prototype.reduce.call(arguments, function (previousValue, currentValue, index, array) {
		    return previousValue + currentValue
		}, 0)
	}
}());

cost(100, 200, 300, 400)
)
}

if (v == "简写Array.prototype.push.apply的方法：[].push.apply") {
Var = 
(
[].push.apply
)
}

if (v == "(...arr)数组解构的前辈：Array.prototype.push.apply(arr, newArr)") {
Var = 
(
Array.prototype.push.apply(arr, newArr)
)
}


if (v == "函数调用注入args：successFn.apply(this, arguments)") {
Var = 
(
successFn.apply(this, arguments)
)
}


if (v == "去重复版本的axios") {
SendLevel 1
Send, singaxios{tab}
return
}

if (v == "(=・ω・=)我的单例版ajax") {
SendLevel 1
Send, singeajax{tab}
return
}
if (v == "强制转化为Boolean类型：!!(a && b)") {
Var = 
(
var a = 1, b = 0
console.log(!!(a && b))
)
}

if (v == "img判断加载完成") {
SendLevel 1
SendInput, imgonload{tab}
return
}


if (v == "create 创建img") {
SendLevel 1
SendInput, createimg{tab}
return
}


if (v == "mask蒙版") {
SendLevel 1
SendInput, mask{tab}
return
}

if (v == "create 创建元素") {
Var = 
(
var div = document.createElement('div')
div.style = 'position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 199307100337; background-color: rgba(0,0,0,.3);'
document.body.append(div)
// document.body.insertBefore(div, document.body.firstChild)
)
}

if (v == "插入body前面") {
Var = 
(
var div = document.createElement('div')
div.style = 'position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 199307100337; background-color: rgba(0,0,0,.3);'
div.innerHTML = '123'
// document.body.append(div)
document.body.insertBefore(div, document.body.firstChild)
)
}

if (v == "插入body后面") {
Var = 
(
var div = document.createElement('div')
div.style = 'position: fixed; top: 0; right: 0; bottom: 0; left: 0; z-index: 199307100337; background-color: rgba(0,0,0,.3);'
div.innerHTML = '123'
document.body.append(div)
// document.body.insertBefore(div, document.body.firstChild)
)
}


if (v == "函数参数对象深度结构与重命名： var a = ({ state: { nums:list, numGroup, map } }) => {}") {
Var = 
(
var a = ({ state: { nums: list, numGroup, map } }) => {
	console.log('num重命名为list了', list, numGroup, map)
}

a({state: {nums: 1, numGroup: 2, map: 3 } })
)
}

if (v == "模拟真实点击click，专门对付clickoutside") {
Var = 
(
var evmousedown = document.createEvent('HTMLEvents');
// evmousedown.clientX = 88
// evmousedown.clientY = 18

evmousedown.initEvent('mousedown', false, true);
var evmouseup = document.createEvent('HTMLEvents');
// evmouseup.clientX = 88
// evmouseup.clientY = 18

evmouseup.initEvent('mouseup', false, true);
document.dispatchEvent(evmousedown)
document.dispatchEvent(evmouseup)
var evmouseclick = document.createEvent('HTMLEvents');
// evmouseclick.clientX = 88
// evmouseclick.clientY = 18

evmouseclick.initEvent('click', false, true);
document.dispatchEvent(evmouseclick)
document.dispatchEvent(evmouseclick)
)
}

if (v == "koajs 核心函数compose的超简单源码实现") {
Var = 
(
// https://github.com/koajs/compose/blob/master/index.js
function compose (middleware) {
  if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
  for (const fn of middleware) {
    if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
  }
  return function (context, next) {
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i <= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}

const a = async (ctx, next) => {
  console.log(1)
  const hello = await Promise.resolve('hello')
  console.log(hello)

  await next()
  console.log('a end')
}

const b = async (ctx, next) => {
  console.log(2)
  const hello = await Promise.resolve('hello')
  console.log(hello)

  await next()
  console.log('b end')
}

compose([a, b])({});
// 1
// hello
// 2
// hello
// b end
// a end
)
}

if (v == "仿rxjs的观察者模式") {
Var = 
(
function Observable(fn) {

	let isComplete = false

	return ({ next, complete, error }) => {
		function _next(...args) {
			if (isComplete) 
				return
			next(...args)
		}

		function _complete(...args) {
			complete(...args)
			isComplete = true
		}

		function _error(...args) {
			error(...args)
		}

		// 依赖注入
		fn({ next: _next, complete: _complete, error: _error })

		// 返回开关
		return () => (isComplete = true)
	}
}

let observerable = Observable(observer => {
	setTimeout(() => {
		observer.next(1)
	}, 1000)
	observer.next(2)
	observer.complete(3)
})

const subject = {
	next: value => {
		console.log(value)
	},
	complete: console.log,
	error: console.log
}

let unsubscribe = observerable(subject);

// 输出 2
// 输出 3
// 并没有输出1，因为 complete 之后 next 就不会生效了。
)
}

if (v == "Promise.race只返回最快的一个") {
Var = 
(
const getName = new Promise((resolve, reject) => {
   setTimeout(function () {
        resolve('success') // reject('fail')
   }, 50);
})

const getNumber = Promise.resolve(1)

Promise.race([getName, getNumber])
	.then(console.log) // 输出 1 只输出最快返回的一个
	.catch(console.log)
)
}

if (v == "anime.js 点击烟花绽放效果") {
Var = 
(
<script src="https://cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<canvas class="fireworks" style="position: fixed; left: 0px; top: 0px; z-index: 1; pointer-events: none;" width="2880" height="832"></canvas>

// fireworks.js

"use strict";
function updateCoords(e) {
    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left,
    pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top
}
function setParticuleDirection(e) {
    var t = anime.random(0, 360) * Math.PI / 180
      , a = anime.random(50, 180)
      , n = [-1, 1][anime.random(0, 1)] * a;
    return {
        x: e.x + n * Math.cos(t),
        y: e.y + n * Math.sin(t)
    }
}
function createParticule(e, t) {
    var a = {};
    return a.x = e,
    a.y = t,
    a.color = colors[anime.random(0, colors.length - 1)],
    a.radius = anime.random(16, 32),
    a.endPos = setParticuleDirection(a),
    a.draw = function() {
        ctx.beginPath(),
        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),
        ctx.fillStyle = a.color,
        ctx.fill()
    }
    ,
    a
}
function createCircle(e, t) {
    var a = {};
    return a.x = e,
    a.y = t,
    a.color = "#F00",
    a.radius = .1,
    a.alpha = .5,
    a.lineWidth = 6,
    a.draw = function() {
        ctx.globalAlpha = a.alpha,
        ctx.beginPath(),
        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),
        ctx.lineWidth = a.lineWidth,
        ctx.strokeStyle = a.color,
        ctx.stroke(),
        ctx.globalAlpha = 1
    }
    ,
    a
}
function renderParticule(e) {
    for (var t = 0; t < e.animatables.length; t++)
        e.animatables[t].target.draw()
}
function animateParticules(e, t) {
    for (var a = createCircle(e, t), n = [], i = 0; i < numberOfParticules; i++)
        n.push(createParticule(e, t));
    anime.timeline().add({
        targets: n,
        x: function(e) {
            return e.endPos.x
        },
        y: function(e) {
            return e.endPos.y
        },
        radius: .1,
        duration: anime.random(1200, 1800),
        easing: "easeOutExpo",
        update: renderParticule
    }).add({
        targets: a,
        radius: anime.random(80, 160),
        lineWidth: 0,
        alpha: {
            value: 0,
            easing: "linear",
            duration: anime.random(600, 800)
        },
        duration: anime.random(1200, 1800),
        easing: "easeOutExpo",
        update: renderParticule,
        offset: 0
    })
}
function debounce(e, t) {
    var a;
    return function() {
        var n = this
          , i = arguments;
        clearTimeout(a),
        a = setTimeout(function() {
            e.apply(n, i)
        }, t)
    }
}
var canvasEl = document.querySelector(".fireworks");
if (canvasEl) {
    var ctx = canvasEl.getContext("2d")
      , numberOfParticules = 30
      , pointerX = 0
      , pointerY = 0
      , tap = "mousedown"
      , colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"]
      , setCanvasSize = debounce(function() {
        canvasEl.width = 2 * window.innerWidth,
        canvasEl.height = 2 * window.innerHeight,
        canvasEl.style.width = window.innerWidth + "px",
        canvasEl.style.height = window.innerHeight + "px",
        canvasEl.getContext("2d").scale(2, 2)
    }, 500)
      , render = anime({
        duration: 1 / 0,
        update: function() {
            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)
        }
    });
    document.addEventListener(tap, function(e) {
        "sidebar" !== e.target.id && "toggle-sidebar" !== e.target.id && "A" !== e.target.nodeName && "IMG" !== e.target.nodeName && (render.play(),
        updateCoords(e),
        animateParticules(pointerX, pointerY))
    }, !1),
    setCanvasSize(),
    window.addEventListener("resize", setCanvasSize, !1)
}
)
}

if (v == "es6 超简洁版Event事件模块") {
Var = 
(
class Event {
	constructor(props) {
	    this.map = {}
	}

	add (name, fn) {
		if (this.map[name])
			this.map[name].push(fn)
		else
			this.map[name] = [fn]
		return this
	}

	emit (name, ...args) {
		// 遍历数组中的所有函数并且执行，注入args
		this.map[name].forEach(_ => _(...args))
		// 返回prototype可以形成链式
		return this
	}
}

let e = new Event()
// 我们约定第一个参数是err信息，如果没有错误则注入null
e.add("hello", (err, name) => {
	if (err) return console.error(err)
	console.log(name)
})
.emit('hello', '发送错误')
.emit('hello', null, 'success')
)
}


if (v == "...args参数和fn(...args) 入参的技巧和认知") {
Var = 
(
emit (name, ...args) {
    // 遍历数组中的所有函数并且执行，注入args
    this.map[name].forEach(_ => _(...args))
    // 能形成链式
    return this
}
)
}

if (v == "多个异步操作时，请毫不犹豫用Pormise.all") {
Var = 
(
const getName = new Promise((resolve, reject) => {
   setTimeout(function () {
        resolve('success') // reject('fail')
   }, 50);
})
Promise.all([getName, getName])
	.then(console.log)
	.catch(console.log)
)
}

if (v == "对象字面量如何使用async/await标记") {
Var = 
(
// 其实很简单，最最前面加入即可。
async init ({ commit, state, dispatch, rootState })  {
    // 获取部门id列表（包含重映射部门id）
    await dispatch('getAllDepartmentItems')
    // 获取事项id列表（包含重映射事项id）
    await dispatch('getAllMatterItems')
},

// 如果是传统的也可以这样
init: async function  ({ commit, state, dispatch, rootState }) {
    // 获取部门id列表（包含重映射部门id）
    await dispatch('getAllDepartmentItems')
    // 获取事项id列表（包含重映射事项id）
    await dispatch('getAllMatterItems')
}
)
}


if (v == "获取localStorage剩余容量和最大容量") {
Var = 
(
// 获取localStorage最大容量
(function() {
   if(!window.sessionStorage) {
        console.log('当前浏览器不支持sessionStorage!')
   }    
   var test = '0123456789';
   var add = function(num) {
     num += num;
     if(num.length == 10240) {
       test = num;
       return;
     }
     add(num);
   }
   add(test);
   var sum = test;
   var show = setInterval(function(){
      sum += test;
      try {
       window.sessionStorage.removeItem('test');
       window.sessionStorage.setItem('test', sum);
       console.log(sum.length / 1024 + 'KB');
      } catch(e) {
       console.log(sum.length / 1024 + 'KB超出最大限制');
       clearInterval(show);
      }
   }, 0.1)
 })()


// 获取sessionStorage的剩余容量
(function(){
    if(!window.sessionStorage) {
        console.log('浏览器不支持sessionStorage');
    }
    var size = 0;
    for(item in window.sessionStorage) {
        if(window.sessionStorage.hasOwnProperty(item)) {
            size += window.sessionStorage.getItem(item).length;
        }
    }
    console.log('当前sessionStorage剩余容量为' + (size / 1024).toFixed(2) + 'KB');
})()
)
}

if (v == "memoized 函数缓存") {
SendLevel 1
Send, funcache{tab}
return
}

if (v == "是否隐藏：$('#div').is(':hidden')") {
Var = 
(
$('#div').is(':hidden')
)
}

if (v == "是否显示：$('#div').is(':visible')") {
Var = 
(
$('#div').is(':visible')
)
}

if (v == "clickOutSide：!el.contains(event.target)") {
Var = 
(
handle = e => {
  const el = this.container
  // 核心: el.contains()，这里的el就是弹窗本身，换句话就是inSide
  if (el && !el.contains(e.target)) onClickOutside(e)
}

// 点击事件函数
const func = e => {
  // 如果点击的不是弹窗本身，那么关闭它
  if (!this.$refs.tabbar.contains(e.target)) {
    // 取消显示
    this.isShow = false
    // 取消点击事件
    document.removeEventListener('mouseup', func)
  }
}
// clickoutside
document.addEventListener('mouseup', func)
)
}

if (v == "（回调版）单例模式，通常用于ajax类") {
Var = 
(
// （回调版）单例模式，通常用于ajax类
var getCallBackSingle = function(fn) {
    // 缓存
    var cache;
    // 接受一个回调函数
    return function (cb) {
        // 如果有缓存存在，那么直接使用缓存作为回调值，否则使用默认函数
        cache ? cb.apply(this, cache) : fn(function () {
            console.log('no cache')
            // 保存到缓存并且执行回调
            cb.apply(this, cache = arguments)
        })
    }
};

// demo：获取所有内容
var getData = function (successcb) {
    $.ajax({
        url: "/search.json",
        dataType: 'json',
        success: successcb,
        error: function(e, m){
           console.log('数据接口请求异常', e, m);
        }
    })
}

// 使用示例
var _getData = getCallBackSingle(getData)
_getData(_ => {console.log(20190126191340, _)}) // no cache，[...]
_getData(_ => {console.log(20190126191340, _)}) // [...]
)
}


if (v == "parseInt/parseFloat可以直接移除字符串：parseFloat(layero.css('left')) // '162px' => 162") {
Var = 
(
dict.offset = [
    e.clientX - parseFloat(layero.css('left')),
    e.clientY - parseFloat(layero.css('top'))
;
)
}


if (v == "filterhtml: 移除html标签，只提取文本text()") {
SendLevel 1
Send, filterhtml{tab}
return
}

if (v == "window.onunload 刷新/关闭页面之前发送请求") {
SendLevel 1
Send, window.onunload{tab}
return
}

if (v == "js获取root（window）对象") {
Var = 
(
var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};
)
}


if (v == "高度从0到auto的伸缩特效魔法") {
Var =
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
    .el {
        transition: max-height 0.5s;
        overflow: hidden;
        max-height: 0;
    }

    .trigger:hover>.el {
        max-height: var(--max-height);
    }
    </style>
</head>

<body>
    <div class="trigger">
        Hover me to see a height transition.
        <div class="el">content</div>
    </div>
</body>
<script>
var el = document.querySelector('.el')
var height = el.scrollHeight
el.style.setProperty('--max-height', height + 'px')
</script>

</html>
)
}

if (v == "获取前6个月/前15天数据") {
Var = 
(
/**
 * 生成日报模式下的 xAxisDate 数据，
 * 业务需求:  如果是日报（day）则是取前半个月的数据，即15条数据
 * @param {String} str 当前用户选择的日报时间
 * @param {Number} len 往前获取多少天？
 * @return {Array} 如：["20181211","20181210","20181209","20181208","20181207", "20181206","20181205","20181204","20181203","20181202", "20181201","20181130","20181129","20181128","20181127"] 
 */
getDayxAxisDate(str, len) {
    // 转化为date对象
    const _date = new Date(str.substring(0, 4), str.substring(4, 6) - 1, str.substring(6, 8))

    // 往前取半个月15天
    return [...Array(len)].map((v, index, array) => {
        // 不断地回退day
        _date.setDate(_date.getDate() - 1)
        // YYYYMMDD
        return _date.getFullYear() + PrefixInteger(_date.getMonth() + 1, 2) + PrefixInteger(_date.getDate(), 2)
        // 翻转一下顺序，让数组符合desc顺序的直觉
    }).reverse()
},

/**
 * 生成月报模式下的 xAxisDate 数据，
 * 业务需求:  如果是月报（month）则是取前半年的数据，即6条数据
 * @param {String} str 当前用户选择的月报时间
 * @param {Number} len 往前获取几个月？
 * @return {Array} 如： ["20181207","20181208","201809","201810","201811","201812"]
 */
getMonthxAxisDate(str, len) {
    // 转化为date对象
    const _date = new Date(str.substring(0, 4), str.substring(4, 6) - 1)
    // 往前取半年6个月
    return [...Array(len)].map((v, index, array) => {
        // 不断地回退month
        _date.setMonth(_date.getMonth() - 1)
        // MM
        return PrefixInteger(_date.getMonth() + 1) + '月'
        // 翻转一下顺序，让数组符合desc顺序的直觉
    }).reverse()
},
)
}




if (v == "获取手机归属地信息：中国移动/中国联通/中国电信") {
Var = 
(
/**
 * @func
 * @desc - 获取手机归属地信息
 * @param {string} phoneNo - 手机号码
 * @param {string} callback - 回调函数
 */
var getPhoneData = function(phoneNo, callback) {
    $.ajax({
        url: 'http://tcc.taobao.com/cc/json/mobile_tel_segment.htm',
        type: 'get',
        data: {
            tel: phoneNo
        },
        success: function(result) {
            if (result) {
                var _data = result.split('=')[1]
                _data = _data.replace(/\s+/g, "").replace(/<\/?.+?>/g, "").replace(/[\r\n]/g, "").replace(/\'/g, '"').replace(/\:/g, '":').replace(/\,/g, ',"').replace('{', '{"')
                var phoneData = JSON.parse(_data);
                console.log(phoneData)
                if (phoneData.catName === '中国移动') {
                    applyData.PhoneType = 1;
                } else if (phoneData.catName === '中国联通') {
                    applyData.PhoneType = 2
                } else if (phoneData.catName === '中国电信') {
                    applyData.PhoneType = 3
                } else {
                    applyData.PhoneType = 0
                }
                applyData.PhoneAddress = phoneData.province
            }
        },
        error: function(result) {
            console.info('无法获取手机归属地信息');
        },
        complete: function() {
            typeof callback === 'function' && submitApply();
        }
    })
}

)
}

if (v == "闭包与Cache") {
Var = 
(
/**
 * @func
 * @desc - 灵活使用闭包的概念。
           以下简单的实验说明他们是不同的实例。所以他们各自闭包内的_cache是不相干也不相同的
           其实是简单的类与实例的概念。但还是说明一下比较好
           毕竟大部分的插件也是这样制作的
 */
var Cache = (function () {
    var _cache = {};

    return {
      getCache: function (key) {
        return _cache[key]
      },
      setCache: function (key, value) {
        _cache[key] = value;
      },
      showAllCache: function () {
        console.log(_cache);
      }
    }
});


var a = new Cache();
a.setCache('foo', 'bar');
a.showAllCache();

var b = new Cache();
b.setCache('foo', 'bar2');
b.showAllCache();

/* 从输出的结果得知两者的闭包互不相干 */
)
}

if (v == "Android 输入法键盘 和 input 问题:scrollIntoViewIfNeeded") {
Var = 
(
/**
 * Android 输入法键盘 和 input 问题
 */
if(getSys() === 'Android') {
    window.addEventListener("resize", function() {
        if(document.activeElement.tagName=="INPUT" || document.activeElement.tagName=="TEXTAREA") {
           window.setTimeout(function() {
                document.activeElement.scrollIntoViewIfNeeded();
           }, 0);
       }
    })
}
)
}


if (v == "优惠券条件分支：链式after解决方案") {
Var = 
(
Function.prototype.after = function(fn) {
    var self = this;
    return function() {
        var ret = self.apply(this, arguments);  
        if (ret === 'next') {
            return fn.apply(this.arguments);
        }
    }
}

var order500yuan = function(orderType, pay, stock) {
    if (orderType === 1 && pay === true) {
        console.log('500 元定金预购，得到 100 优惠券');
    } else {
        return 'next'; // 我不知道下一个节点是谁，反正把请求往后面传递
    }
};

var order200yuan = function(orderType, pay, stock) {
    if (orderType === 2 && pay === true) {
        console.log('200 元定金预购，得到 50 优惠券');
    } else {
        return 'next'; // 我不知道下一个节点是谁，反正把请求往后面传递
    }
};

var orderNormal = function(orderType, pay, stock) {
    if (stock > 0) {
        console.log('普通购买，无优惠券');
    } else {
        console.log('手机库存不足');
    }
};

var order = order500yuan.after( order200yuan ).after( orderNormal );
order( 1, true, 500 )
order( 2, true, 500 );
order( 1, false, 500 );
)
}

if (v == "Function.prototype.before") {
SendLevel 1
Send, fn.before{tab}
return
}

if (v == "Function.prototype.after") {
SendLevel 1
Send, fn.after{tab}
return
}

if (v == "模板抽象类接口：咖啡与茶") {
Var = 
(
// 继承抽象类的目的，通常是可以为了可以省略很多重复的操作，或者帮你完成了很多基础工作，譬如本例的煮水（boilWater）
// 但接口还强制你重写/实现/覆盖指定方法譬如brew, pourIncup, addCondiments来搜集配置和个性化需求。
// 这种模式也成为模板模式。可以脑补【模板页面】的场景
var Beverage = function() {};
Beverage.prototype.boilWater = function() {
	console.log( '把水煮沸' );
};
Beverage.prototype.brew = function() {
	throw new Error( '子类必须重写 brew 方法' );
};
Beverage.prototype.pourIncup = function() {
	throw new Error( '子类必须重写 pourIncup 方法' );
};
Beverage.prototype.addCondiments = function() {
	throw new Error( '子类必须重写 addCondiments 方法' );
};
Beverage.prototype.init = function() {
    this.boilWater();
    this.bubbleBeverage();
    this.pourCup();
    this.addCondiments();
};

var Coffee = function() {};
// 原型继承抽象类
Coffee.prototype = new Beverage();

Coffee.prototype.bubbleBeverage = function() {
    console.log("开水冲泡咖啡.");
};
Coffee.prototype.pourCup = function() {
    console.log("咖啡倒入杯中.");
};
Coffee.prototype.addCondiments = function() {
    console.log("添加糖和牛奶.");
};

var coffee = new Coffee();
coffee.init();
)
}

if (v == "解构与split结合：const [language, country] = locale.split('-')") {
Var = 
(
const [language, country] = locale.split('-')
)
}

if (v == "模块模式：现代模块实现的基石") {
Var = 
(
var Module = (function($){
    var _$body = $("body");     // we can use jQuery now!
    var foo = function(){
        console.log(_$body);    // 特权方法
    }

    // Revelation Pattern
    return {
        foo: foo
    }
})(jQuery)

Module.foo();
)
}

if (v == "社会主义点击事件") {
Var = 
(
(function() {
    var coreSocialistValues = ["富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"]
      , index = Math.floor(Math.random() * coreSocialistValues.length);
    document.body.addEventListener('click', function(e) {
        if (e.target.tagName == 'A') {
            return;
        }
        var x = e.pageX
          , y = e.pageY
          , span = document.createElement('span');
        span.textContent = coreSocialistValues[index];
        index = (index + 1) `% coreSocialistValues.length;
        span.style.cssText = ['z-index: 9999999; position: absolute; font-weight: bold; color: #ff6651; top: ', y - 20, 'px; left: ', x, 'px;'].join('');
        document.body.appendChild(span);
        animate(span);
    });
    function animate(el) {
        var i = 0
          , top = parseInt(el.style.top)
          , id = setInterval(frame, 16.7);
        function frame() {
            if (i > 180) {
                clearInterval(id);
                el.parentNode.removeChild(el);
            } else {
                i += 2;
                el.style.top = top - i + 'px';
                el.style.opacity = (180 - i) / 180;
            }
        }
    }
}());
)
}

if (v == "urlparams 获取路由参数") {
SendLevel 1
Send, urlparams{tab}
return
}

if (v == "构造器借用") {
Var = 
(
function Shape(id) {
  this.id = id;
}
Shape.prototype.name = 'shape'
Shape.prototype.toString = function () {
  return this.name
}

function Triangle() {
  Shape.apply(this, arguments)
}
Triangle.prototype.name = 'Triangle'

var t = new Triangle(101);
t.name; // "Triangle"
)
}

if (v == "寄生式继承") {
Var = 
(
// 在创建对象的函数中直接吸收其他对象的功能，然后对其进行扩展并返回。“就好像所有的工作都是自己做的一样无耻！”
// 寄生式继承并没有涉及什么新的模式和语法，只是一种概念认知。
var twoD = {
  name: '2D shape',
  dimensions: 2
}

function triangle(s, h) {
  var that = Object(twoD);
  that.name = 'TRIANGLE';
  that.side = s;
  that.height = h;
  that.getArea = function () {
    return this.side * this.height / 2;
  };
  return that;
}

var t = triangle(5, 10);
t.dimensions; // 2
)
}

if (v == "multi 多重拷贝") {
Var = 
(
function multi() {
  var n = {}, stuff, j = 0, len = arguments.length;
  for (var i = 0; i < len; i++) {
      stuff = arguments[j];
      for (var i in stuff) {
        if (stuff hasOwnProperty(i)) {
          n[i] = stuff[i];
        }
      }
  }
  return n
}
)
}

if (v == "通用的惰性单例") {
Var = 
(
var getSingle = function(fn) {
     var result;
     return function() {
         return result || (result = fn.apply(this, arguments));
     }
};
)
}


if (v == "惰性单例") {
Var = 
(
var Singleton = function(name) {
     this.name = name;
};
Singleton.getInstance = (function() {
     var instance = null;
     return function(name) {
         if (!instance) {
             instance = new Singleton(name);
         }
         return instance;
     }
})();
var a = Singleton.getInstance( 'sven1' );
var b = Singleton.getInstance( 'sven2' );
alert ( a === b ); // true
)
}

if (v == "透明单例") {
Var = 
(
var CreateDiv = (function() {
     var instance;
     var _CreateDiv = function(html) {
         if (instance) {
             return instance;
         }
         this.html = html;
         this.init();
         return instance = this;
     };
     _CreateDiv.prototype.init = function() {
         var div = document.createElement('div');
         div.innerHTML = this.html;
         document.body.appendChild(div);
     };
     return _CreateDiv;
})();

var a = new CreateDiv('sven1');
var b = new CreateDiv('sven2');
alert(a === b); // => true
)
}

if (v == "代理单例") {
Var = 
(
// 普通的创建 div 的类：
var CreateDiv = function(html) {
     this.html = html;
     this.init();
};
CreateDiv.prototype.init = function() {
     var div = document.createElement('div');
     div.innerHTML = this.html;
     document.body.appendChild(div);
};
// 引入代理类
var ProxySingletonCreateDiv = (function() {
    var instance;
    return function(html) {
        if (!instance) {
            instance = new CreateDiv(html);
        }
        return instance;
    }
})();
var a = new ProxySingletonCreateDiv('sven1');
var b = new ProxySingletonCreateDiv('sven2');
alert(a === b);
)
}

if (v == "封装") {
Var = 
(
// JavaScript并没有提供private、public、protected 关键字来提供不同的访问权限，我们只能依赖变量的 作用域来实现封装特性
var Module = (function(){
    var _private = "safe now";
    var foo = function(){
        console.log(_private)
    }

    return {
        foo: foo
    }
})()

Module.foo();    // "safe now"
Module._private; // undefined
)
}


if (v == "多态") {
Var = 
(
var makeSound = function(animal) {
    if (animal instanceof Duck) {
        console.log('嘎嘎嘎');
    } else if (animal instanceof Chicken) {
        console.log('咯咯咯');
    }
};
var Duck = function() {};
var Chicken = function() {};
makeSound(new Duck());    // 嘎嘎嘎
makeSound(new Chicken()); // 咯咯咯

//////////////////////////////////////////////
// 
//////////////////////////////////////////////
var renderMap = function( map ){
  if ( map.show instanceof Function ){
     map.show();
  }
};
renderMap( googleMap ); // 输出：开始渲染谷歌地图
renderMap( baiduMap );  // 输出：开始渲染百度地图

// 即使以后增加了搜搜地图， renderMap 函数仍、然不需要做任何改变，如下所示：
var sosoMap = {
  show: function(){
     console.log( '开始渲染搜搜地图' );
  }
};
renderMap( sosoMap ); // 输出：开始渲染搜搜地图
)
}


if (v == "基于原型模式的继承") {
Var = 
(
var A = function(){};
var B = function(){};
A.prototype = { name: 'sven' };

// 核心
B.prototype = new A();
var b = new B();
console.log( b.name ); // 输出：sven
)
}


if (v == "call 和 apply") {
Var = 
(
)
}


if (v == "AOP - 面向切面编程") {
Var = 
(
// （A）定义原始函数
var func = function() {
    console.log(2);
};

Function.prototype.before = function(beforefn) {
    // 保存原始函数（A）的引用
    var __self = this;

    // （B）
    return function() { 
        // 执行 before 函数
        beforefn.apply(this, arguments); 

        // 执行原始函数（A）
        return __self.apply(this, arguments);
    }
};

Function.prototype.after = function(afterfn) {
    // 保存函数（B）的引用
    var __self = this;

    // （C）
    return function() {
        // 执行函数（B）并获取执行结果，而实际上函数（B）的返回的是原始函数（A）的执行结果
        var ret = __self.apply(this, arguments);

        // 执行 after 函数
        afterfn.apply(this, arguments);

        // 返回原函数（A）的执行结果
        return ret;
    }
};

func = func.before(function() {
    console.log(1);
}).after(function() {
    console.log(3);
});

// 执行函数（C）
func();
)
}



if (v == "1、作为对象的方法调用") {
Var = 
(
var obj = {
     a: 1,
     getA: function(){
        alert ( this === obj ); // 输出：true
        alert ( this.a );       // 输出: 1
     }
};
obj.getA();
)
}

if (v == "2、作为普通函数调用时") {
Var = 
(
//////////////////////////////////////////////
// 当函数作为普通函数方式被调用时，此时的 this 总是指向全局对象。
// 如果是在浏览器里，全局对象就是 window。
//////////////////////////////////////////////
window.name = 'windowName';
var getName = function () {
     return this.name;
};
console.log( getName() ); // windowName

// 以下写法和（1）很相似，所以容易混淆，但实际上这种调用函数的方式和（2）也是一样的道理，它指向的是函数执行时的环境，所以需要额外注意一下：
window.name = 'windowName';
var myObject = {
     name: 'sven',
     getName: function(){
        return this.name;
     }
};
var getName = myObject.getName;
console.log( getName() ); // windowName
)
}

if (v == "3、作为构造器调用") {
Var = 
(
//////////////////////////////////////////////
// JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。
// 所有 JavaScript 函数都可以当作构造器使用。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象。
//////////////////////////////////////////////
var MyClass = function(){
     this.name = 'sven';
};
var obj = new MyClass();
alert ( obj.name ); // 输出：sven
)
}


if (v == "4、Function.prototype.call 或 Function.prototype.apply 调用") {
Var = 
(
window.name = 'foo';
var obj1 = {name: 'sven'};
var obj2 = {name: 'anne'};

var getName = function () {
    alert ( this.name );
};
getName();            // 输出: foo
getName.call( obj1 ); // 输出: sven
getName.call( obj2 ); // 输出: anne
)
}


if (v == "6、es6 class 中的") {
Var = 
(

)
}

if (v == "5、es6箭头函数调用时") {
Var = 
(
// 箭头函数自己没有this，只能往上找对象。


// 不适用场合
var fuck = {
	bb: 'bb',
	methods: () =>  {
		console.log(this.bb) // undefined
	}
}
)
}

if (v == "JavaScript版 策略模式") {
SendLevel 1
Send, celue{tab}
return
}


if (v == "加强版map遍历:bettermap") {
SendLevel 1
Send, fuckmap{tab}
return
}

if (v == "injectCss 往页面插入style") {
SendLevel 1
Send, addstyle{tab}
return
}


if (v == "getScriptPath") {
Var = 
(
// http://stackoverflow.com/questions/2161159/get-script-path
function getScriptPath() {
    var scripts = _doc.currentScript || (function () { var s = _doc.getElementsByTagName('script'); return (s.length) ? s[s.length - 1] : false; })();
    var path = scripts ? scripts.src.split('?')[0] : '';
    return (path.split('/').length > 0) ? path.split('/').slice(0, -1).join('/') + '/' : '';
}
)
}


if (v == "处理iOS 微信客户端6.7.4 键盘收起页面未下移bug") {
Var = 
(
/**
 * 处理iOS 微信客户端6.7.4 键盘收起页面未下移bug
 */
;(/iphone|ipod|ipad/i.test(navigator.appVersion)) && document.addEventListener('blur', (e) => {
    // 这里加了个类型判断，因为a等元素也会触发blur事件
    ['input', 'textarea'].includes(e.target.localName) && document.body.scrollIntoView(false)
}, true)
)
}

if (v == "holder占位图") {
Var = 
(
<script src="https://cdn.bootcss.com/holder/2.9.6/holder.min.js"></script>
<img class="card-img-top" data-src="holder.js/100px225?theme=thumb&bg=55595c&fg=eceeef&text=Thumbnail" alt="Card image cap">
)
}

if (v == "dragscroll 拖拽滚动") {
Var = 
(
export const dragScroll = el => {
    var _window = window
        ,_document = document
        ,mousemove = 'mousemove'
        ,mouseup = 'mouseup'
        ,mousedown = 'mousedown'
        ,EventListener = 'EventListener'
        ,addEventListener = 'add'+EventListener
        ,removeEventListener = 'remove'+EventListener
        ,newScrollX, newScrollY;

    // HERE
    var startx,starty, endx, endy;


    return (function(el, lastClientX, lastClientY, pushed, scroller, cont) {
        (cont = el.container || el)[addEventListener](
            mousedown,
            cont.md = function(e) {
                if (!el.hasAttribute('nochilddrag') ||
                    _document.elementFromPoint(
                        e.pageX, e.pageY
                    `) == cont
                `) {
                    pushed = 1;
                    startx = lastClientX = e.clientX;
                    starty = lastClientY = e.clientY;

                    e.preventDefault();
                }
            }, 0
        `);

        el[addEventListener](
            mouseup, cont.mu = function(e) { 
                pushed = 0;  
                // HERE
                endx = e.clientX;
                endy = e.clientY;
                // setTimeout(function(){ el.classList.remove("dragging"); }, 100);
            }, 0
        `);

        el[addEventListener](
            mousemove,
            cont.mm = function(e) {
                if (pushed) {
                    // HERE
                    // el.classList.add("dragging");
                    (scroller = el.scroller || el).scrollLeft -= newScrollX = (-lastClientX + (lastClientX = e.clientX));
                    scroller.scrollTop -= newScrollY = (-lastClientY + (lastClientY = e.clientY));
                    if (el == _document.body) {
                        (scroller = _document.documentElement).scrollLeft -= newScrollX;
                        scroller.scrollTop -= newScrollY;
                    }
                }

            }, 0
        `)

        return function (CLICKHANDLER) {
            if (Math.abs(starty - endy) <= 1) {
                CLICKHANDLER && CLICKHANDLER(el)
            }
        }
    })(el);
}
)
}

if (v == "$.scrollforevery 无缝滚动") {
Var = 
(
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://cdn.bootcss.com/dragscroll/0.0.8/dragscroll.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nicescroll/3.7.6/jquery.nicescroll.min.js"></script>
    <script>
    </script>
    <style>
    html,
    body {
        margin: 0;
        padding: 0;
    }

    *,
    ::after,
    ::before {
        box-sizing: border-box;
    }

    #app {
        height: 200px;
        background: thin;
        width: 200px;
        overflow: scroll;
        cursor: move;
    }

    p {
        height: 40px;
        margin: 0;
        padding: 0;
    }
    </style>
</head>
<body>
    <div id="app" class='dragscroll'>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
        <p>1</p>
    </div>
</body>
<script>
const $app = $('#app')
const innerHeight = 40
const len = 5
const distance = innerHeight * len
let timer = null
const start = () => {
 timer = setInterval(function() {
     const scrollDistance = $app.scrollTop();
     if (scrollDistance >= distance) {
         $app.scrollTop(0)
     } else {
         $app.scrollTop(scrollDistance + 1)
     }
 }, 10);
}

start()

$('#app').niceScroll({ cursorcolor: 'rgba(0,0,0,0.2)', autohidemode: 'hidden' })

$('#app').mouseover(e => {
    clearInterval(timer);
}).mouseleave(e => {
    start()
})
</script>

</html>
)
}

if (v == "$.autoscroll 自动滚动") {
Var = 
(
$.fn.extend({
    'autoScroll': function (options) {
	    // 配置参数
	    var opt = $.extend({}, {speed: 1500, size: 4, height: 40, time: 10000}, options)
	    // jQuery对象
	    var $el = this;
	    // 时间器
	    var timer = null;
	    // 核心函数
	    var _autoScroll = function () {
	        // 自动滚动
	        timer =  setInterval(function () {
	            // 滚动的速度
	            const speed = opt.speed
	            // 每次滚动多少条
	            const size = opt.size;
	            // 每条的高度是多少
	            const height = opt.height;
	            // 每次滚动的距离
	            const distance = size * height;
	            // 当前滚动的高度
	            const currentScrollTop = $el.scrollTop()
	            // 底部位置
	            const bottom = $el.prop('scrollHeight') - $el.height()
	            // 如果已经滚到底了
	            if (Math.floor(currentScrollTop) === Math.floor(bottom)) {
	                // 滚回头部
                    // $el.animate({ scrollTop: 0 }, 0).animate({ scrollTop: distance + 'px' }, speed);
                    // 滚回头部
                    $el.animate({ scrollTop: 0 }, speed);
	            } else {
	                // 余数
	                const remainder = currentScrollTop `% height
	                // 下一次滚动的位置 = 当前位置 + 每次滚动的位置 - 余数
	                const nextScrollTop = currentScrollTop + distance - remainder
	                // 开始滚动
	                $el.animate({ scrollTop: nextScrollTop + 'px' }, speed);
	            }
	        // 滚动间隔
	        }, opt.time + opt.speed);
	        // 鼠标移入的时候，删除自动滚动, 鼠标移出的时候，自动滚动
	        $el.one('mouseover', function () { clearInterval(timer)}).one('mouseleave', _autoScroll)
	        // 将timer放入jQuery对象的缓存中，方便后续操作
	        $el.data('timer', timer)
	    }
	    // 开始滚动
	    _autoScroll()
	    // 返回时间器，方便后续操作
	    return timer
	},
	'stopScroll': function () {
	     // jQuery对象
	    var $el = this;
	    // 时间器
	    var timer = $el.data('timer')
	    // 消除它就是停止它（其实这里还需要结束动画，但就不做那么麻烦了）
	    clearInterval(timer);
	}
});

$('.trajectoryTable').autoScroll()
)
}

if (v == "window.requestAnimFrame") {
SendLevel 1
Send, requestanimate{tab}
return
}

if (v == "encodeURI URI过滤") {
Var = 
(
encodeURI
)
}

if (v == "deepfind 深度递归搜索") {
Var = 
(
var fuck = [
    {
        "label": "占用道路问题",
        "value": 31,
        "children": [
            {
                "label": "经营占道",
                "value": 35,
                "children": [
                    {
                        "label": "店外经营占道",
                        "value": 40,
                        "children": null
                    },
                    {
                        "label": "流动摊贩占道",
                        "value": 41,
                        "children": null
                    }
                ]
            },
            {
                "label": "垃圾占道",
                "value": 36,
                "children": [
                    {
                        "label": "生活垃圾",
                        "value": 42,
                        "children": null
                    },
                    {
                        "label": "建筑垃圾",
                        "value": 43,
                        "children": null
                    },
                    {
                        "label": "工业垃圾",
                        "value": 44,
                        "children": null
                    }
                ]
            },
            {
                "label": "车辆占道",
                "value": 37,
                "children": [
                    {
                        "label": "机动车占道",
                        "value": 45,
                        "children": null
                    },
                    {
                        "label": "非机动车占道",
                        "value": 46,
                        "children": null
                    }
                ]
            },
            {
                "label": "霸占车位",
                "value": 38,
                "children": []
            },
            {
                "label": "其他占道",
                "value": 39,
                "children": []
            }
        ]
    },
    {
        "label": "“两违”问题",
        "value": 32,
        "children": [
            {
                "label": "违法建筑",
                "value": 58,
                "children": [
                    {
                        "label": "房屋违建",
                        "value": 61,
                        "children": null
                    },
                    {
                        "label": "小区违建",
                        "value": 62,
                        "children": null
                    },
                    {
                        "label": "违建棚架",
                        "value": 63,
                        "children": null
                    }
                ]
            },
            {
                "label": "违法用地",
                "value": 59,
                "children": []
            },
            {
                "label": "其他违建",
                "value": 60,
                "children": []
            }
        ]
    },
    {
        "label": "市容设施管理问题",
        "value": 33,
        "children": [
            {
                "label": "道路损坏",
                "value": 47,
                "children": []
            },
            {
                "label": "垃圾桶损坏",
                "value": 48,
                "children": []
            },
            {
                "label": "下水道堵塞",
                "value": 49,
                "children": []
            },
            {
                "label": "井盖损坏",
                "value": 50,
                "children": []
            },
            {
                "label": "路灯损坏",
                "value": 51,
                "children": []
            },
            {
                "label": "树木修剪",
                "value": 52,
                "children": []
            },
            {
                "label": "水电气",
                "value": 53,
                "children": []
            },
            {
                "label": "户外广告牌",
                "value": 54,
                "children": []
            },
            {
                "label": "隔音屏损坏",
                "value": 55,
                "children": []
            },
            {
                "label": "洒水车问题",
                "value": 56,
                "children": []
            },
            {
                "label": "其他",
                "value": 57,
                "children": []
            }
        ]
    },
    {
        "label": "其他问题",
        "value": 34,
        "children": []
    }
]
const deepFind = ({ arr = [], key = '', val = '', children = 'children'} = {}) => {
    // 即将返回的数组
    var main = []
    // 如果没有键也没有值，那么还是直接返回吧
    if (!val || !key) return main
    // 用try方案方便直接中止所有递归的程序
    try {
        // 开始轮询
        (function poll(arr, level) {
            // 如果传入非数组
            if (!Array.isArray(arr)) return
            // 遍历数组
            for (var i = 0; i < arr.length; i++) {
                // 获取当前项
                var item = arr[i]
                // 先占位预设值
                main[level] = item[key]
                // 如果已经找到了
                if (item[key] === val) {
                    // 直接抛出错误中断所有由父及子的所有轮询
                    throw Error
                // 如果存在children，那么深入递归
                } else if (item[children] && item[children].length) {
                    poll(item[children], level + 1)
                // 如果是最后一个了且没有找到值，那么删除之
                } else if (i === arr.length - 1) {
                   // 删除占位预设值
                   main.length = main.length - 1
                }
            }
        })(arr, 0)
    // 错误捕捉仅为程序正常执行
    } catch (err) {}

    // 返回最终数组
    return main
}
var myarr = deepFind({ arr: fuck, key: 'value', val: 63, children: 'children' })
console.log(20181115092957, myarr)
)
}


if (v == "compose 函数组合") {
Var = 
(
function compose () {
	let args = arguments
	let start = args.length - 1

	return function () {
		let i = start
		let result = args[start].apply(this, arguments)
		while (i--)
			result = args[i].call(this, result)
		return result
	}
}

const explode = _ => _.split(/\s+/)
const count = _ => _.length
const countWords = compose(count, explode);
countWords(``a
			b
			c
			d``); // => 4
)
}


if (v == "(〜￣△￣)〜认知～(￣▽￣～)：({a = 123, b = 321, c = 456} = {}) 对象解构 与 参数默认值") {
Var =
(
var abc = ({a = 123, b = 321, c = 456} = {}) => console.log(20181109155055, a)
abc()
)
}

if (v == "Object.assign({}, )") {
Var =
(
Object.assign({}, )
)
}
if (v == "Object.is 比 === 更严格的比较") {
Var =
(
0 === -0 // true
NaN === NaN // false（这也是NaN的特性）

Object.is(0, -0) // false
Object.is(NaN, NaN) // true
)
}

if (v == "'tail' in cat / cat.hasOwnProperty('tail') 判断对象是否包含某属性") {
Var =
(
'tail' in cat
cat.hasOwnProperty('tail')
)
}
if (v == "Object.getOwnPropertyDescriptor({a: 123}, 'a') 获取属性的配置") {
Var =
(
// {value: 123, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor({a: 123}, "a")
)
}
if (v == "Object.defineProperty 属性的权限设置 writable（可写） / configurable（可配置）/enumerable（可枚举）") {
Var =
(
var myObject = {};

Object.defineProperty(myObject, "a", {
  value: 2,
  writable: true,  // 可写
  configurable: true, // 可配置
  enumerable: true  // 可枚举
});

myObject.a // 2
)
}
if (v == "Object.defineProperties 属性的批量权限设置") {
Var =
(

)
}

if (v == "getter / setter") {
Var =
(

)
}

if (v == "delete person.age 删除对象的属性") {
Var =
(
delete person.age
)
}

if (v == "__EVENT__消息订阅") {
Var = 
(
window.__EVENT__ = {
     // 缓存列表
     clientList: [],
     listen: function(key, fn) {
         if (!this.clientList[key]) {
             this.clientList[key] = [];
         }
         // 订阅的消息添加进缓存列表
         this.clientList[key].push(fn);
     },
     trigger: function() {
         var key = Array.prototype.shift.call(arguments),
             fns = this.clientList[key];
         // 如果没有绑定对应的消息
         if (!fns || fns.length === 0) {
             return false;
         }
         for (var i = 0, fn; fn = fns[i++];) {
             // arguments 是 trigger 时带上的参数
             fn.apply(this, arguments);
         }
     },
     remove: function(key, fn) {
         var fns = this.clientList[key];
         if (!fns) { // 如果 key 对应的消息没有被人订阅，则直接返回
             return false;
         }
         if (!fn) { // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅
             fns && (fns.length = 0);
         } else {
             for (var l = fns.length - 1; l >= 0; l--) { // 反向遍历订阅的回调函数列表
                 var _fn = fns[l];
                 if (_fn === fn) {
                     fns.splice(l, 1); // 删除订阅者的回调函数
                 }
             }
         }
    }
};
)
}

if (v == "cache request axios 缓存请求") {
_send("request.js", true, true)
return
}

if (v == "AMD/CommonJS/factory/module") {
Var = 
(
(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['exports', 'echarts'], factory);
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports, require('echarts'));
    } else {
        // Browser globals
        factory({}, root.echarts);
    }
}(this, function(exports, echarts) {
    if (!echarts) {
        log('ECharts is not Loaded');
        return;
    }
}));

;(function (root, factory) {
  if (typeof exports === "object") {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define([], factory);
  } else {
    root.FUCKYOU = factory();
  }
}(this,function () {
　　// ...  这里编写你的代码
　　return {
      
   };
});
)
}

if (v == "JSON.parse(JSON.stringify(...)) 超简易拷贝") {
Var = 
(
JSON.parse(JSON.stringify(...))
)
}

if (v == "setattr") {
Var = 
(
el.setAttribute('tabindex', 3);
)
}

if (v == "removeattr") {
Var = 
(
document.querySelector('.fuck').removeAttribute('disabled');
)
}


if (v == "onscript/loadscript 加载脚本并等待加载完成") {
Var = 
(
/**
 * 加载script并且执行回调
 * @param {String} url 资源地址
 * @param {Function} cb 回调方法
 * https://www.cnblogs.com/_franky/archive/2010/06/20/1761370.html
 */
var onscriptload = function (url, cb) {
  var node = document.createElement("script")
  var head = document.getElementsByTagName('head')[0]
  var timeID
  var supportLoad = "onload" in node
  var onEvent = supportLoad ? "onload" : "onreadystatechange"
  node[onEvent] = function onLoad() {
      if (!supportLoad && !timeID && /complete|loaded/.test(node.readyState)) {
          timeID = setTimeout(onLoad)
          return
      }
      if (supportLoad || timeID) {
          clearTimeout(timeID)
          cb && cb()
      }
  }
  head.insertBefore(node, head.firstChild)
  node.src = url
}

onscriptload('https://cdn.bootcss.com/jquery/1.9.1/jquery.min.js', function () {
   console.log(jQuery.fn.jquery);
   console.log($('*').size())
})

)
}

if (v == "isNodeList") {
Var = 
(
Object.prototype.toString.call(v) === '[object NodeList]'
)
}

if (v == "is") {
Var = 
(
// 仿ramda: https://github.com/ramda/ramda/blob/master/source/is.js
const is = (type, val) => {
	return val != null && val.constructor === type || val instanceof type;
}

is(String, '123')     // => true
is(Number, 123)       // => true
is(Date, new Date())  // => true
is(Object, {})        // => true
is(Array, [])         // => true
)
}

if (v == "curry2 二元参数的手动柯里化") {
Var = 
(
// 二元参数的手动柯里化
function curry2(fn) {
	return function(firstArg){
		return function (secondArg) {
			return fn(firstArg, secondArg)
		}
	}
}
)
}

if (v == "es6.class") {
SendLevel 1
Send, js.class{tab}
return
}

if (v == "for-- 循环中splice需要使用") {
Var = 
(
var Things = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
var arr = []
for (var i = Things.length - 1; i >= 0; i--) {
	if (Things[i] `% 2 === 0) {
		arr.push(...Things.splice(i, 1))
		console.log(Things, arr)
	}
}
)
}



if (v == "Model 类") {
Var = 
(
import { getUUID } from '@/utils/utils.js'

export default class Model {
	constructor ({ size = 20 } = {}) {
		// 核心数据
		this.data = null
		// token
		this.token = ''
		// 是否加载中
		this.loading = false
		// 是否数据为空
		this.empty = false
		// 是否正在加载更多
		this.loadingmore = false
		// 是否没有更多了
		this.nomore = false
		// 总数
		this.total = 0
		// 页码
		this.page = 0
		// 数量
		this.size = this._size = size
		// 是否报错了
		this.error = ''
	}

	// 重置
  resetWhere () {
	  this.token = ''
	  this.loading = false
	  this.empty = false
	  this.loadingmore = false
	  this.nomore = false
	  this.total = 0
	  this.page = 0
	  this.size = this._size
	  this.error = ''
  }

  // 显示loading并且返回token
  showLoading () {
    this.loading = true
  }

  // 显示loadingmore并且返回token
  showLoadingmore () {
    this.loadingmore = true
  }

  // 隐藏loading
  hideLoading () {
    this.loading = false
  }

  // 隐藏Loadingmore
  hideLoadingmore () {
    this.loadingmore = false
  }

  // 页码++
  pagePlus () {
	  this.page++
  }

  // 是否是第一次加载
  isFirstPage () {
    return this.page === 0
  }

  // 刷新token并且返回token
  refreshToken () {
    return this.token = getUUID()
  }

  // 设置data以及一系列逻辑
  setData ({ data = [], total = 0, token = ''} = {}, cb = null) {
    // 如果token不一致，说明请求被覆盖了。应该中止逻辑演变
    if (token && this.token != token) return

    this.total = total
    this.loading = false
    this.loadingmore = false

    const isEmptyData = data.length === 0

    // empty 表示没有数据
    if (this.isFirstPage() && isEmptyData)
      this.empty = true

    // nomore 表示没有更多数据
    if (data.length < this.size || (!this.isFirstPage() && isEmptyData))
      this.nomore = true

    // 如果有数据，应该重置标识
    if (!isEmptyData) {
      this.empty = false
      // 就算有数据，如果不够长度，也是数据nomore
      if (data.length === this.size)
        this.nomore = false
    }

    if (this.isFirstPage())
      this.data = data
    else
      this.data = Array.prototype.concat.call(this.data || [], data)

    // 执行回调
    cb && cb(this)
  }
}
)
}

if (v == "scrollIntoView 滚动到元素可视区域") {
Var = 
(
document.querySelector(".loadingmore").scrollIntoView();
)
}

if (v == "throttle 函数节流") {
Var = 
(

// 函数节流（throttle）
var throttle = function(func, wait, options) {
  var timeout, context, args, result;
  // 标记时间戳
  var previous = 0;
  // options可选属性 leading: true/false 表示第一次事件马上触发回调/等待wait时间后触发
  // options可选属性 trailing: true/false 表示最后一次回调触发/最后一次回调不触发
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : +(new Date());
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    // 记录当前时间戳
    var now = +(new Date());
    // 如果是第一次触发且选项设置不立即执行回调
    if (!previous && options.leading === false)
    // 将记录的上次执行的时间戳置为当前
    previous = now;
    // 距离下次触发回调还需等待的时间
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;

    // 等待时间 <= 0或者不科学地 > wait（异常情况）
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
          // 清除定时器
        clearTimeout(timeout);
        // 解除引用
        timeout = null;
      }
      // 将记录的上次执行的时间戳置为当前
      previous = now;

      // 触发回调
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    }
    // 在定时器不存在且选项设置最后一次触发需要执行回调的情况下
    // 设置定时器，间隔remaining时间后执行later
    else if (!timeout && options.trailing !== false)    {
      timeout = setTimeout(later, remaining);
    }
   return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
};

// demo
var fn = (data) => console.log(20180926160742, data);
// leading 为 true时，第一次执行立即触发，这比setTimeout好多了
// trailing 为 fasle时，不会触发最后一次。这样比较符合直觉。
const fn2 = throttle(fn, 3000, { leading: true, trailing: false });
fn2(123) // 请手动不停的执行这个函数
)
}

if (v == "debounce 函数去抖") {
Var = 
(

// 函数去抖（debounce）：让函数只有在过完一段时间后再执行，并且该段时间内不被调用才会被执行
var debounce = function(func, wait, immediate) {
    var timeout, result;

     // 定时器设置的回调，清除定时器，执行回调函数func
    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var restArgs = function(func, startIndex) {
      startIndex = startIndex == null ? func.length - 1 : +startIndex;
      return function() {
        var length = Math.max(arguments.length - startIndex, 0);
        var rest = Array(length);
        for (var index = 0; index < length; index++) {
          rest[index] = arguments[index + startIndex];
        }
        switch (startIndex) {
          case 0: return func.call(this, rest);
          case 1: return func.call(this, arguments[0], rest);
          case 2: return func.call(this, arguments[0], arguments[1], rest);
        }
        var args = Array(startIndex + 1);
        for (index = 0; index < startIndex; index++) {
          args[index] = arguments[index];
        }
        args[startIndex] = rest;
        return func.apply(this, args);
      };
    };

    var delay = restArgs(function(func, wait, args) {
      return setTimeout(function(){
        return func.apply(null, args);
      }, wait);
    });

     // restArgs函数将传入的func的参数改造成Rest Parameters —— 一个参数数组
    var debounced = restArgs(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        // 立即触发的条件：immediate为true且timeout为空
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        // _.delay方法实际上是setTimeout()包裹了一层参数处理的逻辑
        timeout = delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
};
)
}

if (v == "is-ie") {
Var = 
(
(function(){ //ie版本
    var agent = navigator.userAgent.toLowerCase();
    return (!!window.ActiveXObject || "ActiveXObject" in window) ? (
      (agent.match(/msie\s(\d+)/) || [])[1] || '11' //由于ie11并没有msie的标识
    `) : false;
}())
)
}

if (v == "cookie 库") {
Var = 
(
/**
 * @desc  设置Cookie
 * @param {String} name
 * @param {String} value
 * @param {Number} expires
 */
function setCookie(name, value, expires) {
    var cookieString = name + "=" + escape(value);
    //判斷是否設置過期時間,0代表關閉瀏覽器時失效
    if (expires > 0) {
        var date = new Date();
        date.setTime(date.getTime() + expires * 1000);
        cookieString = cookieString + ";expires=" + date.toUTCString();
    }
    document.cookie=cookieString;
}

/**
 * @desc 根据name读取cookie
 * @param  {String} name
 * @return {String}
 */
function getCookie(name) {
    var arr = document.cookie.replace(/\s/g, "").split(';');
    for (var i = 0; i < arr.length; i++) {
        var tempArr = arr[i].split('=');
        if (tempArr[0] == name) {
            return decodeURIComponent(tempArr[1]);
        }
    }
    return '';
}

/**
 * @desc 根据name修改cookie
 * @param  {String} name
 * @param  {String} value
 * @param  {Number} expires 
 */
function editCookie(name, value, expires){
    var cookieString = name + "=" + escape(value);
    if (expires > 0) {
        var date = new Date();
        date.setTime(date.getTime() + expires * 1000);
        cookieString = cookieString + ";expires=" + date.toGMTString();
    }
    document.cookie = cookieString;
}

/**
 * @desc 根据name删除cookie
 * @param  {String} name
 */
function removeCookie(name) {
    // 设置已过期，系统会立刻删除cookie
    setCookie(name, '1', -1);
}
)
}

if (v == "countDown 倒计时") {
Var = 
(
/**
 * 開始倒計時
 * http://candy.dragonvein.io/frontend/web/site/signup
 * @param {jQuery DOM} $dom
 * <input type='button' id='second' value = '獲取驗證碼 | Get SMS Code'/>
 */
$(function () {
	// 触发按钮
	$("#second").click(function () {
	    sendCode();
	});
	// 獲取cookie值
	v = getCookie("secondsremained_login") ? getCookie("secondsremained_login") : 0;
	if (v > 0) {
		 // 開始倒計時
	    countDown($("#second")); 
	}
})

function sendCode () {
	// 设置默认时间
	setCookie('secondsremained_login', '60', 60)
	// 開始倒計時
    countDown($("#second")); 
}

function countDown ($dom) {
	var countdown = getCookie('secondsremained_login') ? getCookie('secondsremained_login') : 0;
	(function settime () {
		if (countdown == 0) {
		    $dom.removeAttr('disabled');
		    $dom.val('獲取驗證碼 | Get SMS Code');
		    return;
		} else {
		    $dom.attr('disabled', true);
		    $dom.val(countdown + '秒後重發 | Waiting ' + countdown + 's');
		    countdown--;
		    editCookie('secondsremained_login', countdown, countdown + 1);
		}
		setTimeout(function() { settime($dom) },1000) //每1000毫秒執行壹次
	}());
}
)
}

if (v == "rem 解决方案 / 淘宝解决方案") {
SendLevel 1
Send, taobao{tab}
return 
}

if (v == "lazyload 图片懒加载") {
Var = 
(
/**
 * 图片懒加载
 * https://www.liaoxuefeng.com/article/00151045553343934ba3bb4ed684623b1bf00488231d88d000
 * <img src="https://loading.io/assets/img/ajax.gif" data-src="http://www.hongte.info/assets/images/banner2.jpg">
 * <div style="margin-top: 1000px;"></div>
 */
;(function(){
    // 获取包含data-src属性的img
    var lazyImgs = document.querySelectorAll('img[data-src]')
    // 将Node-List转化成数组类型
    lazyImgs = [].slice.apply(lazyImgs);
     // 定义事件函数
    var lazyload = function () {
        // 获取页面滚动的高度
        var wtop = window.scrollY;
        // 获取可视区域高度
        var wheight = document.documentElement.clientHeight;
        // 判断是否还有未加载的img
        if (lazyImgs.length > 0) {
            // 循环处理数组的每个img元素
            for (var i = lazyImgs.length - 1; i >= 0; i--) {
                // 获取图片信息
                var el = lazyImgs[i], rect = el.getBoundingClientRect(), src = el.getAttribute('data-src')
                // 判断是否在可视范围内:
                if (rect.top - wtop < wheight) {
                   // 设置src属性:
                   el.setAttribute('src', src);
                   // 删除对象
                   Array.prototype.splice.call(lazyImgs, i, 1);
                }
            }
        }
    };

    // 懒加载优化：滚动节流策略
    var __SCROLLTIMER__ = null
    // 绑定事件
    window.onscroll = function () {
        clearTimeout(__SCROLLTIMER__);
        __SCROLLTIMER__ = setTimeout(lazyload, 150);
    }

    // 手动触发一次, 因为页面显示时，并未触发scroll事件。
    lazyload();
}());
)
}

if (v == "copyToClipboard 剪切板") {
Var = 
(
// 剪切板
export const copyToClipboard = (text, cb) => {
    if(text.indexOf('-') !== -1) {
        let arr = text.split('-');
        text = arr[0] + arr[1];
    }
    var textArea = document.createElement("textarea");
      textArea.style.position = 'fixed';
      textArea.style.top = '0';
      textArea.style.left = '0';
      textArea.style.width = '2em';
      textArea.style.height = '2em';
      textArea.style.padding = '0';
      textArea.style.border = 'none';
      textArea.style.outline = 'none';
      textArea.style.boxShadow = 'none';
      textArea.style.background = 'transparent';
      textArea.value = text;
      document.body.appendChild(textArea);
      textArea.select();

      try {
        var successful = document.execCommand('copy');
        cb && cb()
      } catch (err) {
        console.log('该浏览器不支持点击复制到剪贴板');
      }
      document.body.removeChild(textArea);
}
)
}

if (v == "maybe 神奇的预设函数") {
Var = 
(
const maybe = (fn, n = '') => {
   try {
      const result = fn()
      return (result && result === result && result !== 'NaN' && result !== 'Invalid date') ? result : n
   } catch (err) {
      return n
   }
}

var obj = {
 a: 123
}
maybe(_=> obj.a, 0); // 123
maybe(_=> obj.b, 0); // 0
maybe(_=> obj.a.b.s.w.holy.shit.fuck.god, 0); // 0
)
}

if (v == "ClickOutside 点击外部冒泡") {
_send("clickoutside", true, true)
return
}

if (v == "addcss/link 样式加载器") {
Var = 
(
var link = function(href, fn, cssname){
	var that = this
	,link = doc.createElement('link')
	,head = doc.getElementsByTagName('head')[0];

	if(typeof fn === 'string') cssname = fn;

	var app = (cssname || href).replace(/\.|\//g, '')
	,id = link.id = 'layuicss-'+app
	,timeout = 0
	,time = 10;

	link.rel = 'stylesheet';
	link.href = href + (config.debug ? '?v='+new Date().getTime() : '');
	link.media = 'all';

	if(!doc.getElementById(id)){
	  head.appendChild(link);
	}

	if(typeof fn !== 'function') return that;

	//轮询css是否加载完毕
	;(function poll() {
	  if(++timeout > time * 1000 / 100){
	    return console.error(href + ' timeout');
	  };
	  <这里写上你的条件> ? fn() : setTimeout(poll, 100);
	}());

	return that;
};

var addcss = function(firename, fn, cssname){
	return link(config.dir + 'css/' + firename, fn, cssname);
};
)
}

if (v == "getstyle") {
Var = 
(
getComputedStyle(el)[ruleName];
)
}

if (v == "is-wx") {
Var = 
(
var is_weixn = function () {
    var ua = navigator.userAgent.toLowerCase();
    if(ua.match(/MicroMessenger/i)=="micromessenger") {
        return true;
    } else {
        return false;
    }
}
)
}

if (v == "poll 递归") {
Var = 
(
// 递归
var maxTimeout = 10,
    timeout = 0,
    wait = 4, 
    callback = function() {
       // ... 这样写上条件成功时执行的内容
    };
(function poll() {
    if (++timeout > maxTimeout * 1000 / wait) {
        return window.alert('超时');
    };
    <这里写上你的判断> ? callback() : setTimeout(poll, wait);
}());
)
}

if (v == "escapeHTML 防止XSS") {
Var = 
(
var escape = function(html){
  return String(html || '').replace(/&(?!#?[a-zA-Z0-9]+;)/g, '&amp;')
  .replace(/</g, '&lt;').replace(/>/g, '&gt;')
  .replace(/'/g, '&#39;').replace(/"/g, '&quot;');
}
)
}

if (v == "preloadimg 图片预加载") {
Var = 
(
var perloadimg = function(url, callback, error) {
    var img = new Image();
    img.src = url;
    if(img.complete){
      return callback(img);
    }
    img.onload = function(){
      img.onload = null;
      typeof callback === 'function' && callback(img);
    };
    img.onerror = function(e){
      img.onerror = null;
      typeof error === 'function' && error(e);
    };
};

const preLoadImages = (imgs) => {
  var imgWrap = [];
  imgs.forEach(function (path) {
       new Image().src = path;
  });
}
preLoadImages(['./bg.png', './bg2.png'])
)
}

if (v == "device 获取设备信息") {
Var = 
(
var device = function(key){
  var agent = navigator.userAgent.toLowerCase()

  //获取版本号
  ,getVersion = function(label){
    var exp = new RegExp(label + '/([^\\s\\_\\-]+)');
    label = (agent.match(exp)||[])[1];
    return label || false;
  }
  
  //返回结果集
  ,result = {
    os: function(){ //底层操作系统
      if(/windows/.test(agent)){
        return 'windows';
      } else if(/linux/.test(agent)){
        return 'linux';
      } else if(/iphone|ipod|ipad|ios/.test(agent)){
        return 'ios';
      } else if(/mac/.test(agent)){
        return 'mac';
      } 
    }()
    ,ie: function(){ //ie版本
      return (!!window.ActiveXObject || "ActiveXObject" in window) ? (
        (agent.match(/msie\s(\d+)/) || [])[1] || '11' //由于ie11并没有msie的标识
      `) : false;
    }()
    ,weixin: getVersion('micromessenger')  //是否微信
  };
  
  //任意的key
  if(key && !result[key]){
    result[key] = getVersion(key);
  }
  
  //移动设备
  result.android = /android/.test(agent);
  result.ios = result.os === 'ios';
  
  return result;
};
)
}



if (v == "isBottom 是否滚动到底部") {
SendLevel 1
Send, isbottom{tab}
return
}


if (v == "isString") {
Var = 
(
export default function isString(input) {
	return Object.prototype.toString.call(input) === '[object String]'
}
)
}
if (v == "isBoolean") {
Var = 
(
export default function isBoolean(input) {
	return Object.prototype.toString.call(input) === '[object Boolean]'
}
)
}
if (v == "isZH-Cn") {
Var = 
(
if (!/^[\u4e00-\u9fa5]+$/.test('李钊鸿')) {
      throw new Error('请输入中文汉字')
}
)
}
if (v == "isIp") {
Var = 
(
body.match(/\d\.\d\.\d\.\d:\d/g);
)
}
if (v == "isPhone") {
Var = 
(
/^([0-9]{3,4}-)?[0-9]{7,8}$/.test(s)
/^[1][3,4,5,7,8][0-9]{9}$/.test(s)
/^1\d{10}$/.test(s)
/^((1)3(\d){9}$)|(^(1)4[5-9](\d){8}$)|(^(1)5[^4]{9}$)|(^(1)66(\d){8}$)|(^(1)7[0-8](\d){8}$)|(^(1)8(\d){9}$)|(^(1)9[8-9](\d){8}$)/.test(16961121989)
)
}
if (v == "isPwd") {
Var = 
(
/[A-Za-z].*[0-9]|[0-9].*[A-Za-z]/.test('123456a@') // 必须同时包含数字和字母,支持非法符号
)
}
if (v == "isUser") {
Var = 
(
 /^[a-zA-Z0-9-_]*$/.test('') // 由6-16位数字、 字母、 '_'、 '-'组成，不含特殊字符
)
}
if (v == "isId") {
Var = 
(
if (!/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/.test('445222199307100337')){
    throw new Error('非法身份证')
}
)
}
if (v == "isEmail") {
Var = 
(
)
}

if (v == "isZH-Cn") {
Var = 
(
if (!/^[\u4e00-\u9fa5]+$/.test('李钊鸿')) {
      throw new Error('请输入中文汉字')
}
)
}



if (v == "gettop 获取距离顶部的相对距离") {
Var = 
(
// 获取距离顶部的相对距离
function getElementTop(element){
    try {
　  　　　var actualTop = element.offsetTop;
　  　　　var current = element.offsetParent;
　  　　　while (current !== null){
　  　　　　　actualTop += current.offsetTop;
　  　　　　　current = current.offsetParent;
　  　　　}
　  　　　return actualTop;
    } catch (e) {}
}
)
}

if (v == "scrollToTop 滚动到头部") {
Var = 
(
var timer = null;
var goTop = function() {
    cancelAnimationFrame(timer);
    timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
            document.body.scrollTop = document.documentElement.scrollTop = oTop - 500;
            timer = requestAnimationFrame(fn);
        } else {
            cancelAnimationFrame(timer);
        }
    });
}
// es6
const scrollToTop = () => {
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c > 0) {
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  }
};
)
}


if (v == "pad 自动补全") {
Var = 
(
// 自动补全
function pad (target, n) {
    var zero = new Array(n).join('0');
    var str = zero + target;
    var result = str.substr(-n);
    return result;
}
)
}

if (v == "isArray") {
Var = 
(
export default function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}
)
}

if (v == "isDate") {
Var = 
(
export default function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}
)
}

if (v == "isFunction") {
Var = 
(
export default function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}
)
}

if (v == "isNumber") {
Var = 
(
export default function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}
)
}

if (v == "isPureObject") {
Var = 
(
export default function isEmptyObject(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}
)
}

if (v == "isObject") {
Var = 
(
export default function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

)
}

if (v == "isPromise") {
Var = 
(
export function isPromise (val) {
  return val && typeof val.then === 'function'
}
)
}

if (v == "isNaN") {
Var = 
(
function isNaN(obj) {
    return obj !== obj
}
)
}

if (v == "extend 浅拷贝（继承模式中最后的圣杯）") {
SendLevel 1
Send, extend{tab}
return
}

if (v == "deepExtend 深拷贝") {
SendLevel 1
Send, deepextend{tab}
return
}

if (v == "getElementPosition 获取元素的定位") {
Var = 
(
function getElementPosition (el: Element, offset: Object): Object {
  const docEl: any = document.documentElement
  const docRect = docEl.getBoundingClientRect()
  const elRect = el.getBoundingClientRect()
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  }
}
)
}


if (v == "uuid 超简易版") {
Var = 
(
// 36位
function getUUID () {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    return (c === 'x' ? (Math.random() * 16 | 0) : ('r&0x3' | '0x8')).toString(16)
  })
}

// 32位 正式版
const UUIDGeneratorBrowser = () => ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16));
UUIDGeneratorBrowser(); // '7982fcfe-5721-4632-bede-6000885be57d'

// 9位 简易版
const MdUuid = () => Math.random().toString(36).slice(4)
MdUuid() // "r1mca5d4z"
)
}


if (v == "hasClass") {
Var = 
(
export const hasClass = (el, className) => {
  if (el.classList)
    return el.classList.contains(className);
  else
    return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
}
)
}

if (v == "addClass") {
Var = 
(
export const addClass = (el, cls) => {
        if (el.classList) {
            el.classList.add(cls)
        } else {
            var cur = ' ' + utils.getClassName(el) + ' '
            if (cur.indexOf(' ' + cls + ' ') < 0) {
                el.setAttribute('class', (cur + cls).trim())
            }
        }
    }
)
}

if (v == "removeclass") {
Var = 
(
export const removeClass = (el, cls) => {
        if (el.classList) {
            el.classList.remove(cls)
        } else {
            var cur = ' ' + utils.getClassName(el) + ' ',
                tar = ' ' + cls + ' '
            while (cur.indexOf(tar) >= 0) {
                cur = cur.replace(tar, ' ')
            }
            el.setAttribute('class', cur.trim())
        }
    }
)
}

if (v == "getclassname") {
Var = 
(
export const getClassName = (el) => {
        return (el.className instanceof SVGAnimatedString ? el.className.baseVal : el.className)
    }
)
}

if (v == "setStyle") {
Var = 
(
export const setStyle = (element, styleName, value) => {
    if (!element || !styleName) return;

    if (typeof styleName === 'object') {
        for (var prop in styleName) {
            if (styleName.hasOwnProperty(prop)) {
                setStyle(element, prop, styleName[prop]);
            }
        }
    } else {
        if (styleName === 'opacity' && ieVersion < 9) {
            element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';
        } else {
            element.style[styleName] = value;
        }
    }
};
)
}

if (v == "Vue 进度条组件") {
Var = 
(
<template>
    <div class="myprogress" :style='{ width: mywidth }'></div>
</template>

<script>
export default {
  name: 'myprogress',
  data () {
    return {
      mywidth: 0
    }
  },
  methods: {
      go () {
          console.log('go');
      }
  },
  props: {
    _width: {
      default: 0,
      type: String
    }
  },
  components: {

  },
  computed: {

  },
  watch: {
    _width (newV) {
      this.mywidth = 0
      setTimeout(_ => this.mywidth = newV, 50)
    }
  },
  mounted () {
      setTimeout(() => {
        this.mywidth = this._width
      }, 50);
  }
}
</script>

<style lang="scss" scoped>
@import "~@/scss/functions.scss";
.myprogress {
  transition: .5s all ease;
  width: 0;
}
</style>
)
}




code(Var)
return

::delay::
Var =
(
/**
 * 延迟工具，必须配合 async/await使用 ...
 *
    (async function(){
        await delay(1000)
        console.log('test')
    }())
 */
export const delay = t => new Promise((resolve, reject) => {
   setTimeout(() => {
        resolve(t)
   }, t)
})
)
code(Var)
return


::utils.js::
::utils::
Var =
(
import { Message } from 'element-ui'

/**
 * 最简单且最安全的方法显示任意值，举个例子: 
 * var obj = {a: 123 }
   maybe(_=> obj.a, 0); // 123
   maybe(_=> obj.b, 0); // 0
   maybe(_=> obj.a.b.s.w.holy.shit.fuck.god, 0); // 0
 */
export const maybe = (fn, n = '') => {
    try {
        const result = fn()
        return (result && result === result && result !== 'NaN' && result !== 'undefined' && result !== 'Invalid date') ? result : n
    } catch (err) {
        return n
    }
}

/**
 * delay工具函数
 *
    (async function(){
        // 启动计时器
        console.time('🚀')
        // 测试专用函数
        const test = () => new Promise((resolve, reject) => setTimeout(_ => resolve('success'), 1000))
        // wait
        const result = await wait(test, 3000)
        // success
        console.log(result)
        // 停止计时，输出时间
        console.timeEnd('🚀') // => 🚀: 3002.038818359375ms
    }())
 */
export const wait = async (fn, t = 0) => {
    // 计时器（开始）
    const startTime = +new Date
    // 执行并等待该函数
    const result = await fn()
    // 计时器停止
    const endTime = +new Date
    // 获取请求消耗的时间
    const intervalTime = t - (endTime - startTime)
    // 返回
    return new Promise((resolve, reject) => setTimeout(() => resolve(result), intervalTime))
}


/**
 * 延迟工具，必须配合 async/await使用 ...
 *
    (async function(){
        await delay(1000)
        console.log('test')
    }())
 */
export const delay = t => new Promise((resolve, reject) => {
   setTimeout(() => {
        resolve(t)
   }, t)
})

/**
 * 获取数组最后一位
 */
Array.prototype.last = function () {
    return this[this.length - 1]
} 

/**
 * 获取数组第一位
 */
Array.prototype.first = function () {
    return this[0]
} 


/**
 * 判断对象是否是一个空的对象，既{}
 */
export const isEmptyObject = obj => {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

/**
 * 将对象转化为formdata格式
 */
export const obj2formdata = (json) => {
    var data = new FormData()
    if (json) {
        Object.keys(json).forEach(function(key) {
            data.append(key, json[key])
        });
    }
    return data
}

/**
 * 移动dom元素到指定目标位置
 *
 * @source {DOM} 你要移动的DOM
 * @target {DOM} 你要移动的位置
 */
const mvDOM = function (source, target) {
	// 深度拷贝（含子元素）
	let _source = source.cloneNode(true)
	// 删除本身
	source.remove()
	// 默认插入到容器最前面，如果想在后面可以这样处理：target.append(source)
	target.insertBefore(_source, target.firstChild)
}

/**
 * 将对象转化为GET参数
 */
export const obj2formdatastr = (body) => {
    if (body) {
        let formparams = '';
        Object.keys(body).forEach(key => {
            if (formparams.length > 0) {
                formparams += '&';
            }
            formparams = formparams + key + '=' + body[key];
        });
        return formparams
    }
    return ''
}


/**
 * 函数节流（throttle）
 */
export const throttle = (func, wait, options) => {
  var timeout, context, args, result;
  // 标记时间戳
  var previous = 0;
  // options可选属性 leading: true/false 表示第一次事件马上触发回调/等待wait时间后触发
  // options可选属性 trailing: true/false 表示最后一次回调触发/最后一次回调不触发
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : +(new Date());
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    // 记录当前时间戳
    var now = +(new Date());
    // 如果是第一次触发且选项设置不立即执行回调
    if (!previous && options.leading === false)
    // 将记录的上次执行的时间戳置为当前
    previous = now;
    // 距离下次触发回调还需等待的时间
    var remaining = wait - (now = previous);
    context = this;
    args = arguments;

    // 等待时间 <= 0或者不科学地 > wait（异常情况）
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
          // 清除定时器
        clearTimeout(timeout);
        // 解除引用
        timeout = null;
      }
      // 将记录的上次执行的时间戳置为当前
      previous = now;

      // 触发回调
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    }
    // 在定时器不存在且选项设置最后一次触发需要执行回调的情况下
    // 设置定时器，间隔remaining时间后执行later
    else if (!timeout && options.trailing !== false)    {
      timeout = setTimeout(later, remaining);
    }
   return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
};


// Array Remove - By John Resig (MIT Licensed)
/**
 * // 移除数组中的第二项
 * array.remove(1);
 * // 移除数组中的倒数第二项
 * array.remove(-2);
 * // 移除数组中的第二项和第三项（从第二项开始，删除2个元素）
 * array.remove(1,2);
 * // 移除数组中的最后一项和倒数第二项（数组中的最后两项）
 * array.remove(-2,-1);
 *
 */
Array.prototype.remove = function(from, to) {
  var rest = this.slice((to || from) + 1 || this.length);
  this.length = from < 0 ? this.length + from : from;
  this.push.apply(this, rest);
  return this
};


 /**
 * 深度递归搜索
 * @param {Array} arr 你要搜索的数组
 * @param {Function} condition 回调函数，必须返回谓词，判断是否找到了。会传入(item, index, level)三个参数
 * @param {String} children 子数组的key
 */
export const deepFind = (arr, condition, children) => {
    // 即将返回的数组
    let main = []

    // 用try方案方便直接中止所有递归的程序
    try {
        // 开始轮询
        (function poll(arr, level, cb) {
            // 如果传入非数组
            if (!Array.isArray(arr)) return

            // 遍历数组
            for (let i = 0; i < arr.length; i++) {
                // 获取当前项
                const item = arr[i]

                // 先占位预设值
                main[level] = item

                // 扩展：如果是一个对象的话，添加一些标记属性
                if (Object.prototype.toString.call(item) === '[object Object]') {
                  item.__INDEX__ = i
                  item.__LEVEL__ = level
                }

                // 检验是否已经找到了
                const isFind = condition && condition(item, i, level) || false

                // 自杀函数
                const kill = () => {
                // 删除占位预设值
                  main.length = main.length - 1
                  // 触发回调
                  cb && cb()
                }

                // 如果已经找到了
                if (isFind) {
                    // 直接抛出错误中断所有轮询
                    throw Error
                // 如果存在children，那么深入递归
                } else if (children && item[children] && item[children].length) {
                    poll(item[children], level + 1,
                      // 如果本函数被触发，说明children还是找不到。
                      () => {
                      // 那么如果我是最后一条，那么我也自杀吧
                      if (i === arr.length - 1) {
                        kill()
                      }
                    })
                // 如果是最后一个且没有找到值，那么通过修改数组长度来删除当前项
                } else if (i === arr.length - 1) {
                  // 找不到，羞愧自杀
                  kill()
                }
            }
        })(arr, 0)
    // 使用try/catch是为了中止所有轮询中的任务
    } catch (err) {}

    // 返回最终数组
    return main
}

/**
 * 深度设置
 */
export const deepSet = (ary, path, cb) => {
  // （重要）保存引用
  let obj = ary
  // 不断轮询路径
  while (path.length) {
    // 从左往右取出路径
    const key = path.shift()
    // 获取当前路径的值
    obj = obj[key]
    // 判断路径，如果异常则直接中断循环
    if (!obj) break
  }
  // 回调，注入指定路径的ary引用
  cb && cb(obj)
  // （重点）返回被串改的数组
  return ary
}

/**
 * chunk 数组分块函数
 * 对数组进行分块，满足条件的分为hit组，不满足分到miss组
 *
 * const ary = [1, 2, 3, 4, 5, 6, 7, 8]
 * const result = chunk(ary, _ => _ > 1)
 * console.log(result)
 */
export const chunk = (ary, fn) => ary.reduce(({ hit, miss } = {}, v) => {
  fn(v) ? hit.push(v) : miss.push(v)
  return { hit, miss }
}, { hit: [], miss: [] })

export const poll = (conditionFn, callback, wait = 4, maxTimeout = 10, timeout = 0) => {
  // 请求是否超出阈值
  if (++timeout > maxTimeout * 1000 / wait) throw new Error('overtime')
  // 如果条件满足，那么执行，否则轮询
  conditionFn() ? callback() : setTimeout(() => {poll(conditionFn, callback, wait, maxTimeout, timeout) }, wait)
}


export const pureMap = (ary = [], validate = () => true, cb = () => undefined) => {
  // copy
  let _ary = JSON.parse(JSON.stringify(ary))

  // filter
  _ary = _ary.map(v => {
    // validate
      if (validate(v)) {
        // callback
        return cb(v) || v
      } else {
        // default
        return v
      }
  });

  // filter ary
  return _ary
}

export const addClass = (el, cls) => {
    if (el.classList) {
        el.classList.add(cls)
    } else {
        var cur = ' ' + getClassName(el) + ' '
        if (cur.indexOf(' ' + cls + ' ') < 0) {
            el.setAttribute('class', (cur + cls).trim())
        }
    }
}

export const hasClass = (el, className) => {
  if (el.classList)
    return el.classList.contains(className);
  else
    return new RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);
}

export const getClassName = (el) => {
    return (el.className instanceof SVGAnimatedString ? el.className.baseVal : el.className)
}

export const removeClass = (el, cls) => {
    if (el.classList) {
        el.classList.remove(cls)
    } else {
        var cur = ' ' + getClassName(el) + ' ',
            tar = ' ' + cls + ' '
        while (cur.indexOf(tar) >= 0) {
            cur = cur.replace(tar, ' ')
        }
        el.setAttribute('class', cur.trim())
    }
}

export const exclude = (obj, ...attribute) =>  {
  // copy
  let _ = JSON.parse(JSON.stringify(obj))
    // 删除属性
  for (let i = 0, len = attribute.length; i < len; i++) {
    const attr = attribute[i]
      delete _[attr]
  }
  // pure obj
  return _
}


// 补全
export const pad = (target, n) => {
    var zero = new Array(n).join('0');
    var str = zero + target;
    var result = str.substr(-n);
    return result;
}

// 获取24小时，从指定的时间开始
export const get24hourfrom = (start, count = 24) => {
  return [...Array(count)].map((v, index, array) => {
      return pad((index + start) `% 24, 2)
  })
}


// 设置高亮 for point.css
export const point = dom => {
  if (hasClass(dom, 'changing')) {
     removeClass(dom, 'changing')
  } else {
     addClass(dom, 'changing')
     addClass(dom, 'point')
     dom.addEventListener("webkitAnimationEnd", function() {
       removeClass(dom, 'changing')
     })
  }
}


// 缓存器
export const memoized = function (fn) {
  // 缓存队列
  var cache = {}
  return function () {
    // 以入参为key（todo:最好作为可配置）
    var __KEY__ = Array.prototype.slice.call(arguments)
    // 记录缓存
    return cache[__KEY__] || (cache[__KEY__] = fn.apply(this, arguments))
  }
}

// 对象查找器
export const findObj = (obj = {}, condition = () => true) => {
  for (let [key, ele] of Object.entries(obj)) {
      if (condition(key, ele)) {
        return ele
      }
  }
}

// catch error 
export const catchErr = err => {
  Message(err.message || '数据异常')
  throw new Error(err.message)
}


/**
 *  Promise.prototype.before 补丁
 *
 *  new Promise((resolve, reject) => {
 *     setTimeout(function () {
 *        resolve('success') // reject('fail')
 *     }, 1000);
 *  }).before(() => {
 *    console.log(20190422151455, 'before')
 *  }).finally(() => {
 *    console.log(20190422145923, 'finally')
 *  })
 */
Promise.prototype.before = function (fn) {
  (fn instanceof Function || Object.prototype.toString.call(fn) === '[object Function]') && fn()
  return this
}


// 字符串判断
export const isString = (v) => Object.prototype.toString.call(v) === '[object String]'

// 数组判断
export const isArray = (input) => input instanceof Array || Object.prototype.toString.call(input) === '[object Array]'

// 对象判断
export const isObject = (input) => input != null && Object.prototype.toString.call(input) === '[object Object]'

// 仿 Array.prototype.map 函数。兼容数组、对象的遍历
export const betterMap = (v, cb) => {
    let result = []
    if (isArray(v) || isString(v)) {
        for (var i = 0; i < v.length; i++) {
            result.push(cb && cb(v[i], i, v, result))
        }
    }
    if (isObject(v)) {
        for (var k in v) {
            result.push(cb && cb(v[k], k, v, result))
        }
    }
    return result
}

export const handleClickOutSide = () => {
  var evmousedown = document.createEvent('HTMLEvents');
  evmousedown.initEvent('mousedown', false, true);
  var evmouseup = document.createEvent('HTMLEvents');
  evmouseup.initEvent('mouseup', false, true);
  document.dispatchEvent(evmousedown)
  document.dispatchEvent(evmouseup)
  var evmouseclick = document.createEvent('HTMLEvents');
  evmouseclick.initEvent('click', false, true);
  document.dispatchEvent(evmouseclick)
  document.dispatchEvent(evmouseclick)
}
)
code(Var)
return

::deepset::
Var =
(
/**
 * 深度设置
 *
 * 示例1：
 * const a = {b: { c: { d: { e: {} } } } }
 * deepSet(a, ['b', 'c', 'd', 'e'], item => {
 * 	 // ...
 * 	 item.fuck = 123
 * })
 *	
 * 示例2：
 * const a = {b: { c: { d: { e: {} } } } }
 * deepSet(a, ['b', 'c', 'd', 'e', 'f', 'g', 'h'], item => {
 * 	 // ...
 * 	 item.fuck = 123
 * })
 */
const deepSet = (ary, path, cb) => {
	// （重要）保存引用
	let obj = ary
	// 不断轮询路径
	while (path.length) {
		// 从左往右取出路径
		const key = path.shift()

		// 补丁，如果不存在则定义该对象
		if (!obj[key]) {
			obj[key] = {}
		}

		// 获取当前路径的值
		obj = obj[key]
	}
	// 回调，注入指定路径的ary引用
	cb && cb(obj)
	// （重点）返回被串改的数组
	return ary
}
)
code(Var)
return

::chunk::
Var =
(
/**
 * chunk 数组分块函数
 * 对数组进行分块，满足条件的分为hit组，不满足分到miss组
 *
 * 示例一：
 * const ary = [1, 2, 3, 4, 5, 6, 7, 8]
 * const result = chunk(ary, _ => _ > 1)
 * console.log(result) // { hit: [...], miss: [...] }
 *
 * 示例二： 
 * const ary = [1, 2, 3, 4, 5, 6, 7, 8]
 * const { hit, miss } = chunk(ary, _ => _ > 5)
 * console.log([...hit.map(_ => _), ...miss])
 */
const chunk = (ary, fn) => ary.reduce(({ hit, miss } = {}, v) => {
	fn(v) ? hit.push(v) : miss.push(v)
	return { hit, miss }
}, { hit: [], miss: [] })
)
code(Var)
return

::puremap::
Var =
(
const pureMap = (ary = [], validate = () => true, cb = () => undefined) => {
  // copy
  let _ary = JSON.parse(JSON.stringify(ary))

  // filter
  _ary = _ary.map(v => {
    // validate
      if (validate(v)) {
        // callback
        return cb(v) || v
      } else {
        // default
        return v
      }
  });

  // filter ary
  return _ary
}
)
code(Var)
return

::paichu::
::exclude::
Var =
(
export const exclude = (obj, ...attribute) =>  {
  // copy
  let _ = JSON.parse(JSON.stringify(obj))
    // 删除属性
  for (let i = 0, len = attribute.length; i < len; i++) {
    const attr = attribute[i]
      delete _[attr]
  }
  // pure obj
  return _
}
)
code(Var)
return

::fuckclickoutside::
::handleclickoutside::
Var =
(
var evmousedown = document.createEvent('HTMLEvents');
// evmousedown.clientX = 88
// evmousedown.clientY = 18

evmousedown.initEvent('mousedown', false, true);
var evmouseup = document.createEvent('HTMLEvents');
// evmouseup.clientX = 88
// evmouseup.clientY = 18

evmouseup.initEvent('mouseup', false, true);
document.dispatchEvent(evmousedown)
document.dispatchEvent(evmouseup)
var evmouseclick = document.createEvent('HTMLEvents');
// evmouseclick.clientX = 88
// evmouseclick.clientY = 18

evmouseclick.initEvent('click', false, true);
document.dispatchEvent(evmouseclick)
document.dispatchEvent(evmouseclick)
)
code(Var)
return

::fullpage::
::maxapge::
::f11::
::maxchrome::
Var =
(
var b = document.getElementById('view_container')

var e = b.requestFullScreen || 
		b.webkitRequestFullScreen || 
		b.mozRequestFullScreen || 
		b.msRequestFullScreen;

e.call(b) // b.webkitRequestFullScreen()

//////////////////////////////////////////////
// say something...
//////////////////////////////////////////////

// 如果不是全屏的话，那么进入全屏
if (!this.isFullScreen) {
    var el = document.documentElement;
    var rfs = el.requestFullScreen || el.webkitRequestFullScreen || el.mozRequestFullScreen || el.msRequestFullScreen;
    if (typeof rfs != "undefined" && rfs) {
        rfs.call(el);
    } else if (typeof window.ActiveXObject != "undefined") {
        var wscript = new ActiveXObject("WScript.Shell");
        if (wscript != null) {
            wscript.SendKeys("{F11}");
        }
    }
// 否则退出全屏
} else {
    // 判断各种浏览器，找到正确的方法
    var exitMethod = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.webkitExitFullscreen;
    if (exitMethod) {
        exitMethod.call(document);
    } else if (typeof window.ActiveXObject !== "undefined") { //for Internet Explorer
        var wscript = new ActiveXObject("WScript.Shell");
        if (wscript !== null) {
            wscript.SendKeys("{F11}");
        }
    }
} 

)
code(Var)
return

::def::
Var =
(
export function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  })
}
)
code(Var)
return

::diff::
Var =
(
function isObject(v) {
   return typeof v === 'object' && !!v
}

function diff(a, b) {
  if(!isObject(a) || !isObject(b)) {
    throw new TypeError(' a or b is invalid json' )
  }

  let keys = Object.keys(a)

  if (keys.length == 0) {
    return JSON.stringify(a) === JSON.stringify(b)
  }

  let aValue, bValue, key

  for (key of keys) {
    aValue = a[key]
    bValue = b[key]
    if (isObject(aValue) && isObject(bValue) === 'object') {
      return diff(aValue, bValue)
    } else if (aValue !== bValue) {
      debugger;
      return false
    }
  }
  return true
}
)
code(Var)
return

::fixpos::
Var =
(
/**
 * fixPos: 根据父层界限调整宽高和位置
 */
function fixPos ({height, width, top, left} = {}, {parentH, parentW} = {}) {
  // Checks if position + size gets out-of-bounds (TOO FAR), if so, reposition...
  if ((top + height) > parentH) 
    top -= (top + height) - parentH

  if ((left + width) > parentW)
    left -= (left + width) - parentW

  // Checks if position is out-of-bounds (NEGATIVE), if so reposition...
  if (top <= 0) 
    top = 0

  if (left <= 0) 
    left = 0

  // Checks if, with a 0 position, the element is still out-of-bounds (TOO BIG), if so, resize
  if (top === 0 && (height > parentH)) 
    height = parentH

  if (left === 0 && (width > parentW)) 
    width = parentW

  return { left, top, height, width }
}
)
code(Var)
return

::dr::
Var =
(
document.removeEventListener('mouseup', this.clickOutSide)
)
code(Var)
return

::log::
t := A_YYYY . A_MM . A_DD . A_Hour . A_Min . A_Sec
Var =
(
const { log, warn, info, error, assert } = console
log(%t%, )
)
code(Var)
SendInput, {left}
return

::asserts::
::assert::
Var =
(
console.assert(false, )
)
code(Var)
SendInput, {left}
return

::once::
Var =
(
/**
 * es6 版本
 *
 */
var once = f => {
	// 计数器，采用闭包来保护私有变量
	let count = 0
	// 保存闭包执行结果
	let cache
	return (...args) => {
	  // once 执行逻辑
	  if (++count === 1) {
	    // 执行函数
	    cache = f(...args)
	  }
	  // 返回函数执行结果
	  return cache
	}
}

/**
 * es5 版本
 *
 */
var once = f => {
	// 计数器，采用闭包来保护私有变量
	let count = 0
	// 保存闭包执行结果
	let cache
	return function () {
	  // once 执行逻辑
	  if (++count === 1) {
	    // 执行函数
	    cache = f.apply(null, arguments)
	  }
	  // 返回函数执行结果
	  return cache
	}
}

/**
 * es6 极限版本
 *
 */
var once = (f, cache, count = 0) => (...args) => ++count === 1 ? cache = f(...args) : cache
)
code(Var)
return

::!include::
::!includes::
Var =
(
a.filter(_ => !b.includes(_))
)
code(Var)
return

::fenye::
Var =
(
// 就像分页一样。
// 1、页码 page：从 0 开始
// 2、数量 num：3
// 3、次数：Math.ceil
// 4、使用Array.prototype.slice切割。不会改变原数组
// 公式：a.slice(page * num, page + 1 * num)

/*
var ary = [1,2,3,4,5,6,7,8,9,10]
var num = 3
var count = Math.ceil(ary.length / num)
for (var page = 0; page < count; page++) {
	console.log(ary.slice(page * num, (page + 1) * num))
}
*/

const ary = [1,2,3,4,5,6,7,8,9,10]
const num = 3
const division = (ary, num, container = {}) => {
	for (let page = 0; page < Math.ceil(ary.length / num); page++) {
	  container[page] = ary.slice(page * num, (page + 1) * num)
	}
	return container
}
// demo
division(ary, num, {}) // or division(ary, num, [])
)
code(Var)
return

::baoleimodel::
::baoleimoshi::
::baoleimodal::
Var =
(
var once = (f, cache, count = 0) => (...args) => ++count === 1 ? cache = f(...args) : cache

var getUser = () => {
    return new Promise((resolve, reject) => {
       setTimeout(function () {
            console.log(20190518201928, 'getUser success!')
            resolve('userName')
       }, 3000);
    })
}

var request = (user) => {
    return new Promise((resolve, reject) => {
       setTimeout(function () {
            resolve('request by ' + user)
       }, 3000);
    })
}

var once_getUser = once(getUser)

var test = async (num) => {
    // 假设这个是前提条件，且只执行一次
    const user = await once_getUser()
 
    // 这个是正式请求，要结合上面的值使用
    const data =  await request(user + num)

    return data
}

test('0').then(console.log)
test('1').then(console.log)
test('2').then(console.log)
test('3').then(console.log)
test('4').then(console.log)
test('5').then(console.log)
test('6').then(console.log)
)
code(Var)
Return

::dpr::
Var =
(
window.devicePixelRatio
)
code(Var)
return

::mvNode::
::mvDOM::
::movedom::
::copydom::
Var =
(
/**
 * 移动dom元素到指定目标位置
 *
 * @source {DOM} 你要移动的DOM
 * @target {DOM} 你要移动的位置
 */
const mvDOM = function (source, target) {
	// 深度拷贝（含子元素）
	let _source = source.cloneNode(true)
	// 删除本身
	source.remove()
	// 默认插入到容器最前面，如果想在后面可以这样处理：target.append(source)
	target.insertBefore(_source, target.firstChild)
}
)
code(Var)
return

::href::
Var =
(
window.location.href
)
code(Var)
return


::promiseall::
::promise.all::
::promise.a::
Var =
(
// 请注意，a和b都是一个promise对象。而且Promise.all返回的也是一个promise对象，所以它也是可以被await的。
Promise.all([a, b]).then(args => {
    const [a, b] = args
})
)
code(Var)
return

::console.save::
Var =
(
(function(console) {
    console.save = function(data, filename) {
        if (!data) {
            console.error('Console.save: No data')
            return;
        }
        if (!filename) filename = (+new Date) + 'console.json'
        if (typeof data === "object") {
            data = JSON.stringify(data, undefined, 4)
        }
        var blob = new Blob([data], { type: 'text/json' }),
            e = document.createEvent('MouseEvents'),
            a = document.createElement('a')

        a.download = filename
        a.href = window.URL.createObjectURL(blob)
        a.dataset.downloadurl = ['text/json', a.download, a.href].join(':')
        e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null)
        a.dispatchEvent(e)
    }
})(console)
)
code(Var)
return


::delayupload::
::delay.upload::
::delay-upload::
::delay_upload::
Var =
(
var upload = function (id) {
    console.log('开始同步文件, id为'： id)
}

var proxySync = ;(function(){
    var cache = [], // 一定时间内需要同步的id
             timer; // 定时器

    return function (id) {
        // 塞入缓存，等待上传
        cache.push(id)

        // 保证不会覆盖已经启动的定时器
        if ( timer ) {
            return;
        }

        timer = setTimeout(() => {
            // 上传
            upload( cache.join(',') )
            // 清空
            clearTimeout(timer); timer = null; cache.length = 0;
        }, 2000);
    }
}());
)
code(Var)
return